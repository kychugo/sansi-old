<!DOCTYPE html>
<html lang="zh">
<head>

<meta http-equiv="Content-Security-Policy" content="
default-src 'self'; 
script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://*.streamable.com https://cdn.heapanalytics.com; 
style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://fonts.googleapis.com; 
font-src 'self' https://cdnjs.cloudflare.com https://fonts.gstatic.com;
img-src 'self' https: data: https://*.streamable.com https://heapanalytics.com;
media-src 'self' https://youfulca.com https://*.streamable.com https://assets.mixkit.co https://taira-komori.net;
connect-src 'self' https://v1.hitokoto.cn https://chatapi.akash.network https://text.pollinations.ai https://gen.pollinations.ai  https://router.huggingface.co https://api.llm7.io https://*.streamable.com https://cdn.jsdelivr.net https://api-fawn-chi.vercel.app https://heapanalytics.com https://open.bigmodel.cn;
frame-src 'self' https://streamable.com https://kenchan20151.pyscriptapps.com https://kenchan20141.github.io https://sansi.vercel.app https://lyricschi.vercel.app https://penpalchi.vercel.app https://litstudy.vercel.app https://621d05f47d591.site123.me https://script.google.com https://www.i2ocr.com;
object-src 'none';
base-uri 'self';
form-action 'self';
">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>神思 2.0</title>

<!-- 添加到主畫面設定 -->
<meta name="application-name" content="神思">
<meta name="apple-mobile-web-app-title" content="神思">
<link rel="manifest" href="manifest.json">


<link rel="apple-touch-icon" href="https://i.ibb.co/tpYQMG6/SANSI.png">


<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">


<link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&display=swap" rel="stylesheet">


<!-- Android 圖示 -->
<link rel="icon" sizes="192x192" href="https://i.ibb.co/tpYQMG6/SANSI.png">

<link rel="icon" sizes="144x144" href="https://i.ibb.co/tpYQMG6/SANSI.png">

<link rel="icon" sizes="96x96" href="https://i.ibb.co/tpYQMG6/SANSI.png">


<!-- iOS 圖示 -->
<link rel="apple-touch-icon" sizes="180x180" href="https://i.ibb.co/tpYQMG6/SANSI.png">

<link rel="apple-touch-icon" sizes="152x152" href="https://i.ibb.co/tpYQMG6/SANSI.png">

<link rel="apple-touch-icon" sizes="120x120" href="https://i.ibb.co/tpYQMG6/SANSI.png">


<!-- 引入 Chart.js 以繪製雷達圖 -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>


<!-- === 新增：頁面右緣卡扣按鈕 === -->
<button id="sideMenuToggle" title="展開選單">
    <i class="fas fa-bars"></i>
</button>

<div id="sideMenu" class="side-menu-overlay">
    <div class="side-menu-content">
        <button class="side-menu-close" id="sideMenuClose">&times;</button>
        
       <div class="side-menu-items">
    <!-- 1. 工具一覽 (已添加 ID 以確保 JS 控制準確) -->
    <button class="side-menu-item" id="sideMenuToolsBtn" onclick="openToolsFromSideMenu()">
        <i class="fas fa-toolbox"></i>
        <span>工具一覽</span>
    </button>

    <!-- 2. 歷史紀錄 -->
    <button class="side-menu-item" onclick="openHistoryContainer()">
        <i class="fas fa-history"></i>
        <span>歷史紀錄</span>
    </button>

    <!-- 3. 返回主頁 (已移至此處，位於歷史紀錄下方) -->
    <button class="side-menu-item" id="sideMenuHomeBtn" onclick="returnToHome()" style="display: none;">
        <i class="fas fa-home"></i>
        <span>返回主頁</span>
    </button>
    
    <!-- 4. 音樂播放器 -->
    <button class="side-menu-item" onclick="toggleMusicPlayer()">
        <i class="fas fa-music"></i>
        <span>音樂播放器</span>
    </button>
</div>
    </div>
</div>



<!-- === 新增：返回主頁按鈕 === -->
<button id="homeBtn" onclick="returnToHome()" title="返回主頁">
    <i class="fas fa-home"></i>
</button>
	
<style>
/* === 全局基礎設定 === */
body {
    font-family: 'Noto Serif TC', 'cwTeXHei', 'cwTeXFangSong', 'cwTeXKai', 'cwTeXMing', 'PingFang TC', 'Microsoft JhengHei', serif;
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
    background: url('背景.png') center/cover fixed;
    padding-bottom: 60px; /* 為頁面內容設置底部內邊距，避免被音樂播放器遮擋 */
    transition: background-image 0.6s ease-in-out, background-color 0.6s ease-in-out;
}

h1 {
    text-align: center;
    color: #333;
}

/* === 返回主頁按鈕樣式 === */
#homeBtn {
    position: fixed;
    top: 20px;
    left: 20px; /* 左上角 */
    z-index: 9999;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background-color: rgba(0, 0, 0, 0.6); /* 半透明黑底 */
    color: white;
    border: 2px solid rgba(255, 255, 255, 0.5);
    font-size: 24px;
    cursor: pointer;
    display: none; /* 預設隱藏 */
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    transition: all 0.3s ease;
    backdrop-filter: blur(5px);
}

#homeBtn:hover {
    background-color: rgba(0, 0, 0, 0.8);
    transform: scale(1.1);
    border-color: #fff;
}

/* === 通用容器與佈局 === */
.box {
    background: rgba(220, 220, 220, 0.96);
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    padding: 20px;
    margin: 15px 0;
}

.category {
    margin-bottom: 20px;
}

.category h3 {
    font-size: 18px;
    margin-bottom: 10px;
    color: #fff; /* 白色文字，適配深色背景 */
    text-align: left;
}

/* 手機設備調整 */
@media (max-width: 600px) {
    .category {
        padding-left: 25px; /* 增加左內邊距，讓按鍵遠離左邊緣 */
    }

    #toolsList button {
        width: auto; /* 寬度自適應文字內容 */
        display: inline-block; /* 按鈕以行內塊元素顯示，配合置中 */
        margin: 10px 0; /* 調整為上下 10px，左右 0px，避免額外水平間距 */
        font-size: 14px; /* 保留字體大小 */
        padding: 8px 16px; /* 保留內邊距，提供適當空間 */
    }

    .category h3 {
        font-size: 16px; /* 保留標題字體大小 */
    }
}

.copyright-footer {
    position: fixed;
    bottom: 0;
    right: 0;
    padding: 5px 10px;
    background-color: #f1f1f1;
}

.copyright-footer p {
    margin: 0;
    font-size: 14px;
}

@media (max-width: 600px) {
    .copyright-footer p {
        font-size: 12px;
    }
}

/* === 背景動畫效果 === */
/* 晴天效果：太陽 */
.sun {
    position: absolute;
    top: 10%;
    left: 5%; /* 調整為靠左 */
    width: 100px;
    height: 100px;
    background-color: yellow;
    border-radius: 50%;
    box-shadow: 0 0 20px yellow;
    animation: sunGlow 2s infinite alternate;
    z-index: -1; /* 確保太陽在其他元素下方，避免遮擋按鍵 */
}

/* 平板設備調整 */
@media (max-width: 768px) {
    .sun {
        left: 5%;
        top: 5%;
        width: 100px;
        height: 100px;
    }
}

/* 手機設備調整 */
@media (max-width: 480px) {
    .sun {
        left: 2%;
        top: 2%;
        width: 80px;
        height: 80px;
    }
}

/* 太陽光芒動畫 */
@keyframes sunGlow {
    0% { box-shadow: 0 0 20px yellow; }
    100% { box-shadow: 0 0 40px yellow; }
}

/* 多雲效果：雲朵 */
.cloud {
    position: absolute;
    background-color: white;
    border-radius: 50%;
    opacity: 0.8;
    animation: cloudMove linear infinite;
}

@keyframes cloudMove {
    0% { transform: translateX(-100vw); }
    100% { transform: translateX(100vw); }
}

/* 下雨效果：雨滴 */
.raindrop {
    position: absolute;
    width: 2px;
    height: 10px;
    background-color: #ADD8E6; /* 淺藍色，更自然 */
    opacity: 0.7; /* 增加透明度 */
    animation: rainFall linear infinite;
}

@keyframes rainFall {
    0% { transform: translateY(-10px); }
    100% { transform: translateY(100vh); }
}

/* 下雪效果：雪花 */
.snowflake {
    position: absolute;
    background-color: #e0f7fa;
    border-radius: 50%;
    opacity: 0.7;
    animation: snowfall linear infinite;
}

@keyframes snowfall {
    0% { top: -10px; transform: translateX(0); }
    50% { transform: translateX(20px); }
    100% { top: 100vh; transform: translateX(0); }
}

/* === 標題樣式 === */
.title-container {
    background: none;
    padding: 0;
    position: relative;
    margin-bottom: 3rem;
    text-align: center;
}

.title-text {
    display: block;
    font-size: 3rem;
    color: #d1f2eb;
    text-shadow: 3px 3px 0 #7f8c8d;
    letter-spacing: 4px;
    animation: titleFloat 3s ease-in-out infinite;
}

/* === 按鈕基礎樣式 === */
button {
    background: #007bff;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.3s;
    margin: 5px;
}

button:hover {
    background: #0056b3;
}

.save-btn { background: #28a745; }
.save-btn:hover { background: #218838; }
.clear-btn { background: #dc3545; }
.clear-btn:hover { background: #c82333; }

/* === 表單輸入框美化 === */
select, textarea, input[type="text"] {
    width: 100%;
    padding: 12px 15px; /* 增加內邊距 */
    margin: 10px 0;
    border: 1px solid #dcdfe6; /* 更柔和的邊框顏色 */
    border-radius: 8px; /* 更大的圓角 */
    box-sizing: border-box;
    background-color: #fcfdfd; /* 非常淺的背景色 */
    font-size: 1.3em;
    color: #333;
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

select:focus, textarea:focus, input[type="text"]:focus {
    outline: none; /* 移除預設的 outline */
    border-color: #4A90E2; /* 焦點狀態下的邊框顏色 */
    box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.2); /* 模擬 glow 效果 */
}

textarea {
    resize: vertical;
    min-height: 80px; /* 設定最小高度 */
}

/* === 表格樣式 === */
table {
    width: 100%;
    border-collapse: collapse;
    margin: 10px 0;
}

th, td {
    border: 1px solid #ccc;
    padding: 10px;
    text-align: left;
    vertical-align: top;
    word-break: break-word;
}

th {
    background: #f0f0f0;
}

.table-container {
    overflow-x: auto;
    width: 100%;
}

.table-container table {
    width: 100%;
    border-collapse: collapse;
}

.table-container th, .table-container td {
    border: 1px solid #ccc;
    padding: 10px;
    text-align: left;
    vertical-align: top;
    word-break: break-word;
}

.table-container th:first-child, .table-container td:first-child { width: 60px; }
.table-container th:nth-child(2), .table-container td:nth-child(2),
.table-container th:nth-child(3), .table-container td:nth-child(3) { min-width: 100px; }
.table-container th:nth-child(4), .table-container td:nth-child(4),
.table-container th:nth-child(5), .table-container td:nth-child(5) { min-width: 150px; }

/* === 動畫 === */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

.tool-btn {
    animation: fadeIn 0.2s ease-in-out forwards;
    opacity: 0;
}

/* === 範疇按鍵樣式 === */
.category-buttons-container {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center; /* 讓按鈕在容器內居中 */
}

.btn-category {
    padding: 10px 20px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    transition: all 0.3s ease;
    border: 2px solid white;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
    background-color: rgba(142, 142, 147, 0.7); /* 半透明灰色 */
    color: white;
    backdrop-filter: blur(5px);
    margin: 0; /* 重置 margin */
}

.btn-category:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    filter: brightness(115%);
}

.btn-category.active {
    filter: brightness(115%);
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.7), 0 4px 12px rgba(0,0,0,0.25);
    transform: translateY(-2px);
}

/* Specific active colors */
#readingBtn.active { background-color: #28a745; }
#writingBtn.active { background-color: #007bff; }
#argumentBtn.active { background-color: #800080; }
#expandBtn.active { background-color: #dc3545; }
#booksBtn.active { background-color: #ffc107; }

/* Apply to the expand button as well */
#expandToolsBtn2 {
    padding: 10px 20px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    transition: all 0.3s ease;
    border: 2px solid white;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
    color: white;
    background-color: rgba(54, 187, 167, 0.8);
    backdrop-filter: blur(5px);
display: none; /* 新增這行 */
}

#expandToolsBtn2:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    filter: brightness(110%);
}

/* === 工具列表 === */
#toolsContainer {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    background-color: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    overflow: hidden; /* 隱藏頁面滾動條 */
}

#toolsList {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    max-height: 80vh; /* 設置最大高度 */
    overflow-y: auto; /* 啟用垂直滾動條 */
    position: relative; /* 保持相對定位於容器內 */
}

#toolsList button {
    opacity: 0;
    margin: 10px 0;
    padding: 10px 20px;
    font-size: 16px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

#closeToolsBtn {
    position: absolute;
    top: 20px;
    right: 20px;
    background-color: #dc3545;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 4px;
    cursor: pointer;
}

#commentResult {
    width: 100%;
    overflow-wrap: break-word;
}

#toggleOverviewBtn {
    background-color: #A9A9A9; /* 灰色背景 */
    color: white; /* 白色文字 */
}

#toggleOverviewBtn:hover {
    background-color: #808080; /* 懸停時深灰色 */
}

#manuscriptPaperBtn {
    background-color: #17a2b8;
}
#manuscriptPaperBtn:hover {
    background-color: #138496;
}

#writingContainer, #readingContainer, #booksContainer, #expandContainer, #argumentContainer {
    display: none;
}
#argumentTopicSelectionArea, #argumentCustomTopicArea, #argumentWritingArea, #argumentGuideArea {
    margin-top: 10px;
}

/* === 音樂播放器樣式優化 === */
#music-player {
    position: fixed;
    bottom: 0px;
    left: 0;
    width: 100%;
    background-color: rgba(40, 40, 40, 0.95); /* 深色半透明背景 */
    backdrop-filter: blur(5px);
    color: white;
    padding: 10px 15px;
    display: none; /* 預設隱藏 */
    align-items: center;
    justify-content: space-between;
    z-index: 1002;
    box-sizing: border-box;
    font-size: 14px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 -4px 10px rgba(0,0,0,0.3);
}

#music-player .controls { 
    display: flex; 
    align-items: center; 
    flex-shrink: 0; 
    gap: 10px;
}

/* 播放按鈕樣式 */
#music-player .controls button#play-pause {
    background: none;
    border: 1px solid rgba(255,255,255,0.3);
    border-radius: 50%;
    color: white;
    font-size: 14px;
    cursor: pointer;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    margin: 0; /* 重置 margin */
}

#music-player .controls button#play-pause:hover {
    background-color: white;
    color: #333;
    border-color: white;
    transform: scale(1.1);
}

#music-player .controls select { 
    background: #555; 
    color: white; 
    border: none; 
    padding: 6px 10px; 
    border-radius: 4px; 
    max-width: 150px; 
    cursor: pointer;
}

#music-player .progress { 
    flex: 1; 
    margin: 0 15px; 
    display: flex; 
    align-items: center; 
}
#music-player .progress input[type="range"] { 
    width: 100%; 
    cursor: pointer;
}

#music-player .mode { 
    margin-left: 10px; 
    flex-shrink: 0; 
}
#music-player .mode select { 
    background: #555; 
    color: white; 
    border: none; 
    padding: 6px 10px; 
    border-radius: 4px; 
    cursor: pointer;
}

/* 隱藏 (箭頭) 按鈕樣式 */
#music-player .hide-btn { 
    background: none; 
    border: none; 
    color: #aaa; 
    font-size: 18px; 
    cursor: pointer; 
    margin-left: 15px; 
    transition: color 0.3s;
    padding: 5px;
}
#music-player .hide-btn:hover {
    color: white;
    transform: translateY(2px);
}

/* 懸浮顯示按鈕 (替代原本的鋼琴 Emoji) */
#show-player {
    position: fixed;
    bottom: 25px;
    right: 20px;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background-color: rgba(30, 30, 30, 0.9);
    color: white;
    border: 2px solid rgba(255, 255, 255, 0.2);
    cursor: pointer;
    z-index: 1003;
    font-size: 20px;
    display: none; /* JS 會控制顯示 */
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    backdrop-filter: blur(5px);
    padding: 0;
}

#show-player:hover {
    transform: scale(1.15) rotate(15deg);
    background-color: #007bff; /* 懸停變藍色 */
    border-color: white;
    box-shadow: 0 6px 20px rgba(0, 123, 255, 0.4);
}

@media (max-width: 600px) {
    #music-player { flex-wrap: wrap; padding: 5px; }
    #music-player .controls select { max-width: 100px; font-size: 12px; }
    #music-player .mode select { font-size: 12px; }
    #progress-bar-music {
        height: 10px;
        -webkit-appearance: none;
        appearance: none;
        background: #ddd;
        border-radius: 5px;
    }
    #progress-bar-music::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        background: #007bff;
        border-radius: 50%;
        cursor: pointer;
    }
    #progress-bar-music::-moz-range-thumb {
        width: 20px;
        height: 20px;
        background: #007bff;
        border-radius: 50%;
        cursor: pointer;
    }
    #music-player .controls select, #music-player .mode select { max-width: 80px; padding: 3px; font-size: 12px; }
    #music-player .controls button, #music-player .hide-btn { padding: 5px; font-size: 16px; }
}

/* --- Styles for Tool 2 (語薈) --- */
:root {
    --bg-color: #f5f5f3;
    --text-color: #333;
    --primary-color: #6a7a7d;
    --secondary-color: #8f8f8f;
    --accent-color: #8c9ea1;
    --line-color: #c5c5c5;
    --shadow-color: rgba(0, 0, 0, 0.05);
    --highlight-bg-writing: rgba(230, 240, 245, 0.6);
    --highlight-bg-reading: rgba(245, 240, 230, 0.6);
    --font-main: 'Noto Serif TC', 'cwTeXHei', 'cwTeXFangSong', 'cwTeXKai', 'cwTeXMing', 'PingFang TC', 'Microsoft JhengHei', serif;
}

#toolsContainer2 {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--bg-color);
    z-index: 1005;
    overflow-y: auto;
    display: none;
    padding: 2rem 1rem;
    box-sizing: border-box;
    justify-content: center;
}

#closeToolsBtn2 {
    position: fixed;
    top: 15px;
    right: 25px;
    background-color: transparent;
    border: none;
    font-size: 2.5rem;
    font-weight: bold;
    color: #333;
    cursor: pointer;
    z-index: 1006;
    line-height: 1;
    padding: 5px 10px;
}

#closeToolsBtn2:hover { color: #d32f2f; }

.main-container {
    max-width: 1200px;
    width: 100%;
    position: relative;
    opacity: 0;
    transition: opacity 0.5s ease-in;
}

.main-container.loaded { opacity: 1; }

.floating-header {
    position: fixed;
    top: 15px;
    left: 20px;
    background-color: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(8px);
    padding: 5px 15px;
    border-radius: 30px;
    border: 1px solid #e0e0e0;
    z-index: 1000;
    box-shadow: 0 2px 10px var(--shadow-color);
    display: flex;
    align-items: center;
    gap: 10px;
}

#video-tour-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 0;
    display: flex;
    align-items: center;
}

#video-tour-btn .icon {
    width: 24px;
    height: 24px;
    fill: var(--primary-color);
    transition: fill 0.3s;
}

#video-tour-btn:hover .icon { fill: var(--accent-color); }

.floating-header h1 {
    font-size: 1.2rem;
    margin: 0;
    font-weight: 700;
    color: var(--primary-color);
}

.mind-map-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: auto auto 1fr auto;
    grid-template-areas:
    "core-ai core-ai"
    "foundations foundations"
    "writing reading"
    "assignments support";
    gap: 50px 20px;
    width: 100%;
    margin-top: 80px;
    padding-bottom: 50px;
    position: relative;
}

.node {
    display: flex;
    align-items: center;
    text-align: center;
    padding: 8px 12px;
    background-color: #fff;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    box-shadow: 0 3px 12px var(--shadow-color);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    position: relative;
}

.node:hover {
    transform: translateY(-4px) scale(1.02);
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
    border-color: var(--accent-color);
}

.node a {
    text-decoration: none;
    color: inherit;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-size: 0.95rem;
    gap: 8px;
    width: 100%;
}

.node .icon {
    width: 24px;
    height: 24px;
    margin-right: 0;
    fill: var(--primary-color);
}

#toolsContainer2 .category {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    margin-bottom: 0; /* Reset margin for this context */
}

#writing, #reading {
    padding: 20px;
    border-radius: 12px;
}
#writing { background-color: var(--highlight-bg-writing); }
#reading { background-color: var(--highlight-bg-reading); }

.category-title {
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--primary-color);
    padding-bottom: 5px;
    border-bottom: 2px solid var(--accent-color);
    display: flex;
    align-items: center;
    margin-bottom: 10px;
}

.category-title .icon {
    width: 24px;
    height: 24px;
    margin-right: 8px;
    fill: var(--primary-color);
}

.sub-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    width: 100%;
}

.sub-group-title {
    font-weight: bold;
    color: var(--secondary-color);
    font-size: 0.9rem;
    position: relative;
    padding-bottom: 5px;
    margin-bottom: 5px;
}
.sub-group-title::after{
    content: '';
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 30px;
    height: 1px;
    background-color: var(--line-color);
}

.node.level-2 { font-size: 0.9rem; }
.node.level-3 { font-size: 0.85rem; padding: 6px 10px; }
.node.level-3 a { font-weight: 400; flex-direction: row; }

/* Grid Area Assignments */
#core-ai { grid-area: core-ai; }
#foundations {
    grid-area: foundations;
    display: flex;
    flex-direction: row;
    justify-content: center;
    gap: 500px;
    align-items: flex-start;
}
#writing { grid-area: writing; }
#reading { grid-area: reading; }
#assignments { grid-area: assignments; }
#support { grid-area: support; }

.connector-svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    pointer-events: none;
}

.connector-svg line {
    stroke: var(--line-color);
    stroke-width: 1.5;
    stroke-dasharray: 4;
    animation: dash 1s linear infinite;
}

@keyframes dash {
    to { stroke-dashoffset: -20; }
}

#yuyilu-toggle { cursor: pointer; }
.yuyilu-grades {
    display: flex;
    flex-direction: column;
    gap: 8px;
    width: 100%;
    max-height: 500px;
    overflow: hidden;
    transition: max-height 0.5s ease-in-out, opacity 0.3s ease-in-out;
    opacity: 1;
}
.yuyilu-grades.collapsed {
    max-height: 0;
    opacity: 0;
    pointer-events: none;
}

.foundation-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
}

@media (max-width: 768px) {
    #toolsContainer2 { padding: 1rem 0.5rem; }
    .floating-header { top: 10px; left: 10px; }

    .mind-map-container {
        margin-top: 70px;
        grid-template-columns: 1fr;
        grid-template-rows: auto;
        grid-template-areas:
        "core-ai"
        "foundations"
        "writing"
        "reading"
        "assignments"
        "support";
        gap: 40px;
    }

    #foundations {
        flex-direction: row;
        justify-content: space-between;
        align-items: flex-start;
        width: 90%;
        margin: 0 auto;
        gap: 10px;
    }

    #writing, #reading { padding: 15px; }
}

/* --- Preview Modal Styles --- */
.preview-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: none; /* 預設隱藏 */
    justify-content: center;
    align-items: center;
    z-index: 2000;
    padding: 1rem;
    box-sizing: border-box;
}

.preview-modal-content {
    background-color: #fff;
    border-radius: 12px;
    box-shadow: 0 5px 25px rgba(0,0,0,0.2);
    width: 90%;
    height: 90%;
    max-width: 1000px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    position: relative;
}

.preview-close-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    background: rgba(255, 255, 255, 0.7);
    border: none;
    border-radius: 50%;
    width: 36px;
    height: 36px;
    font-size: 1.5rem;
    font-weight: bold;
    color: #333;
    cursor: pointer;
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.3s, color 0.3s;
    z-index: 2010;
}
.preview-close-btn:hover {
    color: #fff;
    background-color: #d32f2f;
}

.preview-modal-body {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    height: 100%;
}

#previewIframe {
    width: 100%;
    flex-grow: 1; /* 佔據大部分空間 */
    border: none;
    border-top-left-radius: 12px;
    border-top-right-radius: 12px;
    min-height: 60%; /* 確保預覽畫面有足夠高度 */
}

.preview-modal-footer {
    padding: 16px;
    background-color: #f7f9fa;
    border-top: 1px solid #e0e0e0;
    display: flex;
    align-items: flex-start;
    gap: 16px;
    overflow-y: auto;
    max-height: 40%;
    flex-shrink: 0;
}

.preview-description {
    font-size: 0.95rem;
    color: #333;
    line-height: 1.6;
    text-align: left;
    flex-grow: 1;
}

.preview-goto-btn {
    background: #007bff url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white' width='18px' height='18px'%3E%3Cpath d='M0 0h24v24H0z' fill='none'/%3E%3Cpath d='M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z'/%3E%3C/svg%3E") no-repeat 15px center;
    background-size: 18px 18px;
    color: white;
    padding: 10px 20px 10px 40px;
    border: none;
    border-radius: 20px;
    text-decoration: none;
    font-size: 1rem;
    font-weight: bold;
    transition: background-color 0.3s;
    cursor: pointer;
    flex-shrink: 0; /* 防止按鈕縮小 */
}
.preview-goto-btn:hover {
    background-color: #0056b3;
    color: white;
}

@media (max-width: 600px) {
    .preview-modal-footer {
        flex-direction: column;
        align-items: stretch;
    }
    .preview-goto-btn {
        align-self: flex-end; /* 在堆疊時仍將按鈕靠右 */
    }
}

/* --- Video Modal Styles --- */
.video-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    display: none; /* 預設隱藏 */
    justify-content: center;
    align-items: center;
    z-index: 2100;
    cursor: pointer;
}

.video-modal-content {
    position: relative;
    width: 90%;
    max-width: 960px;
    padding-top: 56.25%; /* 16:9 Aspect Ratio */
    height: 0;
    cursor: default;
}

.video-modal-content iframe {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: none;
}

/* --- 功能選擇與間距 --- */
.function-selector-wrapper {
    padding: 20px; /* 增加內邊距，讓內部元素有更多呼吸空間 */
    background-color: rgba(59, 184, 219, 0.2);
    border-left: 5px solid #0288d1;
    margin-top: 30px;
    margin-bottom: 35px; /* 明顯增加與下方內容的間距 */
    border-radius: 8px; /* 圓角稍大，視覺上更柔和 */
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}
.function-selector-wrapper label {
    font-size: 1.1em; /* 標題字體稍大，更突出 */
    font-weight: bold;
    color: #01579b;
    display: block;
    margin-bottom: 15px; /* 增加與下拉選單的間距 */
}
.function-selector-wrapper select {
    font-size: 1em; /* 統一下拉選單字體大小 */
    padding: 8px; /* 適度增加下拉選單的內邊距 */
}

/* 為各個功能容器內的主要區塊（div）增加統一的下間距 */
#writingContentContainer > div,
#expandContentContainer > div,
#argumentContentContainer > div {
    margin-bottom: 30px;
}

/* 清除最後一個元素的下邊距 */
#writingContentContainer > div:last-child,
#expandContentContainer > div:last-child,
#argumentContentContainer > div:last-child {
    margin-bottom: 0;
}

/* 針對閱讀區塊，其內部結構不同，單獨調整其子元素的間距 */
#readingInputArea > *:not(div#readingResult) {
    margin-bottom: 20px;
}

/* --- 改寫說明 UI --- */
.rewrite-explanation-container { margin-top: 20px; }
.rewrite-explanation-card {
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.04);
}
.rewrite-explanation-card h3 {
    margin-top: 0;
    margin-bottom: 15px;
    color: #343a40;
    font-size: 1.2em;
    border-bottom: 2px solid #e9ecef;
    padding-bottom: 10px;
}
.explanation-point {
    display: flex;
    align-items: flex-start;
    margin-bottom: 15px;
}
.explanation-point:last-child { margin-bottom: 0; }
.explanation-number {
    flex-shrink: 0;
    width: 28px;
    height: 28px;
    background-color: #0288d1;
    color: white;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    margin-right: 15px;
    font-size: 1em;
}
.explanation-text {
    font-size: 1em;
    line-height: 1.6;
    color: #495057;
}

/* --- 點評語氣標籤 --- */
.tone-selector-label {
    display: block; /* 確保標籤獨佔一行 */
    margin-top: 25px; /* 增加與上方元素的距離 */
}

/* --- 題目顯示區塊樣式 --- */
#topicResult, #argumentTopicResult, #expandTopicResult {
    position: relative;
    padding: 12px 15px;
    margin-bottom: 20px;
    border-left: 5px solid #2A9689;
    border-radius: 4px;
    font-size: 1em;
    display: none;
    background-color: transparent !important; /* 強制容器本身透明 */
    z-index: 0;
}

#topicResult::before,
#argumentTopicResult::before,
#expandTopicResult::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(54, 187, 167, 0.5); /* 半透明背景 */
    border-radius: inherit;
    z-index: -1;
}

#topicResult td, #argumentTopicResult td, #expandTopicResult td { background-color: #ffffff !important; }
#topicResult th, #argumentTopicResult th, #expandTopicResult th { background-color: #f0f0f0 !important; }
#topicResult:not(:empty), #argumentTopicResult:not(:empty), #expandTopicResult:not(:empty) { display: block; }

#topicSelectionArea > label,
#argumentTopicSelectionArea > label,
#expandTopicSelectionArea > label {
    display: block;
    margin-bottom: 10px;
}

/* --- 按鍵美化修訂 --- */
.topic-buttons-container {
    display: flex;
    gap: 15px;
    align-items: center;
    margin-top: 10px;
}

.btn {
    padding: 8px 18px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    color: white;
    transition: all 0.3s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
    border: 3px solid transparent;
    background-color: #8E8E93; /* 中性灰 */
}

.btn:not(.active):hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    filter: brightness(110%);
}

.btn-generate.active { background-color: #4A90E2; }
.btn-custom.active { background-color: #7B68EE; }

.btn.active {
    filter: brightness(115%);
    border: 3px solid white;
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
    transform: translateY(-2px);
}

.btn .fas { font-size: 15px; }

/* --- 剩餘字數計數器 --- */
#charCount {
    margin-top: 0px;
    margin-bottom: 20px;
    text-align: right;
    font-size: 0.9em;
    color: #666;
}

/* --- 禁用按鈕樣式 --- */
button:disabled, .btn:disabled, .btn-icon-confirm:disabled, .btn-action:disabled {
    background-color: #cccccc !important;
    border-color: #cccccc !important;
    color: #666666;
    cursor: not-allowed;
    opacity: 0.6;
    box-shadow: none;
    transform: none;
}

/* --- 儲存/清除圖示按鍵 --- */
.action-buttons-container {
    display: flex;
    justify-content: flex-end;
    gap: 12px;
    margin-top: 10px;
    align-items: center;
}

.btn-add-icon { background-color: rgba(0, 123, 255, 0.8); }

.btn-icon-action {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    border: none;
    color: white;
    font-size: 16px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0,0,0,0.15);
    transition: all 0.2s ease-in-out;
    margin: 0;
}

.btn-icon-action:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    filter: brightness(110%);
}

.btn-icon-action:active { transform: translateY(0); }
.btn-save-icon { background-color: rgba(26, 117, 149, 0.8); }
.btn-clear-icon { background-color: rgba(220, 53, 69, 0.8); }

/* --- 確認圖示按鍵 --- */
.btn-icon-confirm {
    width: 44px;
    height: 44px;
    border-radius: 50%;
    background-color: #28a745;
    border: none;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 20px;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    transition: all 0.2s ease-in-out;
}

.btn-icon-confirm:hover {
    transform: scale(1.1);
    filter: brightness(110%);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
}

.btn-icon-confirm:active { transform: scale(1.15); }

/* --- 書籍討論資訊 --- */
.discussion-info {
    text-align: left;
    background-color: #e9ecef;
    color: #495057;
    padding: 12px 15px;
    border-radius: 8px;
    margin: 0 auto 15px auto;
    line-height: 1.6;
    width: 95%;
    box-sizing: border-box;
}

.discussion-info strong { color: #0056b3; }
.discussion-info table { width: 100%; border-collapse: collapse; }
.discussion-info td { border: none; padding: 4px 0; vertical-align: top; }
.discussion-info td:first-child { width: 90px; font-weight: bold; color: #0056b3; }

/* --- 聊天介面 --- */
#chatHistory, #writingChatHistory, #argumentChatHistory, #writingGuideChatHistory {
    background-color: #f0f4f8;
    border: 1px solid #dde3ea;
    border-radius: 12px;
    padding: 20px 15px;
    margin-top: 15px;
    margin-bottom: 15px;
    max-height: 400px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
}

.message-bubble {
    padding: 10px 15px;
    border-radius: 18px;
    line-height: 1.5;
    font-size: 14px;
    word-wrap: break-word;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    max-width: 80%;
    animation: fadeIn 0.3s ease-in-out;
    margin-bottom: 15px;
}

.message-bubble.ai-message {
    background-color: #ffffff;
    color: #333;
    align-self: flex-start;
    border-top-left-radius: 4px;
}

.message-bubble.user-message {
    background-color: rgba(45, 153, 102, 0.9);
    color: white;
    align-self: flex-end;
    border-top-right-radius: 4px;
}

#chatInputContainer, #writingChatInputContainer, #argumentChatInputContainer, #writingGuideChatInputContainer {
    display: none;
    align-items: center;
    gap: 10px;
    margin-top: 15px;
}

#chatInputContainer textarea, #writingChatInputContainer textarea, #argumentChatInputContainer textarea, #writingGuideChatInputContainer textarea {
    flex-grow: 1;
    margin: 0;
}

#initialDiscussionForm { display: block; }

.books-modal {
    display: none;
    position: fixed;
    z-index: 1010;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.6);
    justify-content: center;
    align-items: center;
}

.books-modal .modal-content {
    background-color: #fefefe;
    margin: auto;
    padding: 25px;
    border: 1px solid #888;
    width: 90%;
    max-width: 500px;
    border-radius: 12px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    position: relative;
    animation: fadeIn 0.4s;
}

.books-modal .close-modal-btn {
    color: #aaa;
    position: absolute;
    top: 10px;
    right: 15px;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}
.books-modal .close-modal-btn:hover { color: black; }
#discussionControlButtons { margin-bottom: 20px; }
#booksButtons { display: none; }

/* --- 執行動作按鈕 --- */
.btn-action {
    display: inline-block;
    padding: 10px 20px;
    margin: 15px 0 5px 0;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    font-family: 'Noto Serif TC', 'cwTeXHei', 'cwTeXFangSong', 'cwTeXKai', 'cwTeXMing', 'PingFang TC', 'Microsoft JhengHei', serif;
    transition: all 0.3s ease;
    border: 2px solid white;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
    color: white;
    background-color: rgba(31, 122, 85, 0.8);
    backdrop-filter: blur(5px);
    text-align: center;
    text-decoration: none;
}

.btn-action:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    filter: brightness(110%);
}

/* --- 懸浮視窗編輯器 --- */
textarea:not(.no-modal-editor), input[type="text"]:not(.no-modal-editor) {
    cursor: pointer;
    background-color: #f0f8ff;
    transition: background-color 0.2s;
}

textarea:not(.no-modal-editor):hover, input[type="text"]:not(.no-modal-editor):hover {
    background-color: #e6f2ff;
}

.outline-modal-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.65);
    z-index: 2000;
    justify-content: center;
    align-items: center;
    padding: 1rem;
    box-sizing: border-box;
}

/* === 懸浮視窗容器設定 (修訂版：限制高度防止爆版) === */
.outline-modal-content {
    background-color: #fdfdfd;
    padding: 25px;
    border-radius: 12px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    width: 90%;
    max-width: 900px;       /* 稍微加寬，讓電腦版視野更好 */
    max-height: 90vh;       /* 關鍵：限制高度最多佔螢幕 90% */
    position: relative;
    animation: fadeIn 0.3s;
    display: flex;          /* 使用 Flexbox 排版 */
    flex-direction: column; /* 垂直排列子元素 */
    box-sizing: border-box; /* 確保 padding 不會撐大寬度 */
}

.outline-modal-content h3 {
    margin-top: 0;
    margin-bottom: 15px;
    color: #2A9689;
    font-size: 1.2em;
    font-weight: 700;
    border-bottom: 2px dashed #a8dad5;
    padding-bottom: 12px;
    text-align: center;
    letter-spacing: 2px;
    flex-shrink: 0;         /* 防止標題被壓縮 */
}

/* === 懸浮視窗輸入框設定 (修訂版：自動填滿空間) === */
#modal-textarea {
    width: 100%;
    box-sizing: border-box !important;
    
    /* 字體與原稿紙設定 (保持不變) */
    font-family: 'Noto Serif TC', 'Songti TC', serif !important;
    font-size: 20px !important;       
    line-height: 40px !important;     
    color: #2c3e50;                   
    letter-spacing: 2px;              
    background-color: #fffcf6;        
    background-image: 
        linear-gradient(transparent 39px, rgba(42, 150, 137, 0.3) 39px, rgba(42, 150, 137, 0.3) 40px, transparent 40px),
        linear-gradient(90deg, transparent 39px, rgba(0,0,0,0.03) 39px, rgba(0,0,0,0.03) 40px, transparent 40px);
    background-size: 40px 40px;       
    background-attachment: local;     
    border: 2px solid #8baea8;        
    border-radius: 8px;               
    padding: 0 18px !important;       
    box-shadow: inset 0 0 40px rgba(0,0,0,0.02);

    /* === 關鍵修訂：高度控制 === */
    flex-grow: 1;           /* 自動填滿視窗剩餘高度 */
    height: auto;           /* 讓 flex 控制高度 */
    min-height: 200px;      /* 設定最小高度 */
    resize: none;           /* 禁止手動拉伸，避免破壞佈局 */
    overflow-y: auto;       /* 內容過多時，只有輸入框內部會滾動 */
    margin-bottom: 10px;
}

/* 手機版適配 (保持不變，但需確保優先級) */
@media (max-width: 600px) {
    #modal-textarea {
        font-size: 16px !important;
        line-height: 32px !important;
        background-image: 
            linear-gradient(transparent 31px, rgba(42, 150, 137, 0.3) 31px, rgba(42, 150, 137, 0.3) 32px, transparent 32px),
            linear-gradient(90deg, transparent 31px, rgba(0,0,0,0.03) 31px, rgba(0,0,0,0.03) 32px, transparent 32px);
        background-size: 32px 32px !important;
        padding: 0 10px !important;
    }
}

.outline-modal-content .modal-buttons { 
    text-align: right; 
    margin-top: 5px; 
    flex-shrink: 0;         /* 防止按鈕被壓縮 */
}

.outline-modal-content .modal-buttons { text-align: right; margin-top: 15px; }
.outline-modal-content .preview-close-btn { position: absolute; top: 10px; right: 10px; }

#structure, #writingTone, #writingReviewer, #readingTone, #booksTone, #expandTone, #argumentOutlineTone, #argumentWritingTone, #argumentReviewer {
    font-size: 1.05em;
    padding: 6px 10px;
}

#booksContainer #initialDiscussionForm input[type="text"],
#booksContainer #initialDiscussionForm textarea {
    font-size: 1rem !important;
    padding: 10px 12px;
}

/* --- 答題步驟卡片 --- */
.steps-container {
    margin-top: 20px;
    padding-left: 15px;
    border-left: 4px solid #4A90E2;
}

.step-card {
    background-color: #f7f9fc;
    border-radius: 8px;
    padding: 15px 20px;
    margin-bottom: 20px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.08);
    transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}

.step-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.12);
}

.step-card:last-child { margin-bottom: 0; }
.step-title {
    font-weight: bold;
    font-size: 1.1em;
    color: #0056b3;
    margin-bottom: 10px;
}
.step-content {
    font-size: 1em;
    line-height: 1.7;
    color: #333;
}

#customTopicArea input[type="text"], #customTopicArea textarea, #argumentCustomTopicArea input[type="text"], #expandCustomTopicInputArea input[type="text"], #expandCustomTopicInputArea textarea, #expandGuideArea input[type="text"], #expandGuideArea textarea {
    font-size: 1rem !important;
    padding: 10px 12px;
}

/* --- 評等系統 --- */
.grading-container {
    margin-top: 25px;
    border-top: 2px dashed #aeb6bf;
    padding-top: 20px;
    max-width: 100%;
    overflow-x: hidden;
}

.grading-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    align-items: flex-start;
}

.grading-scores, .grading-radar {
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.04);
    max-width: 100%;
    box-sizing: border-box;
    width: 90%;
    margin: 0 auto;
}

.grading-scores h3, .grading-radar h3 {
    margin-top: 0;
    color: #343a40;
    border-bottom: 2px solid #e9ecef;
    padding-bottom: 10px;
    margin-bottom: 15px;
}

.score-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    gap: 10px;
}

.score-item label {
    font-weight: bold;
    color: #495057;
    flex-shrink: 0;
    margin-right: 10px;
}

.score-item .slider-container {
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
    max-width: 160px;
}

.score-item .progress-bar-container {
    width: 120px;
    height: 12px;
    background-color: #e9ecef;
    border-radius: 6px;
    overflow: hidden;
    border: 1px solid #ced4da;
}

.score-item .progress-bar-fill {
    height: 100%;
    width: 0%;
    background-color: #007bff;
    border-radius: 6px;
    transition: width 0.4s ease-in-out;
}

.score-item .score-display {
    font-weight: bold;
    width: 25px;
    text-align: center;
    color: #0056b3;
}

.total-score-container {
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid #dee2e6;
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    flex-wrap: wrap;
}

#finalGrade, [id$="FinalGrade"] {
    font-size: 2.5em;
    font-weight: bold;
    color: #d9534f;
    line-height: 1;
}

#totalScoreDisplay, [id$="TotalScoreDisplay"] {
    font-size: 1.2em;
    font-weight: bold;
    color: #333;
}

.radar-chart-container {
    position: relative;
    aspect-ratio: 4 / 3;
    max-height: 350px;
    width: 100%;
}

@media (max-width: 768px) {
    .grading-grid {
        grid-template-columns: 1fr;
        width: 95%;
        margin: 0 auto;
        justify-items: center;
    }
    .grading-scores, .grading-radar {
        padding: 15px;
        width: 95%;
        max-width: 95%;
    }
    .radar-chart-container {
        aspect-ratio: 1 / 1;
        max-height: 400px;
    }
    .score-item { flex-wrap: wrap; }
    .score-item label { width: 100%; margin-bottom: 5px; }
    .score-item .slider-container { max-width: 100%; }
}

/* --- 儲存HTML按鈕 --- */
.result-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.btn-save-html {
    position: static;
    margin-top: 20px;
    width: 40px;
    height: 40px;
    background-color: rgba(106, 122, 138, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.5);
    border-radius: 50%;
    color: white;
    display: none;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    z-index: 10;
    opacity: 0.85;
    transition: all 0.2s ease-in-out;
    padding: 0;
    margin-left: auto;
    margin-right: auto;
}

.btn-save-html:hover {
    opacity: 1;
    transform: scale(1.1);
    background-color: rgba(90, 105, 120, 0.9);
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

.btn-save-html svg { width: 20px; height: 20px; }
#booksButtons #save-books-html-btn { background-color: rgba(74, 144, 226, 0.8); }

#writingReviewResultContainer, #argumentReviewResultContainer {
    display: flex;
    flex-direction: column;
    gap: 15px;
    width: 100%;
}

/* --- 點評範疇 UI --- */
.scope-selector-container {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    margin-top: 10px;
    padding: 15px;
    background-color: rgba(0, 0, 0, 0.05);
    border-radius: 8px;
    border: 1px solid rgba(0, 0, 0, 0.08);
}

.scope-label input[type="checkbox"] { display: none; }

.scope-label {
    display: inline-block;
    padding: 8px 16px;
    border-radius: 20px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.3s ease;
    user-select: none;
    border: 1px solid transparent;
    background-color: #f0f0f0;
    color: #555;
}

.scope-label:not(.disabled):hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    border-color: #007bff;
}

.scope-label.active {
    background-color: #007bff;
    color: white;
    font-weight: bold;
    box-shadow: 0 2px 5px rgba(0, 123, 255, 0.3);
}

.scope-label.disabled {
    background-color: #e9ecef;
    color: #adb5bd;
    cursor: not-allowed;
    opacity: 0.7;
}

.scope-label.all-scope.active {
    background-color: #4F5B93;
    color: white;
    box-shadow: 0 2px 5px rgba(79, 91, 147, 0.3);
}

/* --- 解題指引輸入框 --- */
#writingGuideTopicInput {
    padding: 15px;
    border: 2px solid #4A90E2;
    border-radius: 8px;
    width: 100%;
    margin-bottom: 15px;
    font-size: 1.2rem;
    transition: all 0.3s ease;
    background-color: #fcfdfd;
}
#writingGuideTopicInput:focus {
    border-color: #28a745;
    box-shadow: 0 0 10px rgba(40, 167, 69, 0.2);
    outline: none;
}

/* 2. 標題區塊 */
.guide-section-header {
    padding: 10px 15px;
    margin-bottom: 15px;
    background-color: rgba(255, 255, 255, 0.8);
    border-radius: 0 8px 8px 0;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}
.guide-section-header h3 {
    margin: 0;
    font-size: 1.3rem;
    display: flex;
    align-items: center;
    gap: 10px;
}

/* 3. 介紹卡片 (Intro) */
.guide-intro-card {
    background: #fff;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.05);
    margin-bottom: 25px;
    line-height: 1.8;
    color: #444;
    font-size: 1.05rem;
    border: 1px solid #eee;
}

/* === 動漫風格角色選擇卡片 === */
.category-cards-wrapper {
    width: 100%;
    display: flex;
    justify-content: center;
    perspective: 1000px;
    padding: 10px 0 30px 0;
}

.category-cards-container {
    display: flex;
    gap: 20px;
    overflow-x: auto;
    padding: 10px 20px;
    scrollbar-width: none;
    -ms-overflow-style: none;
    justify-content: center;
}

.category-cards-container::-webkit-scrollbar { display: none; }

.anime-card {
    position: relative;
    width: 120px;
    height: 180px;
    border-radius: 15px;
    background-image: var(--bg-img);
    background-size: cover;
    background-position: center;
    cursor: pointer;
    transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    overflow: hidden;
    flex-shrink: 0;
    border: 1px solid rgba(255,255,255,0.2);
    filter: grayscale(30%);
}

.card-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.2) 60%, rgba(0,0,0,0) 100%);
    transition: all 0.3s ease;
}

.card-border-effect {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: 15px;
    border: 2px solid transparent;
    transition: all 0.3s ease;
    z-index: 5;
    box-sizing: border-box;
}

.card-content {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    align-items: center;
    padding-bottom: 20px;
    z-index: 10;
}

.card-icon-container {
    font-size: 28px;
    color: rgba(255, 255, 255, 0.8);
    margin-bottom: auto;
    margin-top: 40px;
    transform: translateY(10px);
    transition: all 0.4s ease;
    opacity: 0.8;
    text-shadow: 0 2px 10px rgba(0,0,0,0.5);
}

.card-text {
    text-align: center;
    transform: translateY(0);
    transition: transform 0.3s ease;
}

.card-zh {
    display: block;
    font-size: 18px;
    font-weight: bold;
    color: #fff;
    text-shadow: 0 2px 4px rgba(0,0,0,0.8);
    letter-spacing: 1px;
white-space: nowrap !important; /* 核心指令：強制文字不換行 */
    width: 100%;                    /* 確保文字容器寬度足夠 */
    text-align: center;             /* 確保文字水平置中 */
    display: block;                 /* 確保它是區塊元素 */
}

.card-en {
    display: block;
    font-size: 10px;
    font-weight: 700;
    color: rgba(255,255,255,0.6);
    letter-spacing: 2px;
    margin-top: 4px;
    text-transform: uppercase;
    font-family: 'Arial', sans-serif;
white-space: nowrap !important; /* 核心指令：強制文字不換行 */
}

.anime-card:hover {
    transform: translateY(-15px) scale(1.05);
    filter: grayscale(0%);
    box-shadow: 0 15px 30px rgba(0,0,0,0.5), 0 0 20px rgba(0, 191, 255, 0.6);
    z-index: 20;
}

.anime-card:hover .card-border-effect { border-color: rgba(255, 255, 255, 0.9); }
.anime-card:hover .card-overlay { background: linear-gradient(to top, rgba(0,86,179,0.8) 0%, rgba(0,0,0,0) 100%); }
.anime-card:hover .card-icon-container {
    transform: translateY(-5px) scale(1.2);
    color: #fff;
    text-shadow: 0 0 10px #00bfff;
}

.anime-card.active {
    transform: translateY(-8px) scale(1.02);
    filter: grayscale(0%);
    box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), 0 0 50px rgba(255, 215, 0, 0.4);
    z-index: 15;
}

.anime-card.active .card-border-effect {
    border: 3px solid #FFD700;
    box-shadow: inset 0 0 15px rgba(255, 215, 0, 0.5);
}

.anime-card.active .card-overlay { background: linear-gradient(to top, rgba(184, 134, 11, 0.8) 0%, rgba(0,0,0,0.1) 100%); }
.anime-card.active .card-zh { color: #fff; text-shadow: 0 0 10px #FFD700; }
.anime-card.active .card-en { color: #FFD700; }
.anime-card.active .card-icon-container { color: #FFD700; transform: translateY(-5px) scale(1.1); }

@media (max-width: 600px) {
    .category-cards-container {
        justify-content: flex-start;
        padding-bottom: 20px;
    }
    .anime-card { width: 100px; height: 150px; }
    .card-zh { font-size: 16px; }
    .card-en { font-size: 8px; }
    .card-icon-container { font-size: 24px; margin-top: 30px; }
}

/* ========================================= */
/* === 卡片排版終極修復 (Fix Layout V2) === */
/* ========================================= */

/* 1. 外層網格：確保每張卡片寬度被限制 */
.guide-grid-3 {
    display: grid;
    grid-template-columns: repeat(3, 1fr); /* 強制三欄均分 */
    gap: 25px;            /* 卡片之間的間距 */
    width: 100%;
    box-sizing: border-box; /* 確保 padding 不會撐爆寬度 */
}

/* 2. 卡片本體：垂直排列 (標題在上，內容在下) */
.guide-card {
    display: flex !important;
    flex-direction: column !important;
    background: #fff;
    border-radius: 12px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.05);
    height: 100%;         /* 讓卡片撐滿網格高度 */
    overflow: hidden;     /* 關鍵：防止內容溢出圓角 */
    position: relative;
    box-sizing: border-box; /* 關鍵：讓寬度包含邊框與內距 */
}

/* 3. 標題區域：藍色部分 */
.card-title, .seed-header {
    flex-shrink: 0;       /* 禁止標題被壓縮 */
    width: 100%;
    padding: 15px;
    font-size: 1.2rem;
    font-weight: bold;
    text-align: center;
    box-sizing: border-box; /* 防止標題文字撐爆 */
}

/* 4. 內容區域：白色文字部分 (修復重點) */
.card-content, .seed-body {
    flex-grow: 1;         /* 填滿剩餘高度 */
    padding: 20px;        /* 內邊距 */
    
    /* === 文字排版核心修復 === */
    font-size: 1rem;
    line-height: 1.8;     /* 增加行高，讓文字不擠 */
    color: #444;
    text-align: justify;  /* 左右對齊，讓方塊更整齊 */
    
    /* 強制換行設定 */
    white-space: normal !important;
    word-wrap: break-word !important;
    overflow-wrap: break-word !important;
    word-break: break-word; /* 針對中英文混排優化 */
    
    width: 100%;          /* 確保不超過卡片寬度 */
    box-sizing: border-box; /* 關鍵：讓 padding 包含在寬度內 */
}

/* 5. 手機版適配：變成單欄 */
@media (max-width: 768px) {
    .guide-grid-3 {
        grid-template-columns: 1fr !important; /* 手機強制一欄 */
    }
    .guide-card {
        margin-bottom: 20px;
        height: auto !important; /* 手機版高度自動 */
    }
}

/* 5. 針對不同類型的卡片配色 */
/* 藍色卡片 (心情/題眼) */
.emotion-card {
    border-top: 5px solid #4A90E2;
}
.emotion-card .card-title {
    background-color: #f0f7ff;
    color: #0056b3;
}

/* 綠色卡片 (種子/寫作方向) */
.seed-card {
    border-top: 5px solid #28a745;
}
.seed-card .seed-header {
    background-color: #f0fff4;
    color: #155724;
}

/* 6. 種子卡片內的段落標題 */
.seed-body p {
    margin-bottom: 12px;
}
.seed-body p:last-child {
    margin-bottom: 0;
}
.seed-body strong {
    color: #155724 !important; /* 改為深綠色 */
    display: inline-block;
    margin-bottom: 5px;
    font-size: 1.05rem;
    border-bottom: 2px solid rgba(40, 167, 69, 0.4) !important; /* 改為淺綠色底線 */
}

/* 7. 手機版適配：強制單欄 */
@media (max-width: 768px) {
    .guide-grid-3 {
        grid-template-columns: 1fr !important; /* 強制變為單欄 */
        gap: 30px; /* 增加手機版卡片間距 */
        margin-bottom: 30px;
    }
    
    .guide-card {
        height: auto !important; /* 手機版高度完全自動 */
        margin-bottom: 0; 
    }
}

/* 8. 下載按鈕容器防重疊修正 */
.result-wrapper {
    margin-top: 40px; /* 確保按鈕與上方內容有足夠距離 */
    padding-top: 20px;
    border-top: 1px dashed #ddd; /* 增加分隔線，視覺上區隔 */
    width: 100%;
    clear: both; /* 清除浮動 */
}

#sideMenuToggle {
    position: fixed;
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    z-index: 9998;
    width: 20px;
    height: 60px;
    border-radius: 8px 0 0 8px;
    background-color: rgba(0, 0, 0, 0.6);
    color: white;
    border: none;
    border-right: none;
    font-size: 14px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: -2px 0 8px rgba(0, 0, 0, 0.3);
    transition: all 0.3s ease;
    backdrop-filter: blur(5px);
}

#sideMenuToggle:hover {
    background-color: rgba(0, 0, 0, 0.8);
    width: 24px;
}

.side-menu-overlay {
    position: fixed;
    top: 50%;
    right: -80px;
    transform: translateY(-50%);
    width: 60px;
    height: auto;
    background-color: rgba(30, 30, 30, 0.95);
    backdrop-filter: blur(10px);
    z-index: 9999;
    transition: right 0.3s ease;
    box-shadow: -4px 0 15px rgba(0, 0, 0, 0.5);
    border-radius: 12px 0 0 12px;
    padding: 10px 0;
}

.side-menu-overlay.active {
    right: 0;
}

.side-menu-content {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    padding: 0;
}

.side-menu-close {
    display: none; /* 移除獨立關閉鍵 */
}

.side-menu-items {
    margin-top: 0;
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 5px;
}

.side-menu-item {
    width: 100%;
    padding: 12px 0;
    background-color: transparent;
    border: none;
    border-radius: 8px;
    color: white;
    font-size: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
}

.side-menu-item span {
    display: none; /* 隱藏文字 */
}

.side-menu-item:hover {
    background-color: rgba(255, 255, 255, 0.2);
    transform: scale(1.1);
}

.side-menu-item i {
    font-size: 24px;
    width: 100%;
    text-align: center;
}

/* 讓卡扣本身也能關閉選單 */
#sideMenuToggle.active {
    background-color: rgba(255, 100, 100, 0.8);
}



/* === 永遠隱藏主頁的「工具一覽」container（但保留代碼）=== */
#mainMenuBox ~ #toolsBox,
#toolsBox {
    display: none !important;
}

/* === 手機版：每行 2 張卡片，最後一張放大到兩張卡片寬 === */
@media (max-width: 600px) {
    .category-cards-wrapper {
        padding: 20px 0 50px 0;
    }

    .category-cards-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 24px;
        justify-items: center;
        padding: 10px 20px;
        overflow: hidden;
    }

    /* 正常卡片大小（前四張） */
    .anime-card {
        width: 120px !important;
        height: 180px !important;
        flex-shrink: 0;
    }

    /* 第 5 張卡片：放大到兩張卡片的總寬度並居中 */
    .category-cards-container .anime-card:nth-child(5) {
        grid-column: 1 / -1;
        width: calc(120px * 2 + 24px) !important;  /* 兩張寬 + gap */
        height: 130px !important;
        max-width: none;
    }

    /* 第 5 張卡片內文字圖標微調（可選，視覺更突出） */
    .category-cards-container .anime-card:nth-child(5) .card-zh {
        font-size: 22px;
    }
    .category-cards-container .anime-card:nth-child(5) .card-en {
        font-size: 13px;
    }
    .category-cards-container .anime-card:nth-child(5) .card-icon-container {
        font-size: 34px;
        margin-top: 45px;
    }

    .card-zh {
        font-size: 18px;
    }
    .card-icon-container {
        font-size: 28px;
        margin-top: 40px;
    }
}

/* === 煙花特效畫布 === */
#fireworksCanvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 99999; /* 確保在最上層 */
    pointer-events: none; /* 讓滑鼠點擊可以穿透煙花，不影響按鈕操作 */
    display: none; /* 預設隱藏 */
}

/* ========================================= */
/* === 神思專用：文藝風原稿紙 UI 設計 (RWD 終極版) === */
/* ========================================= */

/* --- 1. 電腦版預設樣式 (大格、大字) --- */
/* --- 1. 電腦版預設樣式 (大格、大字) --- */
/* 將原本長串的 ID 選擇器改成單純的 textarea，這樣所有多行輸入框都會生效 */
/* --- 1. 電腦版預設樣式 (大格、大字) --- */
/* 加入 input[type="text"] 讓單行輸入框（如書名、作者）也生效 */
textarea, input[type="text"] {
    /* 防止爆版核心設定 */
    box-sizing: border-box !important;
    width: 100% !important;
    max-width: 100% !important;
    
    /* 字體與行高 (配合 40px 格子) */
    font-family: 'Noto Serif TC', 'Songti TC', serif !important;
    font-size: 20px !important;       
    line-height: 40px !important;     
    color: #2c3e50;                   
    letter-spacing: 2px;              
    
    /* 原稿紙背景 (40px 高) */
    background-color: #fffcf6 !important;        
    background-image: 
        linear-gradient(transparent 39px, rgba(42, 150, 137, 0.3) 39px, rgba(42, 150, 137, 0.3) 40px, transparent 40px),
        linear-gradient(90deg, transparent 39px, rgba(0,0,0,0.03) 39px, rgba(0,0,0,0.03) 40px, transparent 40px) !important;
    background-size: 40px 40px !important;       
    background-attachment: local;     
    
    /* 邊框與陰影 */
    border: 2px solid #8baea8 !important;        
    border-radius: 8px !important;               
    padding: 0 18px !important;       
    box-shadow: 
        inset 0 0 40px rgba(0,0,0,0.02),  
        5px 5px 0px rgba(42, 150, 137, 0.15); 
        
    transition: all 0.3s ease;
    resize: vertical;                 
}

/* 互動效果 - 點擊時加深陰影 */
textarea:focus, input[type="text"]:focus {
    background-color: #fff !important;           
    border-color: #2A9689 !important;            
    outline: none;
    box-shadow: 
        inset 0 0 10px rgba(42, 150, 137, 0.1), 
        8px 8px 0px rgba(42, 150, 137, 0.25); 
    transform: translateY(-2px);      
}

/* Placeholder 樣式 */
textarea::placeholder, input[type="text"]::placeholder {
    color: rgba(42, 150, 137, 0.4);   
    font-style: italic;               
    font-size: 16px;
    letter-spacing: 1px;
}

/* --- 2. 手機版響應式調整 (螢幕寬度小於 600px) --- */
/* --- 2. 手機版響應式調整 (螢幕寬度小於 600px) --- */
@media (max-width: 600px) {
    /* 同樣加入 input[type="text"] */
    textarea, input[type="text"] {
        /* 字體縮小，適配窄螢幕 */
        font-size: 16px !important;
        letter-spacing: 1px !important;
        
        /* 行高縮小至 32px (更緊湊) */
        line-height: 32px !important;
        
        /* 重新繪製背景格線 (配合 32px 高度) */
        background-image: 
            /* 31px 透明 + 1px 線條 = 32px */
            linear-gradient(transparent 31px, rgba(42, 150, 137, 0.3) 31px, rgba(42, 150, 137, 0.3) 32px, transparent 32px),
            linear-gradient(90deg, transparent 31px, rgba(0,0,0,0.03) 31px, rgba(0,0,0,0.03) 32px, transparent 32px) !important;
        background-size: 32px 32px !important;
        
        /* 減少內邊距，爭取書寫空間 */
        padding: 0 10px !important;
        
        /* 縮小陰影 */
        box-shadow: 
            inset 0 0 20px rgba(0,0,0,0.02),  
            3px 3px 0px rgba(42, 150, 137, 0.15) !important;
    }
    
    /* 手機版聚焦效果微調 */
    textarea:focus, input[type="text"]:focus {
        box-shadow: 
            inset 0 0 10px rgba(42, 150, 137, 0.1), 
            4px 4px 0px rgba(42, 150, 137, 0.25) !important;
        transform: translateY(-1px); 
    }
}
/* 懸浮視窗標題美化 (通用) */
.outline-modal-content h3 {
    color: #2A9689;
    font-family: 'Noto Serif TC', serif;
    border-bottom: 2px dashed #a8dad5;
    padding-bottom: 12px;
    margin-bottom: 20px;
    text-align: center;
    letter-spacing: 2px;
}

	/* ========================================= */
/* === 灰藍色原稿紙風格：下拉選單專用樣式 === */
/* ========================================= */

select {
    /* 1. 基礎字體與排版 */
    font-family: 'Noto Serif TC', 'Songti TC', serif !important;
    font-size: 18px !important;
    font-weight: bold !important;
    line-height: 40px !important; /* 配合格線高度 */
    color: #455A64 !important;    /* 深灰藍文字 (Blue Grey 700) */
    letter-spacing: 1px;
    padding: 0 40px 0 15px !important; /* 右邊預留箭頭空間 */
    height: 44px !important;      /* 固定高度確保格線對齊 */
    width: 100%;
    margin: 10px 0;
    box-sizing: border-box;

    /* 2. 背景設定 - 灰藍色原稿紙 */
    background-color: #ECEFF1 !important; /* 淺灰藍底色 (Blue Grey 50) */
    
    /* 繪製底線：透明 -> 灰藍線條 -> 透明 + 自定義箭頭 */
    background-image:
        /* 格線：38px透明 + 2px 線條 = 40px */
        linear-gradient(transparent 38px, rgba(120, 144, 156, 0.4) 38px, rgba(120, 144, 156, 0.4) 40px, transparent 40px),
        /* 下拉箭頭圖示 (深灰藍色) */
        url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23455A64%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E") !important;
    
    background-repeat: no-repeat, no-repeat;
    background-position: center, right 15px center; /* 格線置中，箭頭靠右 */
    background-size: 40px 40px, 12px 12px;          /* 格線大小，箭頭大小 */
    background-attachment: local, scroll;           /* 讓背景隨內容滾動(雖然select很少滾動) */

    /* 3. 邊框與外觀 */
    border: 2px solid #90A4AE !important; /* 中灰藍邊框 (Blue Grey 300) */
    border-radius: 8px !important;
    
    /* 增加一點紙張厚度感 */
    box-shadow: 
        inset 0 0 20px rgba(255,255,255,0.5), /* 內部微光 */
        3px 3px 0px rgba(144, 164, 174, 0.3) !important; /* 右下角陰影 */
        
    /* 移除瀏覽器預設外觀 */
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    cursor: pointer;
    transition: all 0.3s ease;
}

/* 互動效果：滑鼠懸停或點擊時 */
select:focus, select:hover {
    background-color: #FFFFFF !important; /* 變亮 */
    border-color: #607D8B !important;     /* 邊框變深 (Blue Grey 500) */
    outline: none;
    transform: translateY(-2px);          /* 輕微浮起 */
    box-shadow: 
        inset 0 0 10px rgba(84, 110, 122, 0.1),
        5px 5px 0px rgba(84, 110, 122, 0.3) !important;
}

/* 針對音樂播放器內的小選單進行微調 (避免變得太大) */
#music-player .controls select, 
#music-player .mode select {
    height: 30px !important;
    line-height: 26px !important;
    font-size: 14px !important;
    padding: 0 25px 0 10px !important;
    background-size: 30px 30px, 10px 10px !important; /* 縮小格線和箭頭 */
    background-image:
        linear-gradient(transparent 28px, rgba(120, 144, 156, 0.4) 28px, rgba(120, 144, 156, 0.4) 30px, transparent 30px),
        url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23455A64%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E") !important;
}

/* 手機版響應式調整 */
@media (max-width: 600px) {
    select {
        font-size: 16px !important;
        height: 36px !important;
        line-height: 32px !important; /* 手機版格線高度縮小 */
        background-position: center, right 10px center;
        
        /* 重新繪製 32px 高度的格線 */
        background-image:
            linear-gradient(transparent 30px, rgba(120, 144, 156, 0.4) 30px, rgba(120, 144, 156, 0.4) 32px, transparent 32px),
            url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23455A64%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E") !important;
        background-size: 32px 32px, 10px 10px !important;
        
        box-shadow: 
            inset 0 0 10px rgba(255,255,255,0.5),
            2px 2px 0px rgba(144, 164, 174, 0.3) !important;
    }
}

/* ==========================================
   === 文藝風歷史紀錄卡片 (莫蘭迪色系) ===
   ========================================== */

/* 定義莫蘭迪色變數 */
:root {
    --morandi-bg: #fdfcf8;          /* 米白紙張底色 */
    --morandi-text: #5e5e5e;        /* 深灰文字 */
    --morandi-green: #8fa398;       /* 閱讀 - 灰綠 */
    --morandi-blue: #94a7b5;        /* 敘事 - 霧霾藍 */
    --morandi-purple: #b6a6ca;      /* 議論 - 香芋紫 */
    --morandi-red: #d69a92;         /* 拓展 - 豆沙紅 */
    --morandi-border: #e0ddd7;      /* 淺卡其邊框 */
    --morandi-shadow: rgba(149, 157, 165, 0.1);
}

/* 列表容器調整 */
.history-list-container {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); /* 改為網格排列 */
    gap: 20px;
    padding: 10px;
    max-height: 70vh;
    overflow-y: auto;
}

/* ==========================================
   === 歷史紀錄卡片：Note Card 打洞風格 ===
   ========================================== */

.history-card {
    /* 1. 基礎卡片設定 */
    background-color: var(--morandi-bg);
    border: 1px solid var(--morandi-border); /* 統一使用細邊框 */
    border-radius: 8px; 
    padding: 20px;
    position: relative;
    box-shadow: 4px 4px 0px rgba(0,0,0,0.03);
    transition: all 0.3s ease;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    overflow: hidden;

    /* 2. Note Card 關鍵樣式：打洞與分隔線 */
    padding-left: 55px !important; /* 左側留白給打洞區 */
    
    background-image: 
        /* A. 垂直分隔線 (模擬紅線或灰線，這裡用莫蘭迪灰 #e0ddd7) */
        linear-gradient(to right, transparent 39px, #e0ddd7 40px, transparent 41px),
        /* B. 打洞效果 (模擬孔洞，使用深灰色圓形 #d1cdc5) */
        radial-gradient(circle at 20px 50%, #d1cdc5 6px, transparent 7px);
    
    /* 設定背景圖層大小 */
    background-size: 
        100% 100%, /* 分隔線：撐滿整張卡片 */
        100% 35px; /* 打洞：每 35px 重複一顆 */
    
    /* 設定背景重複方式 */
    background-repeat: 
        no-repeat, /* 分隔線不重複 */
        repeat-y;  /* 打洞在垂直方向重複 */
        
    /* 設定起始位置 */
    background-position: 
        0 0,       /* 分隔線位置 */
        0 12px;    /* 打洞起始位置向下微調，避免切到頂部色條 */
}

/* 3. 頂部裝飾條 (保留您要求的頂部色條) */
.history-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 6px; /* 頂部色條高度 */
    background-color: #ccc; /* 預設顏色，會被下方 Theme 覆蓋 */
    opacity: 0.8;
    z-index: 1;
}

/* 4. 懸停效果 */
.history-card:hover {
    transform: translateY(-3px);
    box-shadow: 6px 6px 0px rgba(0,0,0,0.05);
    border-color: #d1cdc5;
    /* 確保 Hover 時不會出現左側粗色條，保持打洞風格 */
    border-left-width: 1px;
    border-left-style: solid;
}

/* 5. 顏色主題設定 (只改變頂部色條與標籤顏色) */

/* Theme 1 (灰綠) */
.history-card.history-theme-1::before { background-color: var(--m-color-1); }
.history-card.history-theme-1 .history-tag { background-color: var(--m-color-1); }
.history-card.history-theme-1:hover { border-left-color: var(--morandi-border); }

/* Theme 2 (霧霾藍) */
.history-card.history-theme-2::before { background-color: var(--m-color-2); }
.history-card.history-theme-2 .history-tag { background-color: var(--m-color-2); }
.history-card.history-theme-2:hover { border-left-color: var(--morandi-border); }

/* Theme 3 (香芋紫) */
.history-card.history-theme-3::before { background-color: var(--m-color-3); }
.history-card.history-theme-3 .history-tag { background-color: var(--m-color-3); }
.history-card.history-theme-3:hover { border-left-color: var(--morandi-border); }

/* Theme 4 (豆沙紅) */
.history-card.history-theme-4::before { background-color: var(--m-color-4); }
.history-card.history-theme-4 .history-tag { background-color: var(--m-color-4); }
.history-card.history-theme-4:hover { border-left-color: var(--morandi-border); }

/* Theme 5 (奶茶棕) */
.history-card.history-theme-5::before { background-color: var(--m-color-5); }
.history-card.history-theme-5 .history-tag { background-color: var(--m-color-5); }
.history-card.history-theme-5:hover { border-left-color: var(--morandi-border); }
/* 不同範疇的顏色標記 */
.history-card.type-reading { border-left-color: #28a745; }   /* 閱讀-綠 */
.history-card.type-narrative { border-left-color: #007bff; } /* 敘事-藍 */
.history-card.type-argument { border-left-color: #800080; }  /* 議論-紫 */
.history-card.type-expand { border-left-color: #dc3545; }    /* 拓展-紅 */



.history-meta {
    font-size: 0.85em;
    color: #888;
    margin-bottom: 5px;
}

.history-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 4px;
    background-color: #eee;
    color: #555;
    font-size: 0.8em;
    margin-right: 8px;
    font-weight: bold;
}

.history-title {
    font-size: 1.1em;
    font-weight: bold;
    color: #333;
    margin: 0;
    display: -webkit-box;
    -webkit-line-clamp: 1;
    -webkit-box-orient: vertical;
    overflow: hidden;
}

/* 操作區 (刪除按鈕) */
.history-actions {
    margin-top: 15px;
    display: flex;
    justify-content: flex-end;
    opacity: 0.6;
    transition: opacity 0.3s;
}

.history-card:hover .history-actions {
    opacity: 1;
}


.btn-delete-history {
    background-color: transparent;
    border: 1px solid #dc3545;
    color: #dc3545;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
}

.btn-delete-history:hover {
    background-color: #dc3545;
    color: white;
}

/* 3. 模態視窗內容美化 */
#historyModalContent {
    line-height: 1.6;
    font-size: 1.1em;
}

#historyModalContent h3 {
    border-bottom: 2px solid #eee;
    padding-bottom: 10px;
    margin-top: 20px;
    color: #0056b3;
}

/* 4. 新增：層級選單 (Grid Menu) 樣式 (Level 1 & 2) */
.history-grid-menu {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); /* 自動適應寬度 */
    gap: 15px;
    padding: 10px 0;
}

.history-folder-btn {
    background-color: #f8f9fa;
    border: 2px solid #e9ecef;
    border-radius: 12px;
    padding: 20px 10px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: #555;
    min-height: 100px; /* 確保按鈕有足夠高度 */
}

.history-folder-btn:hover {
    background-color: #fff;
    border-color: #007bff;
    transform: translateY(-3px);
    box-shadow: 0 4px 10px rgba(0, 123, 255, 0.15);
    color: #007bff;
}

.history-folder-btn i {
    font-size: 2em;
    margin-bottom: 10px;
    color: #6c757d;
    transition: color 0.3s ease;
}

.history-folder-btn:hover i {
    color: #007bff;
}

.history-folder-btn span {
    font-weight: bold;
    font-size: 1.1em;
}

/* 5. 新增：麵包屑導航樣式 */
.history-breadcrumb span:hover {
    text-decoration: underline;
}

/* 6. 新增：雷達圖圖片化樣式 (確保 Canvas 轉圖後在歷史紀錄中正確顯示) */
.radar-chart-history-img {
    width: 100% !important;
    max-width: 500px;
    height: auto !important;
    margin: 0 auto;
    display: block;
    border: 1px solid #eee; /* 選用：增加邊框讓圖表更清晰 */
    border-radius: 8px;
    padding: 10px;
    background-color: #fff;
}

	/* 確保歷史紀錄內的卡片容器不會有過多的上下留白 */
#historyContainer .category-cards-wrapper {
    margin-top: 0;
    margin-bottom: 0;
}

/* 讓麵包屑導航更明顯 */
.history-breadcrumb {
    transition: all 0.3s ease;
}
.history-breadcrumb span:hover {
    opacity: 0.8;
}

/* === 新增：標頭的低調清空按鈕 === */
.history-clear-btn {
    background: transparent;
    border: 1px solid transparent; /* 預設無邊框 */
    color: #aaa; /* 淺灰色，非常低調 */
    font-size: 1.2rem;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
}

.history-clear-btn:hover {
    color: #d9534f; /* 懸停時才變紅 */
    background-color: rgba(217, 83, 79, 0.1); /* 淡淡的紅色背景 */
    transform: rotate(15deg); /* 增加一點點互動趣味 */
}


/* 內容佈局 */
.history-info {
    flex-grow: 1;
}

/* 標題樣式：襯線字體，文藝感 */
.history-title {
    font-family: 'Noto Serif TC', serif;
    font-size: 1.15em;
    font-weight: 600;
    color: #4a4a4a;
    margin: 10px 0;
    line-height: 1.5;
    
    /* 多行省略 */
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
}

/* 日期與標籤區域 */
.history-meta {
    display: flex;
    align-items: center;
    margin-bottom: 12px;
    padding-bottom: 10px;
    border-bottom: 1px dashed var(--morandi-border); /* 虛線分隔 */
}

.history-date {
    font-family: 'Courier New', monospace; /* 打字機字體 */
    font-size: 0.85em;
    color: #999;
    letter-spacing: 1px;
}

/* 範疇標籤 (像貼紙) */
.history-tag {
    font-size: 0.75em;
    padding: 2px 8px;
    border-radius: 4px;
    margin-right: auto; /* 將日期推到右邊 */
    color: #fff;
    font-weight: normal;
    letter-spacing: 1px;
}



	
/* 刪除按鈕美化 */
.btn-delete-history {
    background: transparent;
    border: none;
    color: #bfaea8; /* 淺紅棕色 */
    font-size: 1.1em;
    cursor: pointer;
    transition: all 0.2s;
    padding: 5px;
    border-radius: 50%;
}

.btn-delete-history:hover {
    color: #d69a92;
    background-color: rgba(214, 154, 146, 0.1);
    transform: scale(1.1);
}

/* ==========================================
   === 歷史紀錄樣式修訂 (多色卡片 & 導航美化) ===
   ========================================== */

/* 1. 定義 5 種莫蘭迪輪替色 (用於同一列表中的不同卡片) */
/* 讓同一個列表中的卡片擁有不同顏色，以作區分 */
.history-card.accent-1::before { background-color: #8fa398; } /* 灰綠 */
.history-card.accent-1 .history-tag { background-color: #8fa398; }
.history-card.accent-1:hover { border-color: #8fa398; }

.history-card.accent-2::before { background-color: #94a7b5; } /* 霧霾藍 */
.history-card.accent-2 .history-tag { background-color: #94a7b5; }
.history-card.accent-2:hover { border-color: #94a7b5; }

.history-card.accent-3::before { background-color: #b6a6ca; } /* 香芋紫 */
.history-card.accent-3 .history-tag { background-color: #b6a6ca; }
.history-card.accent-3:hover { border-color: #b6a6ca; }

.history-card.accent-4::before { background-color: #d69a92; } /* 豆沙紅 */
.history-card.accent-4 .history-tag { background-color: #d69a92; }
.history-card.accent-4:hover { border-color: #d69a92; }

.history-card.accent-5::before { background-color: #c7b299; } /* 奶茶棕 */
.history-card.accent-5 .history-tag { background-color: #c7b299; }
.history-card.accent-5:hover { border-color: #c7b299; }

/* 2. 麵包屑導航 (顏色區分修訂) */
.history-breadcrumb {
    background-color: transparent !important;
    border: none !important;
    border-bottom: 1px dashed #d1cdc5 !important;
    padding: 10px 5px !important;
    margin-bottom: 25px;
    font-size: 1rem;
    color: #999; /* 分隔符顏色 */
    display: flex;
    align-items: center;
    gap: 8px;
}

/* 第一層：主範疇 (藍色，可點擊) */
.history-breadcrumb span[onclick*="renderHistoryCategories"] {
    color: #007bff !important; 
    font-weight: 900;
    cursor: pointer;
}

/* 第二層：子功能分類 (深灰色，可點擊) */
.history-breadcrumb span[onclick*="enterHistoryCategory"] {
    color: #555 !important; 
    font-weight: bold;
    cursor: pointer;
    transition: color 0.3s;
}
.history-breadcrumb span[onclick*="enterHistoryCategory"]:hover {
    color: #007bff !important;
    text-decoration: underline;
}

/* 第三層：當前頁面 (霧霾藍，不可點擊) */
.history-breadcrumb span#breadcrumb-sub {
    color: #94a7b5 !important; 
    font-weight: bold;
    padding: 2px 4px;
    background-color: rgba(148, 167, 181, 0.1);
    border-radius: 4px;
}

/* 分隔符號 */
.history-breadcrumb span[id^="breadcrumb-sep"] {
    color: #ccc !important;
    font-weight: normal;
}

/* 3. 卡片細節微調 (確保日期與標籤排版) */
.history-meta {
    border-bottom: 1px dashed #e0ddd7;
    padding-bottom: 8px;
    margin-bottom: 10px;
    display: flex; /* 確保左右對齊 */
    justify-content: space-between; /* 標籤靠左，日期靠右 */
    align-items: center;
}

.history-date {
    font-family: 'Courier New', monospace;
    font-size: 0.85em;
    color: #aaa;
    letter-spacing: 0px;
    margin-left: auto; /* 強制靠右 */
}

.history-tag {
    color: white;
    font-size: 0.75em;
    padding: 2px 8px;
    border-radius: 4px;
    font-weight: normal;
    letter-spacing: 1px;
}

/* 手機版適配 */
@media (max-width: 600px) {
    .history-list-container {
        grid-template-columns: 1fr; /* 手機單欄 */
    }
}

	/* 搜尋到的卡片高亮動畫 */
@keyframes highlight-card {
    0% { transform: scale(1); box-shadow: 0 0 0 rgba(40, 167, 69, 0); }
    50% { transform: scale(1.02); box-shadow: 0 0 20px rgba(40, 167, 69, 0.5); border-left-color: #28a745; }
    100% { transform: scale(1); box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
}

.history-card.highlighted {
    animation: highlight-card 1.5s ease-in-out;
    background-color: #f0fff4; /* 淡淡的綠色背景 */
}

	/* === 定義莫蘭迪色系變數 === */
:root {
    --m-color-1: #8fa398; /* 灰綠 */
    --m-color-2: #94a7b5; /* 霧霾藍 */
    --m-color-3: #b6a6ca; /* 香芋紫 */
    --m-color-4: #d69a92; /* 豆沙紅 */
    --m-color-5: #c7b299; /* 奶茶棕 */
}

/* === 修改：歷史紀錄導航列 (麵包屑) === */
/* 需求三：主範疇要莫迪蘭色，不要藍色 */
.history-breadcrumb span[onclick*="renderHistoryCategories"] {
    color: #6a7a7d !important; /* 莫蘭迪深灰藍 */
    font-weight: 900;
    cursor: pointer;
    transition: color 0.3s;
}
.history-breadcrumb span[onclick*="renderHistoryCategories"]:hover {
    color: #8c9ea1 !important;
}

/* === 修改：子功能按鈕 (Level 2) 的顏色邏輯 === */
/* 需求一：子功能卡片要不同顏色 */
.history-folder-btn.history-theme-1 { border-color: var(--m-color-1); color: var(--m-color-1); }
.history-folder-btn.history-theme-1 i { color: var(--m-color-1); }
.history-folder-btn.history-theme-1:hover { background-color: var(--m-color-1); color: white; }
.history-folder-btn.history-theme-1:hover i { color: white; }

.history-folder-btn.history-theme-2 { border-color: var(--m-color-2); color: var(--m-color-2); }
.history-folder-btn.history-theme-2 i { color: var(--m-color-2); }
.history-folder-btn.history-theme-2:hover { background-color: var(--m-color-2); color: white; }
.history-folder-btn.history-theme-2:hover i { color: white; }

.history-folder-btn.history-theme-3 { border-color: var(--m-color-3); color: var(--m-color-3); }
.history-folder-btn.history-theme-3 i { color: var(--m-color-3); }
.history-folder-btn.history-theme-3:hover { background-color: var(--m-color-3); color: white; }
.history-folder-btn.history-theme-3:hover i { color: white; }

.history-folder-btn.history-theme-4 { border-color: var(--m-color-4); color: var(--m-color-4); }
.history-folder-btn.history-theme-4 i { color: var(--m-color-4); }
.history-folder-btn.history-theme-4:hover { background-color: var(--m-color-4); color: white; }
.history-folder-btn.history-theme-4:hover i { color: white; }

.history-folder-btn.history-theme-5 { border-color: var(--m-color-5); color: var(--m-color-5); }
.history-folder-btn.history-theme-5 i { color: var(--m-color-5); }
.history-folder-btn.history-theme-5:hover { background-color: var(--m-color-5); color: white; }
.history-folder-btn.history-theme-5:hover i { color: white; }

/* === 修改：紀錄卡片 (Level 3) 的顏色邏輯 === */
/* 需求：卡片左側不要有色條，保留頂部色條(::before)與標籤顏色 */

/* 確保所有主題卡片的左邊框回歸預設樣式 (無粗色條) */
.history-card {
    border-left: 1px solid var(--morandi-border) !important;
}

/* Theme 1 (灰綠) */
.history-card.history-theme-1::before { background-color: var(--m-color-1); }
.history-card.history-theme-1 .history-tag { background-color: var(--m-color-1); }
/* 確保 hover 時也不會出現左側色條，只加深陰影 */
.history-card.history-theme-1:hover { border-left-color: var(--morandi-border); }

/* Theme 2 (霧霾藍) */
.history-card.history-theme-2::before { background-color: var(--m-color-2); }
.history-card.history-theme-2 .history-tag { background-color: var(--m-color-2); }
.history-card.history-theme-2:hover { border-left-color: var(--morandi-border); }

/* Theme 3 (香芋紫) */
.history-card.history-theme-3::before { background-color: var(--m-color-3); }
.history-card.history-theme-3 .history-tag { background-color: var(--m-color-3); }
.history-card.history-theme-3:hover { border-left-color: var(--morandi-border); }

/* Theme 4 (豆沙紅) */
.history-card.history-theme-4::before { background-color: var(--m-color-4); }
.history-card.history-theme-4 .history-tag { background-color: var(--m-color-4); }
.history-card.history-theme-4:hover { border-left-color: var(--morandi-border); }

/* Theme 5 (奶茶棕) */
.history-card.history-theme-5::before { background-color: var(--m-color-5); }
.history-card.history-theme-5 .history-tag { background-color: var(--m-color-5); }
.history-card.history-theme-5:hover { border-left-color: var(--morandi-border); }

/* === 歷史紀錄：輸入內容優化樣式 === */
.history-input-card {
    background-color: #fdfdfd;
    border: 1px solid #e0e0e0;
    border-left: 5px solid #6a7a7d; /* 莫蘭迪深灰藍裝飾線 */
    border-radius: 6px;
    padding: 20px;
    margin-bottom: 25px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}

.history-input-header {
    margin-top: 0;
    margin-bottom: 15px;
    color: #4a4a4a;
    font-size: 1.1em;
    font-weight: bold;
    display: flex;
    align-items: center;
    gap: 8px;
    border-bottom: 1px dashed #ddd;
    padding-bottom: 10px;
}

.history-input-body {
    font-family: 'Noto Serif TC', serif; /* 保持文藝字體 */
    font-size: 1rem;
    line-height: 1.8; /* 增加行高，避免文字擠在一起 */
    color: #333;
    white-space: pre-wrap; /* 保留換行 */
    word-wrap: break-word;
}

/* 自動將「標籤」加粗的樣式 (配合 JS 使用) */
.history-label-bold {
    font-weight: 700;
    color: #2c3e50;
    background-color: rgba(0,0,0,0.03);
    padding: 2px 6px;
    border-radius: 4px;
    margin-right: 5px;
}

	/* === 歷史紀錄：結構化顯示優化 === */
.history-parsed-container {
    display: flex;
    flex-direction: column;
    gap: 15px; /* 區塊間距 */
}

.history-item-block {
    background-color: transparent;
}

.history-item-label {
    display: block;
    font-size: 0.95em;
    font-weight: bold;
    color: #2A9689; /* 使用你的主題綠色 */
    margin-bottom: 6px;
    display: flex;
    align-items: center;
    gap: 6px;
}

/* 標題前的小裝飾 */
.history-item-label::before {
    content: '';
    display: block;
    width: 4px;
    height: 14px;
    background-color: #2A9689;
    border-radius: 2px;
}

.history-item-content {
    background-color: #f7f9fa; /* 淺灰背景，區分內容 */
    border: 1px solid #e1e4e8;
    border-radius: 8px;
    padding: 12px 15px;
    font-size: 1rem;
    line-height: 1.8;
    color: #333;
    font-family: 'Noto Serif TC', serif;
    white-space: pre-wrap; /* 關鍵：保留詩詞的換行 */
    word-break: break-word;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.02); /* 內陰影增加層次感 */
}

	/* === 歷史紀錄：結構化顯示優化 (莫蘭迪色系版) === */

/* 定義顏色對應類別 */
.history-theme-context-1 { --current-theme-color: var(--m-color-1); } /* 灰綠 */
.history-theme-context-2 { --current-theme-color: var(--m-color-2); } /* 霧霾藍 */
.history-theme-context-3 { --current-theme-color: var(--m-color-3); } /* 香芋紫 */
.history-theme-context-4 { --current-theme-color: var(--m-color-4); } /* 豆沙紅 */
.history-theme-context-5 { --current-theme-color: var(--m-color-5); } /* 奶茶棕 */

/* 預設顏色 (防呆) */
.history-parsed-container {
    --current-theme-color: #6a7a7d; 
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.history-item-block {
    background-color: transparent;
}

/* 標題樣式：使用動態變數 */
.history-item-label {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 1em;
    font-weight: bold;
    color: var(--current-theme-color); /* 跟隨主題色 */
    margin-bottom: 8px;
    padding-left: 2px;
}

/* 標題前的裝飾小圓點 */
.history-item-label::before {
    content: '';
    display: block;
    width: 8px;
    height: 8px;
    background-color: var(--current-theme-color); /* 跟隨主題色 */
    border-radius: 50%;
    opacity: 0.8;
}

/* 內容區塊樣式 */
.history-item-content {
    background-color: #fcfcfc;
    border: 1px solid #e1e4e8;
    /* 左側加上粗邊框，顏色跟隨主題，增強識別度 */
    border-left: 4px solid var(--current-theme-color); 
    border-radius: 4px; /* 稍微方一點，更有文件感 */
    padding: 12px 16px;
    font-size: 1rem;
    line-height: 1.8;
    color: #444;
    font-family: 'Noto Serif TC', serif;
    white-space: pre-wrap;
    word-break: break-word;
}

	/* === 歷史紀錄：標題原地編輯樣式 === */
.history-title {
    cursor: text; /* 提示用戶這是文字 */
    transition: background-color 0.2s;
    border-radius: 4px;
    padding: 2px 4px;
    margin: -2px -4px; /* 抵消 padding，保持位置不變 */
}

.history-title:hover {
    background-color: rgba(0, 0, 0, 0.05); /* 懸停時給一點提示 */
}

/* 編輯模式下的輸入框樣式 */
.history-title-input {
    font-family: 'Noto Serif TC', serif; /* 保持原有字體 */
    font-size: 1em; /* 保持原有大小 */
    font-weight: bold;
    color: #333;
    width: 100%;
    border: 1px solid #2A9689; /* 編輯時顯示綠色邊框 */
    border-radius: 4px;
    padding: 2px 4px;
    background-color: #fff;
    outline: none;
    box-shadow: 0 0 5px rgba(42, 150, 137, 0.3);
    margin: 0;
}

	/* === 新增：通用過渡動畫 === */
.fade-in-up {
    /* 使用 cubic-bezier 讓動畫更有質感，不是線性的死板移動 */
    animation: fadeUpEnter 0.5s cubic-bezier(0.19, 1, 0.22, 1) forwards;
    opacity: 0; /* 預設隱藏，由動畫控制變為可見 */
}

@keyframes fadeUpEnter {
    0% {
        opacity: 0;
        transform: translateY(15px) scale(0.98); /* 稍微縮小並向下偏移 */
    }
    100% {
        opacity: 1;
        transform: translateY(0) scale(1); /* 回復原狀 */
    }
}

	/* === 新增：頁面收縮退場動畫 === */
.page-exit-shrink {
    /* 0.4秒完成，使用 ease-in 讓開始慢結束快，感覺像被吸走 */
    animation: shrinkFadeOut 0.4s cubic-bezier(0.32, 0, 0.67, 0) forwards;
    transform-origin: center 20vh; /* 設定縮放中心點在視窗上方偏中，視覺更自然 */
    pointer-events: none; /* 動畫播放時禁止點擊，防止誤觸 */
}

@keyframes shrinkFadeOut {
    0% {
        opacity: 1;
        transform: scale(1);
    }
    100% {
        opacity: 0;
        transform: scale(0.92) translateY(20px); /* 縮小並稍微往下沉 */
    }
}

/* === 新增：主頁選單進場特效 (配合退場) === */
.home-enter-pop {
    animation: popIn 0.5s cubic-bezier(0.19, 1, 0.22, 1) forwards;
    opacity: 0;
}

@keyframes popIn {
    0% {
        opacity: 0;
        transform: scale(1.05); /* 主頁從稍微放大的狀態回復，產生景深感 */
    }
    100% {
        opacity: 1;
        transform: scale(1);
    }
}

	/* 針對音樂播放器內的小選單進行微調 (改為簡約純淨風格) */
#music-player .controls select, 
#music-player .mode select {
    height: 30px !important;
    line-height: 26px !important;
    font-size: 14px !important;
    padding: 0 30px 0 10px !important; /* 右側留空間給箭頭 */
    
    /* === 樣式重置：去除原稿紙背景 === */
    background-color: rgba(255, 255, 255, 0.1) !important; /* 低調的半透明背景 */
    color: #fff !important; /* 白色文字 */
    border: 1px solid rgba(255, 255, 255, 0.2) !important; /* 極細的半透明邊框 */
    border-radius: 20px !important; /* 圓潤的膠囊狀 */
    box-shadow: none !important; /* 去除原本的紙張厚度陰影 */
    
    /* === 僅保留白色箭頭 === */
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e") !important;
    background-repeat: no-repeat !important;
    background-position: right 8px center !important;
    background-size: 14px 14px !important;
    
    transition: all 0.3s ease;
}

/* 互動效果：滑鼠懸停時 */
#music-player .controls select:hover, 
#music-player .mode select:hover {
    background-color: rgba(255, 255, 255, 0.2) !important; /* 稍微變亮 */
    border-color: rgba(255, 255, 255, 0.5) !important;
    transform: translateY(0) !important; /* 取消原有的浮起效果，保持穩定 */
}

/* 確保下拉後的選項是深色底 (避免在某些瀏覽器變白底黑字) */
#music-player select option {
    background-color: #333;
    color: white;
    padding: 5px;
}
	
</style>

<script>
// 頁面載入完成後，為所有 img 加上 lazy loading（包括動態生成的）
document.addEventListener("DOMContentLoaded", function() {
    document.querySelectorAll('img').forEach(img => {
        if (!img.hasAttribute('loading')) {
            img.setAttribute('loading', 'lazy');
        }
    });
});
// 觀察器：未來若有動態插入的圖片也自動加上
const observer = new MutationObserver(mutations => {
    mutations.forEach(mutation => {
        mutation.addedNodes.forEach(node => {
            if (node.nodeType === 1) { // 元素節點
                if (node.tagName === 'IMG' && !node.hasAttribute('loading')) {
                    node.setAttribute('loading', 'lazy');
                }
                node.querySelectorAll && node.querySelectorAll('img').forEach(img => {
                    if (!img.hasAttribute('loading')) {
                        img.setAttribute('loading', 'lazy');
                    }
                });
            }
        });
    });
});
observer.observe(document.body, { childList: true, subtree: true });
</script>


	
</head>
<body>


<div class="title-container">
<h1>
<span class="title-text">神思2.0</span>
</h1>
    
</div>


<div id="hitokoto-container" class="box">
<div id="hitokoto"></div>
<div id="hitokoto-footer">
<span id="hitokoto-from"></span>
<button id="refresh-btn"><i class="fas fa-sync-alt"></i></button>
</div>
</div>

	<!-- DSE 倒數日曆容器 -->
<div class="box" id="dse-countdown-box">
    <!-- 標題部分 (移除下拉選單，回歸純文字) -->
    <div class="dse-header">距離與DSE中文科分手尚餘</div>

    <!-- 主要顯示區域：左邊選單 + 右邊倒數 -->
    <div class="dse-main-wrapper">
        
        <!-- 左側：年級選擇器 (直排) -->
        <div class="grade-sidebar">
            <div class="grade-label">年級</div>
            <button class="grade-btn" data-val="s6">6</button>
            <button class="grade-btn" data-val="s5">5</button>
            <button class="grade-btn" data-val="s4">4</button>
            <button class="grade-btn" data-val="s3">3</button>
            <button class="grade-btn" data-val="s2">2</button>
            <button class="grade-btn" data-val="s1">1</button>
        </div>

        <!-- 右側：倒數卡片區 -->
        <div class="countdown-section">
            <div class="countdown-container">
                <!-- 「約」字標籤 -->
                <div id="approx-label" class="approx-label hidden">約</div>

                <!-- 千位 -->
                <div class="flip-unit hidden" id="unit-0">
                    <div class="card-part top" id="t0-next">0</div>
                    <div class="card-part bottom" id="b0-old">0</div>
                    <div class="flap" id="f0" data-old="0" data-new="0"></div>
                </div>
                
                <!-- 百位 -->
                <div class="flip-unit" id="unit-1">
                    <div class="card-part top" id="t1-next">0</div>
                    <div class="card-part bottom" id="b1-old">0</div>
                    <div class="flap" id="f1" data-old="0" data-new="0"></div>
                </div>
                <!-- 十位 -->
                <div class="flip-unit" id="unit-2">
                    <div class="card-part top" id="t2-next">0</div>
                    <div class="card-part bottom" id="b2-old">0</div>
                    <div class="flap" id="f2" data-old="0" data-new="0"></div>
                </div>
                <!-- 個位 -->
                <div class="flip-unit" id="unit-3">
                    <div class="card-part top" id="t3-next">0</div>
                    <div class="card-part bottom" id="b3-old">0</div>
                    <div class="flap" id="f3" data-old="0" data-new="0"></div>
                </div>

 <!-- ★★★ 新增這行：日字標籤 ★★★ -->
    <div class="days-label">日</div>
				
            </div>
            
            <div class="dse-footer">DAYS TO BREAKUP</div>
        </div>
    </div>
    
    <audio id="flip-sound" src="切換年級.mp3" preload="auto"></audio>
</div>



<style>
#hitokoto-container {
background: rgba(220, 220, 220, 0.96);
border-radius: 8px;
box-shadow: 0 2px 4px rgba(0,0,0,0.1);
padding: 16px;
margin: 15px 0;
text-align: center;
max-width: 800px;
position: relative;
}

@media (max-width: 600px) {
#hitokoto-container {
text-align: left;
}
}

#hitokoto {
font-size: 21px;
font-style: italic;
color: #333;
margin-bottom: 10px;
}

#hitokoto p {
margin: 5px 0;
}

#hitokoto-footer {
display: flex;
justify-content: space-between;
align-items: center;
margin-top: 10px;
}

#hitokoto-from {
font-size: 16px;
color: #666;
}

#refresh-btn {
background: none;
border: none;
cursor: pointer;
font-size: 20px;
color: #666;
transition: color 0.3s;
padding: 0;
margin: 0;
}

#refresh-btn:hover {
color: #000;
}


/* --- 新增：確認圖示按鍵樣式 --- */

.btn-icon-confirm {
/* 1. 外觀設定：圓形、綠色背景 */
width: 44px;
height: 44px;
border-radius: 50%; /* 製作成完美的圓形 */
background-color: #28a745; /* 成功、確認的綠色 */
border: none;

/* 2. 圖示置中與樣式 */
display: inline-flex;
align-items: center;
justify-content: center;
color: white; /* 圖示顏色 */
font-size: 20px; /* 圖示大小 */

/* 3. 互動效果與陰影 */
cursor: pointer;
box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
transition: all 0.2s ease-in-out;
}

.btn-icon-confirm:hover {
/* 4. 滑鼠懸停時：放大、提亮，陰影加深 */
transform: scale(1.1);
filter: brightness(110%);
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
}

.btn-icon-confirm:active {
/* 5. 點擊瞬間：再放大一點，提供回饋感 */
transform: scale(1.15);
}

/* === DSE 倒數日曆專用樣式 (響應式優化 - 底部選單版) === */
#dse-countdown-box {
    --dse-card-bg: #ffffff;
    --dse-text-color: #000000;
    --dse-line-color: #e0e0e0; 
    --dse-flip-duration: 0.6s;
    --dse-theme-color: #90A1B9;
    
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    padding: 15px 20px;
}

.dse-header {
    font-size: 1.1rem;
    letter-spacing: 0.3rem;
    margin-bottom: 1.2rem;
    color: #888;
    font-weight: 300;
    text-align: center;
}

/* === 主要容器 === */
.dse-main-wrapper {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 25px;
    width: 100%;
}

/* === 年級選單 (Desktop: 左側直排) === */
.grade-sidebar {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    padding-right: 20px;
    border-right: 1px dashed #ddd; /* 電腦版：右側分隔線 */
    flex-shrink: 0;
}

.grade-label {
    font-size: 0.75rem;
    color: #aaa;
    margin-bottom: 2px;
    font-weight: bold;
}

.grade-btn {
    background: transparent;
    border: 1px solid transparent;
    color: #ccc;
    font-family: 'Noto Serif TC', serif;
    font-size: 1rem;
    font-weight: bold;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.2s ease;
    padding: 0;
    margin: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
}

.grade-btn:hover {
    color: var(--dse-theme-color);
    background: rgba(26, 117, 149, 0.1);
}

.grade-btn.active {
    color: white;
    background-color: var(--dse-theme-color);
    box-shadow: 0 2px 5px rgba(26, 117, 149, 0.3);
    transform: scale(1.1);
}

/* === 新增：日字標籤樣式 === */
.days-label {
    font-size: 24px;
    color: var(--dse-theme-color); /* 跟隨主題顏色 */
    margin-bottom: 20px;           /* 與數字底部對齊的微調 */
    margin-left: 8px;              /* 與數字保持一點距離 */
    font-weight: bold;
    opacity: 0.8;
}
	
/* === 右側倒數區塊 === */
.countdown-section {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.countdown-container {
    display: flex;
    gap: 10px;
    perspective: 1200px;
    justify-content: center;
    align-items: flex-end;
}

.approx-label {
    font-size: 24px;
    color: var(--dse-theme-color);
    margin-bottom: 20px;
    margin-right: 5px;
    font-weight: bold;
    opacity: 0.8;
}
.approx-label.hidden { display: none; }

/* 翻頁單元樣式 */
.flip-unit {
    position: relative;
    width: 90px;
    height: 120px;
    font-size: 70px;
    font-family: 'Noto Serif TC', "Songti TC", serif;
    font-weight: bold;
    text-align: center;
    border-radius: 6px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.03);
    color: var(--dse-text-color);
    line-height: 120px;
    z-index: 1;
}

.flip-unit::after {
    content: '';
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    border-radius: 6px;
    pointer-events: none;
    z-index: 10;
    background: linear-gradient(180deg, #46ECD5 0%, 
        #3BB8DB 40%, 
        #36BBA7 100%);
    mix-blend-mode: screen;
    box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.2);
}

.card-part {
    position: absolute;
    left: 0; width: 100%; height: 50%;
    overflow: hidden;
    background: var(--dse-card-bg);
    backface-visibility: hidden;
}

.top { top: 0; border-radius: 6px 6px 0 0; line-height: 120px; border-bottom: 0.5px solid var(--dse-line-color); }
.bottom { bottom: 0; border-radius: 0 0 6px 6px; line-height: 0px; border-top: none; }

.flap {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 50%;
    background: var(--dse-card-bg);
    border-radius: 6px 6px 0 0;
    transform-origin: bottom;
    z-index: 3;
    transition: transform var(--dse-flip-duration) cubic-bezier(0.4, 0, 0.2, 1);
    transform-style: preserve-3d;
    border-bottom: 0.5px solid var(--dse-line-color);
    color: var(--dse-text-color);
}
.flap::before { content: attr(data-old); position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: var(--dse-card-bg); border-radius: 6px 6px 0 0; backface-visibility: hidden; line-height: 120px; }
.flap::after { content: attr(data-new); position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: var(--dse-card-bg); border-radius: 0 0 6px 6px; transform: rotateX(-180deg); backface-visibility: hidden; line-height: 0; display: flex; justify-content: center; border-top: none; }
.card-part, .flap::before, .flap::after { text-shadow: 0 2px 3px rgba(0, 0, 0, 0.2); }
.flipping .flap { transform: rotateX(-180deg); }

.flip-unit.hidden { display: none; }

.dse-footer {
    margin-top: 1rem;
    letter-spacing: 0.2rem;
    font-size: 0.85rem;
    color: #c0c0c0;
    font-weight: 300;
}

/* === RWD 響應式調整 (關鍵修訂：按鈕移至底部) === */
@media (max-width: 600px) {
    .dse-main-wrapper {
        flex-direction: column; /* 垂直排列 */
        gap: 15px;
    }
    
    /* 1. 倒數區塊 (包含卡片和 DAYS TO BREAKUP) */
    .countdown-section {
        order: 1; /* 視覺上排第一 */
        width: 100%;
        margin-bottom: 5px;
    }

    /* 2. 年級選單 */
    .grade-sidebar {
        order: 2; /* 視覺上排第二 (底部) */
        flex-direction: row; /* 橫向排列 */
        width: 100%;
        justify-content: center;
        padding-right: 0;
        
        border-right: none;
        border-top: 1px dashed #e0e0e0; /* 分隔線改在上方 */
        
        padding-top: 15px;
        flex-wrap: wrap;
    }
    
    .grade-label {
        margin-right: 10px;
        margin-bottom: 0;
        align-self: center; /* 垂直置中 */
    }

    .grade-btn {
        width: 24px;  /* 手機版按鈕縮小 */
        height: 24px;
        font-size: 0.8rem;
    }

    .countdown-container {
        transform: scale(0.8); 
        margin: -10px 0;
    }
    
    .flip-unit {
        width: 70px;
        height: 100px;
        font-size: 55px;
        line-height: 100px;
    }
    .top { line-height: 100px; }
    .flap::before { line-height: 100px; }
}
</style>

<script src="https://cdn.jsdelivr.net/npm/opencc-js@1.0.5/dist/umd/full.js"></script>


<script>


	// === 動畫觸發輔助函數 ===
function playEntryAnimation(elementId) {
    const el = document.getElementById(elementId);
    if (el) {
        // 1. 移除動畫 class (如果有的話)
        el.classList.remove('fade-in-up');
        
        // 2. 強制瀏覽器重繪 (Reflow) - 這是關鍵，否則瀏覽器會忽略重新添加 class 的動作
        void el.offsetWidth;
        
        // 3. 重新加入動畫 class
        el.classList.add('fade-in-up');
    }
}

document.addEventListener('DOMContentLoaded', function() {
const converter = OpenCC.Converter({ from: 'cn', to: 'tw' });
const hitokotoElement = document.getElementById('hitokoto');
const hitokotoFromElement = document.getElementById('hitokoto-from');
const refreshBtn = document.getElementById('refresh-btn');


function initDSECalendar() {
    // === 1. 設定日期 ===
    const config = {
        s6: '2026-04-09', 
        s5: '2027-04-02',
        offsets: { s4: 1, s3: 2, s2: 3, s1: 4 }
    };

    // === 2. 自動建立/獲取煙花畫布 ===
    let fireworksCanvas = document.getElementById('fireworksCanvas');
    if (!fireworksCanvas) {
        fireworksCanvas = document.createElement('canvas');
        fireworksCanvas.id = 'fireworksCanvas';
        fireworksCanvas.style.position = 'fixed';
        fireworksCanvas.style.top = '0';
        fireworksCanvas.style.left = '0';
        fireworksCanvas.style.width = '100%';
        fireworksCanvas.style.height = '100%';
        fireworksCanvas.style.pointerEvents = 'none'; 
        fireworksCanvas.style.zIndex = '2147483647';
        fireworksCanvas.style.display = 'none';
        document.body.appendChild(fireworksCanvas);
    }

    const gradeButtons = document.querySelectorAll('.grade-btn');
    const unit0 = document.getElementById('unit-0');
    const approxLabel = document.getElementById('approx-label');
    
    let currentGrade = localStorage.getItem('dse_grade') || 's6';

    // === 3. 煙花特效邏輯 (保持不變) ===
    let fireworksInterval;
    let autoStopTimer; 
    let cleanupTimer;  
    let fireworksActive = false;
    const ctx = fireworksCanvas.getContext('2d');
    let particles = [];

    function resizeCanvas() {
        fireworksCanvas.width = window.innerWidth;
        fireworksCanvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function createParticle(x, y) {
        const particleCount = 35; 
        for (let i = 0; i < particleCount; i++) {
            particles.push({
                x: x,
                y: y,
                colors: ['#1A7595', '#D87C7C', '#E6D0A6', '#8FB2C9', '#A8D8B9'],
                color: '',
                radius: Math.random() * 2 + 0.8, 
                velocity: {
                    x: (Math.random() - 0.5) * 6,
                    y: (Math.random() - 0.5) * 6
                },
                alpha: 0.9,
                decay: Math.random() * 0.01 + 0.005
            });
            particles[particles.length - 1].color = particles[particles.length - 1].colors[Math.floor(Math.random() * 5)];
        }
    }

    function animateFireworks() {
        if (particles.length === 0 && !fireworksActive) return;
        requestAnimationFrame(animateFireworks);
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);
        ctx.globalCompositeOperation = 'lighter';
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.alpha;
            ctx.fill();
            p.x += p.velocity.x;
            p.y += p.velocity.y;
            p.velocity.y += 0.03;
            p.velocity.x *= 0.98;
            p.velocity.y *= 0.98;
            p.alpha -= p.decay;
            if (p.alpha <= 0) particles.splice(i, 1);
        }
    }

    function startFireworks() {
        if (fireworksActive) return;
        fireworksActive = true;
        fireworksCanvas.style.display = 'block';
        animateFireworks();
        createParticle(window.innerWidth / 2, window.innerHeight / 3);
        fireworksInterval = setInterval(() => {
            const x = Math.random() * (fireworksCanvas.width * 0.6) + (fireworksCanvas.width * 0.2);
            const y = Math.random() * (fireworksCanvas.height / 2); 
            createParticle(x, y);
        }, 700);
        clearTimeout(autoStopTimer);
        clearTimeout(cleanupTimer);
        autoStopTimer = setTimeout(() => stopLaunching(), 3000);
    }

    function stopLaunching() {
        clearInterval(fireworksInterval);
        fireworksActive = false;
        cleanupTimer = setTimeout(() => {
            fireworksCanvas.style.display = 'none';
            ctx.clearRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);
            particles = [];
        }, 3000);
    }

    function forceStopFireworks() {
        clearInterval(fireworksInterval);
        clearTimeout(autoStopTimer);
        clearTimeout(cleanupTimer);
        fireworksActive = false;
        fireworksCanvas.style.display = 'none';
        ctx.clearRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);
        particles = [];
    }

    // === 4. 按鈕監聽 (修改處：傳入較短延遲) ===
    gradeButtons.forEach(btn => {
        if (btn.dataset.val === currentGrade) btn.classList.add('active');

        btn.addEventListener('click', function() {
            gradeButtons.forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            
            currentGrade = this.dataset.val;
            localStorage.setItem('dse_grade', currentGrade);
            
            // ★★★ 這裡改成 250ms (0.25秒)，切換時更快速 ★★★
            updateCountdown(true, 250); 
        });
    });

    // === 5. 倒數更新 (修改處：接收 delay 參數) ===
    function updateCountdown(animate = true, delay = 800) {
        // 使用傳入的 delay 參數，預設為 800ms
        const flipDelay = delay; 

        let targetDate;
        const isApprox = ['s1', 's2', 's3', 's4'].includes(currentGrade);
        if (approxLabel) approxLabel.classList.toggle('hidden', !isApprox);
        
        if (currentGrade === 's6' || currentGrade === 's5') {
            targetDate = new Date(config[currentGrade]);
        } else {
            const baseDate = new Date(config.s5);
            const yearsToAdd = config.offsets[currentGrade];
            targetDate = new Date(baseDate.getTime() + (yearsToAdd * 365 * 24 * 60 * 60 * 1000));
        }
        
        const now = new Date();
        targetDate.setHours(0, 0, 0, 0);
        now.setHours(0, 0, 0, 0);
        const diff = targetDate.getTime() - now.getTime();
        let days = Math.ceil(diff / (1000 * 60 * 60 * 24));
        
        const daysLabel = document.querySelector('.countdown-container .days-label, .days-label');
        
        // 處理負數天數
        if (days < 0) {
            forceStopFireworks();
            if (unit0) unit0.classList.remove('hidden');
            const fullStr = "已分手";
            for (let i = 0; i < 3; i++) {
                const unit = document.getElementById(`unit-${i}`);
                if (unit) {
                    unit.classList.remove('flipping');
                    document.getElementById(`t${i}-next`).innerText = fullStr[i] || '';
                    document.getElementById(`b${i}-old`).innerText = fullStr[i] || '';
                    const flap = document.getElementById(`f${i}`);
                    flap.setAttribute('data-old', fullStr[i] || '');
                    flap.setAttribute('data-new', fullStr[i] || '');
                }
            }
            const unit3 = document.getElementById('unit-3');
            if (unit3) unit3.classList.add('hidden');
            if (approxLabel) approxLabel.classList.add('hidden');
            if (daysLabel) daysLabel.style.display = 'none';
            const footer = document.querySelector('.dse-footer');
            if (footer) footer.textContent = "WE ARE FREE";
            return;
        }

        // 正常顯示
        if (daysLabel) daysLabel.style.display = '';
        if (unit0) unit0.classList.toggle('hidden', days < 1000);
        
        const fullStr = days.toString().padStart(4, '0');      // 新數字
        const prevDays = days + 1;                             // 舊數字
        const oldFullStr = prevDays.toString().padStart(4, '0'); 
        
        // 煙花邏輯
        if (days <= 0) {
            days = 0;
            if (!fireworksActive) startFireworks();
        } else {
            forceStopFireworks();
        }
        
        // ★★★ 第一階段：無動畫、瞬間重置為「舊數字」 (防閃爍邏輯) ★★★
        for (let i = 0; i <= 3; i++) {
            const unit = document.getElementById(`unit-${i}`);
            if (unit) {
                const oldVal = oldFullStr[i];
                const flap = document.getElementById(`f${i}`);

                // 關閉過渡，防閃爍
                flap.style.transition = 'none';
                unit.classList.remove('flipping');
                
                // 設為舊數字
                document.getElementById(`t${i}-next`).innerText = oldVal;
                document.getElementById(`b${i}-old`).innerText = oldVal;
                flap.setAttribute('data-old', oldVal);
                flap.setAttribute('data-new', oldVal);

                // 強制重繪
                void unit.offsetWidth; 

                // 恢復過渡
                flap.style.transition = ''; 
            }
        }

        // ★★★ 第二階段：根據 delay 時間翻頁 ★★★
        if (animate) {
            setTimeout(() => {
                const sound = document.getElementById('flip-sound');
                if (sound) {
                    sound.currentTime = 0;
                    sound.play().catch(() => {});
                }

                for (let i = 0; i <= 3; i++) {
                    const unit = document.getElementById(`unit-${i}`);
                    if (unit) {
                        const newVal = fullStr[i];
                        const oldVal = oldFullStr[i];
                        
                        if (oldVal !== newVal) {
                            const flap = document.getElementById(`f${i}`);
                            document.getElementById(`t${i}-next`).innerText = newVal;
                            flap.setAttribute('data-new', newVal);
                            unit.classList.add('flipping');
                        }
                    }
                }
            }, flipDelay); // 使用動態傳入的 delay
        } else {
             for (let i = 0; i <= 3; i++) {
                const unit = document.getElementById(`unit-${i}`);
                if (unit) {
                    const newVal = fullStr[i];
                    document.getElementById(`t${i}-next`).innerText = newVal;
                    document.getElementById(`b${i}-old`).innerText = newVal;
                    const flap = document.getElementById(`f${i}`);
                    flap.setAttribute('data-old', newVal);
                    flap.setAttribute('data-new', newVal);
                }
            }
        }
    }
    
    // 首次執行 (保持較長延遲，這裡設為 800ms)
    setTimeout(() => {
        updateCountdown(true, 800);
    }, 100); 
}

// 確保腳本執行
if (document.readyState === 'complete' || document.readyState === 'interactive') {
    initDSECalendar();
} else {
    document.addEventListener('DOMContentLoaded', initDSECalendar);
}

	
function fetchHitokoto() {
fetch('https://v1.hitokoto.cn/?c=d&c=i&c=k&encode=json')
.then(response => response.json())
.then(data => {
if (data.from.includes('魔道祖師')) {
fetchHitokoto(); // 如果來源是「魔道祖師」，重新獲取名言
} else {
// 使用 textContent 可以自動處理特殊字元，是顯示純文字的最佳選擇
hitokotoElement.textContent = converter(data.hitokoto);
hitokotoFromElement.textContent = `—— ${converter(data.from_who || '佚名')} 《${converter(data.from)}》`;
}
})
.catch(error => {
console.error('獲取名言失敗:', error);
hitokotoElement.innerHTML = '<p>獲取名言失敗，請稍後再試。</p>';
hitokotoFromElement.innerHTML = '';
});
}

fetchHitokoto();
refreshBtn.addEventListener('click', fetchHitokoto);
});
</script>

<!-- 內置的 5** 級數範文 (隱藏) -->
<div id="five-star-examples" style="display: none;">
<div id="example-yanhuo">
<h3>《煙火》</h3>
<p>回鄉的我凝望著門前的「河流」，沉默不語。那場璀璨的煙火又在我杳遠的回憶隱然綻放。
我記得，故鄉梁莊的那夜是樸素的，是低調的，就像默默俯身收割莊稼的農民；我記得，那時祖屋的遠處種著桑樹，樹上迴響著清亮的蟬聲，而近處蜿蜒著一道河，河畔的蘆葦總傳來蛙鳴；那是元旦，鄰居李叔親切地送上祝福，又從吳鎮的煙火廠帶來了龍吐珠，與村民慶賀新春。煙花在夜幕訇然盛放之時，七歲的我正環抱著爺爺的頸項。所有的澄黃、亮綠和緋紅倏爾煥爛在我的眼眸。火光乍現，煙花便瞬即璀璨而華麗地枯萎了，只賸下硝煙和火藥的氣息。
我哭了，爺爺以為我被煙火嚇壞了，瞬即摩娑著我的背。
其實，我不過是驚詫於一切美好的幻滅。
後來，我才瞭解人生有許多事情都注定是一場美好的幻滅，如同煙火。
爺爺是我的留守歲月最璀璨的印記。我從村校放學回家時，爺爺總會捧著熱氣騰騰的、白花花的饅頭迎接著我。阿念，吃吧，快點吃吧。爺爺沙啞的聲線仍猶在耳。童年的我總喜歡伏在爺爺的背上諦聽著時間，一秒，兩秒，是多麼沉穩的幸福呢。背並不厚實，但卻溫暖和煦。時間仿佛會一直定格在這一幀。然而在我九歲那年，爺爺死了，就淹死在門前的河。建築公司在河底挖沙蓋樓，河道看來平靜，卻暗藏漩渦。爺爺游泳時被暗湧拉扯到河底，就活活淹死了。短短數年的歲月，在人生裡不過是一場倉卒燃燒的煙火，爺爺在我的回憶裡綻放過澄黃、亮綠和緋紅，卻連一縷硝煙都沒有遺下，只遺下了一件濡濕的、皺巴巴的汗衣，儼如因衰老而再無能為力綻放的煙花。
還有門前的河流，在爺爺死後十年，已經沉默得如患上了失語症，河水乾涸，河床裸露，像被歲月無情強暴了一樣。夏蟬和青蛙，都憂鬱得噤聲不語，遷徙到回憶之外。李叔前年在電鍍廠中毒過身了。童年時一切一切的美好，都如海市蜃樓般驟然無存。歲月燃點了一場煙花，最後只遺下沉重的回憶，以及沉重地回憶的我。煙火再璀璨，也是匆促的。
本來我是這樣認為的。
直至又再離鄉之際，我才赫然窺探到煙火的秘密。
村口的大樹懸掛著纍纍碩大的林柿，那一個個橘橙的果實每年都爛在樹上，沒有村民採摘，連雀鳥都不屑一顧。在我準備踏出村口時，一顆飽滿的柿子掉落到我面前。我啃咬了一口，還是一如回憶的苦澀、難吃，我急不及待將咀嚼中的柿肉吐出來，且棄之如敝屣。我倏爾發現，縱然梁莊物換星移已不知幾度秋，但仍有許多回憶的遺跡，比如是眼前這棵金玉其外的柿樹。它的果實仍然是澀的，我想，是因為它仍然鮮活、茂盛、強壯，是因為它仍未枯謝、凋零、衰敝。假如它成為了歲月匆促幻滅的過客，也許那味道會是甘甜的苦澀，也許我會懷念那苦澀。
我再次凝望著那乾涸的河道。曩昔我嫌棄過蟬囀蛙鳴聒耳，擾人清夢；我埋怨過蘆葦纖長，阻礙了我的視野；我拒絕過爺爺的饅頭，因為寡淡無味，因為我想吃肉香滿溢的五香肘子啊，不想吃寡淡的、慘白的饅頭。我討厭過李叔蠟黃的臉色，討厭過他衣衫襤褸，討厭過他渾身汗臭，我討厭過李叔的一切。諷刺的是，隨著物和事匆促的面目全非，我竟爾留戀上一切我討厭過的。
於是我開始明白煙花的璀璨，在於它的匆促和幻滅。
時間會過濾掉所有人和事的雜質，隨著泯滅變易，我們開始犯賤地珍惜，然而珍惜的唯一意義僅在於遺憾，但正因為遺憾，才體現到事物的璀璨。倘若爺爺和李叔仍然在世，倘若門前的河仍然流淌不斷，倘若蟬聲蛙鳴依舊，倘若絢爛永恆，那麼一切便將腐爛而不再璀璨，他們和它們都將蛻變成被棄如敝屣的柿子。我曾以為煙火再璀璨，也是匆促的。但原來我錯了。原來煙火璀璨，正因為匆促。一旦煙火永恆，它將失去生命，教人徒然目眩。
離鄉的這夜，恰巧是元旦。是夜天陰，無雨。梁莊寂寥如一場夢，再沒有盛放的煙火。因為，煙花從此只在我的回憶裡燦爛地綻開、匆促地結果。</p>
</div>
<div id="example-gen">
<h3>《根》</h3>
<p>火焰燃起了一瓣又一瓣的灰燼，它們即生即滅，像飄萍，是一種無根的存在。餘燼隨風零落，又再揚起，終落入了深邃的虛無裡。人們說，紙錢燒成灰燼，便會飛落到地獄，交到亡靈的手裡。
父親，你收到了嗎？
你，尋到你的根了嗎？
我向着一枚貝殼問道。
我們的故鄉是一個江南小鎮，名曰周莊。明代江南首富沈萬三昔曾坐落此處發施號令，指點江山，各種契約、決斷和銀票都有這裡大進大出過，如今卻只賸下沈廳的空寂。鎮上到處都是貫穿南北的河道，就像永不乾涸的阡陌。周莊的河網養活了一代又一代的周莊人，從這裡出發，可借河道而東西南北，近至蘇杭，遠通東南亞。我的父親，只是貿易的一塊細小的零件——卑微的船夫，但他卻盤根錯節，支撐著整個家庭。
「爸，你甚麼時候回家？」
小時候，每當我牽扯著他的衣襬問他這道問題時，他總會帶著疲憊的莞爾，摩娑著我的腦殼說道：
「很快了，很快了。」
於是，一去便是三兩個月了。他在無垠的河川和滄渤航行了一輩子，曾為多少家庭送上過物資，又曾目睹過多少匆忙歸家的白鷗呢？然而，他自己卻成為了一個無根的人。他飄洋過海，仿佛只為回來時睡一覺昏沉的。無根的浪花，便是父親的象徵；一身的鹹腥，便是他半生的註腳。
他細碎又重複的夢囈被年幼的我記住了。
在漫長的夢裡，他是參天巨樹，偉岸的、繁茂的，扎根在風吹草低見牛羊的草原。風拂過他的臉龐，他貪婪地流了一行涎液。
一切都只為了養活我們四兄弟姐妹，成為這個家庭的根。母親呢，從不嚮往自由而無根的蒲公英，在我們孩提時代，她已經從周莊的河網掙脫出去了。只賸下父親，像根一樣默默無言地支撐著這個家庭的經濟，用河水澆灌，為它提供養份；用船櫓翻土，使它茁壯成長。我們幾兄弟姐妹，就恍如纍纍碩大的果實。果實之所以飽滿豐美，全因深扎泥土的根。
短暫洗去風塵後，又是一個擾人的昒暝。陽光揉開他的眼瞼，那沉重的眼瞼，一場無垠的旅程又將展開。
他成為了我們的根，自己呢，卻一直飄泊於風波不定的大海。我一直想，他的根究竟在哪裡呢？
也許，從來都不在印有郵遞編號的地方，而在我們。但早在十年前，都被我們砍斷了。終於，父親失去了他惟一的根。
長大後，我們不再牽扯父親的衣襬。父親在我們的印象，是一種昏睡的存在，我們之間存在著一種歲月孕育出來的隔閡——不冷淡又不溫韾的沉默。就像周莊的河水，既不溷濁，又不清澈。只有生活的氣息。隨著長大，我們一個又一個離開了日復如是的故鄉。他用一身風塵支撐的家，早在歲月的長河中淡褪了顏色。
被淹沒了。
大哥從來沒有帶過孩子回鄉。
二姐結婚時沒有邀請過父親。
妹妹幾年來音信杳無，聽說到加拿大去了。
只有我偶爾回鄉。父親總是無所事事，落寞地坐在斜曛映照的碼頭上，抽著雙喜牌香煙，眺望著那平靜如日子的河川。夕陽落在他身上，拓出了一個單薄的黑影。我這才知道，原來影子是會老，是會萎縮的。
他的身體開始坍塌，大不如曩日的壯碩，因為失去了根，失去了人生角色的緣故。他已經沒有了壯碩的理由。在病榻上，只有噏動的嘴唇透露著生命的跡象，在明滅不定的沉吟裡，我諦聽到我們的暱稱，又諦聽到那個關於樹的夢的碎片。不一樣的是，樹好像連根拔起了，似乎被一場颱風吹倒了。
我不會遺忘父親的好。每次他回周莊，他總會為我們帶來一枚貝殼，我愛把貝殼湊在耳畔聽那大海的聲音，有溫煦的，有舒爽的，有寂寞的，有思念的。他出航的畫面，總如真似幻地映照在我的腦海裡。但我無法將愛裸裎地宣之於口。父親，你飄泊半生，四海為家，卻終於失去了支撐你努力活著的角色。為了成為我們的根，你失去了自己的根。也許，也許你無法扎根在這個世界任何一隅，但我卻早為你預留了一捧最肥沃的泥土——在我心裡，讓你終於可以安息，終於可以落葉歸根，終於不用再飄泊不定。
海風永不止息地吹拂著一個夢，雲亦舒捲著無根的故事。</p>
</div>
<div id="example-dengdai">
<h3>《等待》</h3>
<p>月亮高懸在闃寂的夜空，儼如吊著一顆無眠的眼睛。它仿佛記得，自己已用幾千年的時間等待一個人，但卻已遺忘了等待的對象。於是，它映照著下方喧囂的城市，映照著每一個在城市裡等待著的人。
比如說，一個在晚窗前許願的孩子，他在等待著綠豆的幼苗在濕潤的棉花裡茁壯成長，並開花結果。
又比如說，一個無聲吶喊著的女人。他的丈夫，那醉醺醺的男人，又在發瘋。一頓拳打腳踢之後，她身上青一片、紫一片的。原來人的皮膚可以呈現如此斑駁的顏色。然而，她已不驚詫，因為暴力早教她看見青紫色的自己。不過，她在等待，她依猶在等待，依猶在等待那個婚禮上替自己戴上婚戒的他。
想著想着，她無端落下了一滴淚。原來，許多人也在歲月的長河裡無止境地等待著。等待的人並不孤單。
一幀泛黃且充滿顆粒感的照片裡，一個小女孩正佻皮地捏著母親的臉頰，母親佯作生氣，她幸福地「生氣」著。
可愛吧？這個左邊的小女孩，便是我的女兒。 
嗯，可愛。
同樣的對話，同樣的故事，在這八年的時光裡重重複複地敘述著。仿佛是一本八百頁的長篇小說，只有這樣的一段對話。但是，她仍樂此不疲地閱讀著小說的每一頁。因為，因為她已遺忘了上一頁的所有內容。
那個小女孩，便是我，而那位母親患了病，一場將我遺忘的病。
我一直等待著，等待著她有天重新憶記起我；等待著她像小時候一樣，摩娑著我的腦殼，溫柔地哄我入睡；等待著她生活裡每句使人心煩的嘮叨。我等待了八年，為此，我與她一起翻閱舊相冊，一起重遊所有老地方，然而奇蹟一直保持沉默，不作任何回應。在歲月的長河裡，只賺下佇立著、等候著的我。
女兒啊……
她又再躺在沙發上說著朦朦朧朧的囈語。
今晚煮了湯，放在客廳的……
「桌上」兩個音節裹未孵出來，便已胎死在掛掉的話裡了。那時的我，在過著燈紅酒綠的生活。月，仿佛才是昒暝的日出。一杯又一杯的長島冰茶灌進肚裡，根本容不下一碗溫熱的湯。
恰巧，也是八年的時間，媽媽也等待了八年的時間。她每一個晚上都在夢囈裡盼望著我歸家。然而等待一次又一次落空，只有蒼然寂寞的月色悄悄地透過窗戶，替她蓋上一張沒有溫度的被子。
八年後，我才真正明白等待的滋味，才體會到等待的煎熬。你是如何孤單地度過每一個昏暗的夜，如何忍受著一句句使你痛徹心扉的說話？一切的等待為了甚麼？
我的女兒回來了嗎？
你瞇著惺忪的睡眼問我。
還未，她還未回來，再等一下吧。
其實，她永遠都不會回來了，因為她已永恆地滯留在時光的隧道裡。在那個地方，夢即現實，回憶即現實，人永遠不會長大，更不會蒼老。因此之故，她永遠不會回來了。
至於我等待的人，等待的一聲呼喊，也不會回來了。她已羈困在一段停滯的時光裡，沒有逃逸，亦沒有人想逃逸。因為，她已等待得支離破碎，疲憊不堪了。
我們的等待，注定了落空。
但八年的等待裡，我終究參悟了落空的意義。正如那棵似乎會勃發生長的綠豆苗，也許一星期後便會似一場曉夢般枯萎，但孩子學會了生命的價值，學會了甚麼是失落，學會了憧憬在字典外的含義；又正如那個滿佈瘡痍的女人，在漫無邊際的等待裡，或許終於明白了有些等待並不值得，明白了有些等待並不值得，明白了有些等待只是一廂情願，於是鼓起離婚的勇氣。在等待裡，所有人都會找到新的意義。也許，等待只是一場燦爛奪目的煙花，只承諾開花，卻從不承諾結果。但在等待裡，我們都重新認識了自己和他人，甚或是人生。一如八年的等待，使我終於能體會媽媽的體會，孤寂、失望、無奈、感慨、悱惻，我都一一感受到了。她沒有遺下一句說話，便將我遺留在時光的彼岸，然而她內心最隱密的說話，我已諦聽到了。因為，我也成為了一個等待的人。等待的過程裡，我還學會了堅強、勇氣和耐心。從前，我何曾耐心地回應過她一句呢？
等著等著，她便像個孩子似的，哭嚷著要女兒回來，我溫柔地摩娑著她的髮絲、她的臉龐、她的下巴、她的背、她的手，又在她耳畔低語：「別怕，我與你一起等女兒回來，好不好？」她冷靜下來，默默地頷著首。
煙花，終於結了果，一如等待，終於在落空中結了果。</p>
</div>

<div id="example-yanhuo-l3">
<h3>《煙火》(3等範文)</h3>
<p>夏天的夜晚，總是充滿了期待。小明是小六的學生，他最喜歡的事情就是和家人一起去看煙火。每年的鎮上夏日祭典，廣場上都會放一場盛大的煙火表演。那絢麗的光芒、絢爛的色彩，總讓小明看得目不轉睛，心裡充滿了驚奇與快樂。
這一天，小明早早就吃完了晚飯，興奮地拉著爸爸媽媽的手，往廣場走去。路上，他看見許多鄰居和同學，大家都帶著笑容，提著小板凳或鋪著野餐墊，準備找個好位置欣賞煙火。小明的妹妹小芳也跟著，蹦蹦跳跳地哼著歌，手裡還拿著一根螢光棒，閃閃發光。
到了廣場，已經人山人海。小明一家找了一塊空地，鋪上毯子，坐下來等待。天空還有些微亮，夕陽的餘輝灑在遠處的山頭上，像一幅美麗的畫。廣場上有人在賣棉花糖和烤魷魚，香味飄過來，讓小明忍不住嚥了口口水。爸爸笑著說：「等看完煙火，爸爸給你買一串烤魷魚好不好？」小明高興地點點頭。
終於，天色完全暗了下來。突然，一聲「砰」的巨響劃破夜空，第一顆煙火像一朵巨大的金色菊花，在天空中綻放開來。人群中傳來一陣驚呼，小明瞪大了眼睛，嘴巴張成了「O」形。接著，紅的、藍的、綠的、紫的煙火一個接一個升空，有的像流星劃過，有的像瀑布傾瀉，還有的像一顆顆閃亮的星星，點亮了整個夜空。
小明最喜歡的是那種會「咻咻」轉圈的煙火。它們先是像火箭一樣衝上天，然後在空中轉出一個個彩色的光圈，好像在跳舞一樣。小芳拍著手喊：「好漂亮！像仙女在撒花！」小明也忍不住跟著喊：「再來一個！再來一個！」爸爸媽媽在一旁笑著，看著孩子們開心的模樣，也覺得特別幸福。
煙火表演持續了半個多小時，每一顆煙火都讓小明覺得驚喜萬分。他心想，這些煙火是怎麼做出來的呢？為什麼它們可以在天空中變出這麼多不同的形狀和顏色？表演結束後，小明忍不住問爸爸：「煙火是怎麼來的？是誰發明的？」
爸爸摸摸小明的頭，笑著說：「煙火的歷史很長喔！聽說是古代的中國人發明的。他們發現一些化學物質混在一起會爆炸，後來就用來做煙火，讓節日更熱鬧。每一顆煙火裡都有不同的化學藥劑，這些藥劑決定了它們的顏色和形狀。紅色的煙火可能有鍶，藍色的有銅，綠色的有鋇，這些都是科學的魔法！」
小明聽得眼睛亮亮的，覺得好神奇。他想像著一群科學家在實驗室裡調配藥劑，試著做出最漂亮的煙火。他心裡暗暗決定，回家後要上網查更多關於煙火的知識，或許將來他也能成為一個會做煙火的人！
煙火結束後，廣場上的人群慢慢散去。小明一家走在回家的路上，夜風輕輕吹過，帶著一絲涼意。小芳已經累得在爸爸的懷裡睡著了，小明卻還在回味剛剛的煙火。他抬起頭，看著滿天的星星，心裡充滿了夢想。他想，煙火就像人生一樣，雖然短暫，卻可以綻放出最美的光芒。只要努力，他相信自己也能像煙火一樣，在未來某一天閃耀屬於自己的光彩。
回到家，小明拿出日記本，寫下了今天的感受：「今晚的煙火好美！它們在天空中飛舞，像在告訴我，只要有夢想，就能飛得很高很高。我要好好學習，將來也要像煙火一樣，點亮別人的眼睛！」</p>
</div>

<!-- 新增議論文示例 -->
<div id="example-song-li">
<h3>《送禮之我見》</h3>
<p>每個人的一生都與禮物結下不解之緣。親友的滿月賀禮，承載著對新生命的祝福；長輩的壓歲紅包，包裹著對後輩的期許。然而，當物質洪流席捲現代社會，送禮這項古老習俗，卻在功利浪潮的沖刷下漸失本真，淪為人情往來的籌碼與攀比虛榮的角力場。人們穿梭於琳琅禮品間，精打細算著禮物的「價值」能否匹配關係的「份量」，卻鮮少思量這份心意是否仍如初生赤子般純粹無雜質。當饋贈的初衷被異化為計算，我們是否該停下腳步，重新審視禮物的真諦？

禮物的靈魂，從來不在其金玉其外的華美包裝，而在其蘊含的情意之真摯與純粹。古訓有云：「千里送鵝毛，禮輕情意重。」此語道破了饋贈的核心價值——心意遠勝物質。唐代詩人白居易在《秦中吟》中，對權貴間「一叢深色花，十戶中人賦」的奢靡饋贈極盡諷刺，揭露其虛榮浮誇的本質。反之，近代文豪魯迅，常以親筆題簽的書籍贈予青年學子。那薄薄一冊書，承載的是一位啟蒙者對後輩深沉的期許與精神火種的傳遞。魯迅深知，真正有力量的禮物，是能點亮心靈、啟迪思想的火炬，而非點綴門面的俗物。由此觀之，禮物之重，在於心意之深。若僅以價格衡量價值，則再貴重的禮品，亦不過是冰冷交易的憑證，失卻了情感交流的溫度。

可惜，當代社會中，禮物的異化現象俯拾皆是。饋贈時常淪為維繫社會關係網絡的工具，甚至背負著隱形的「債務枷鎖」。法國人類學家莫斯在《禮物》一書中精闢指出，傳統社會的禮物交換蘊含著「給予、接受、回報」的義務性循環，這股無形的社會壓力，常使受贈者感到負擔。反觀今日，此現象愈演愈烈。職場上，年節贈禮常被視為人情投資；婚宴嫁娶，賓客更暗自計較紅包厚薄是否「等值」。更甚者，如《紅樓夢》中賈府壽宴，王熙鳳對各房禮單的斤斤計較，將人情世故的算計演繹得淋漓盡致。當送禮者與受禮者皆困於「人情債」的算計，禮物便不再是心意的載體，而是淪為衡量利害得失的冰冷砝碼。這份計較，不僅磨損人際真誠，更使饋贈的初衷蒙塵。

或許有人辯稱，身處人情社會，送禮難以擺脫功利色彩，所謂「真誠」不過是理想化的奢談。此言差矣。禮物的真偽，關鍵在於饋贈者的用心與純粹。魏晉名士嵇康，面對好友山濤欲舉薦其為官的「厚禮」，選擇以《與山巨源絕交書》明志。這封看似決絕的信，恰恰是嵇康回贈給山濤最貴重的禮物——一份對本真與氣節的堅守。他寧願承受斷交的「失」，也不願以人格自由作為交換官位的「得」。嵇康的行為啟示我們，真正的禮物，源自內在的誠懇與尊重，而非外在的價值或目的。若內心澄澈，即便是婉拒，亦可成為一份震撼靈魂的厚禮；反之，若動機不純，再華貴的饋贈，亦不過是包裹著糖衣的虛偽交易。禮物的重量，終究繫於心意之秤，而非物質之衡。

誠然，在現實的夾縫中尋求全然超脫的饋贈境界並非易事。我們或許無法徹底摒棄人情往來的社會習性，但至少能在每一次饋贈前，叩問己心：這份禮物，是否源自純粹的關懷與祝福？而非包裹著交換、償還或炫耀的雜質。英國文豪王爾德曾諷刺道：「憤世嫉俗者知道所有東西的價格，卻不知道任何東西的價值。」這警語猶如明鏡，映照出我們在物質洪流中對價值的迷失。當我們過分執著於禮物的價格標籤，便極易遺忘其無價的情感內核。歸根結柢，送禮的最高藝術，在於使物質載體成為傳遞真情的使者，讓每一次贈予，都成為心靈間溫暖的交匯點。贈人玫瑰，手有餘香——這份香氣，源於真誠，存於心意，與物質的貴賤無涉。你我能否在下次饋贈時，讓這份芬芳，蓋過世俗的塵囂？</p>
</div>

<div id="example-lun-dushu">
<h3>《論讀書》</h3>
<p>讀書是一件很有趣又很重要的事情。小朋友們，你們喜歡讀書嗎？也許有的小朋友覺得讀書很無聊，但其實讀書可以讓我們變聰明、開心，還能認識很多新東西。今天我要來跟你們說說，為什麼讀書是一件很棒的事情。我會用簡單的理由告訴你們，讀書對我們有多好！

讀書就像打開一扇神奇的大門，裡面有很多新東西等著我們去發現。比如說，你有沒有想過恐龍是怎麼生活的？或者太空裡有什麼祕密？當你讀一本關於恐龍或太空的書，你就會知道好多有趣的事情。比如，我讀過一本書，說霸王龍的牙齒像香蕉一樣大！這是不是很酷？讀書可以讓我們學到課堂上沒教的東西，讓我們的腦袋裝滿知識。

不只科學，讀書還能讓我們認識不同的地方和文化。比如，你可以讀一本關於非洲的故事，知道那裡有大大的草原和跑得很快的獅子。這些知識讓我們對世界更好奇，也讓我們變得更聰明。所以，讀書就像一個寶藏箱，裡面裝滿了讓我們變厲害的知識！

你有沒有想過自己變成一個勇敢的騎士，或是飛到天上的超人？讀書可以幫我們想像這些很棒的事情！當我們讀故事書時，我們會跟著書裡的角色一起冒險。比如，我讀過一本書，講一個小男孩在森林裡找到一個魔法棒，然後他用魔法棒打敗了壞巫師。讀的時候，我好像也跟著他一起去冒險，感覺好刺激！

想像力很重要，因為它讓我們會想出新點子。當你畫畫、寫故事，或是玩遊戲時，好的想像力可以讓你做出很棒的事情。比如，你可能會因為讀了一本關於海盜的書，就自己畫了一艘很酷的海盜船！所以，讀書不只讓我們開心，還能讓我們的腦袋變得更有創意。

讀書不只能讓我們變聰明，還能讓我們的心變得更善良。有的書會教我們怎麼跟朋友相處，怎麼幫助別人。比如，我讀過一本書，講一個小女孩幫助了一隻受傷的小鳥，後來他們變成了好朋友。這個故事讓我覺得，幫助別人是一件很快樂的事情。

當我們讀這些故事時，我們會學到什麼是對的，什麼是錯的。這些書就像老師一樣，教我們怎麼做一個好人。比如，當你看到書裡的角色分享玩具，你也會想跟朋友分享東西。這樣，我們的心就會變得更溫暖，朋友也會更多！

有些小朋友可能會說：「讀書好無聊，我想玩遊戲或看電視！」我知道，玩遊戲和看電視也很開心，但它們跟讀書不一樣。遊戲和電視很快就會看完，但書裡的故事可以讓你慢慢想、慢慢感受。而且，讀書可以讓你自己決定故事怎麼走，比如你可以用想像力幫故事裡的角色想新的結局，這是遊戲和電視做不到的！

還有小朋友可能說：「書裡的字好多，看不懂！」沒關係，我們可以從簡單的書開始，比如圖畫書，裡面有好看的圖片，字也不多。慢慢地，你會發現讀書越來越簡單，也越來越有趣。所以，別害怕，試著讀一本你喜歡的書，你會發現它有多好玩！

總之，讀書是一件很棒的事情！它讓我們學到新知識，變得更有想像力，還能讓我們的心更溫暖。雖然有時候讀書可能有點難，但只要我們找到自己喜歡的書，就會覺得它像一個好朋友，陪我們一起成長。小朋友們，讓我們一起拿起書，開始一場知識的冒險吧！不管是故事書、科學書，還是漫畫書，每一本書都是一個新世界，等著我們去探索。每天讀一點書，你會發現自己越來越厲害，也越來越快樂！</p>
</div>




</div>








<!-- 內置的 DSE 評分原則 (隱藏) -->
<div id="dse-grading-principles" style="display: none;">
<h3>【擬卷理念】</h3>
<p>1. 考核能力：考核考生構思、表達、創作等能力。</p>
<p>2. 設題方式：或命題，或指定情境，並提供選擇。</p>
<p>3. 設題方向：主要環繞考生生活經驗及日常思考、關注的情或事；並盡量給予寫作空間，讓考生發揮創意。</p>
<p>4. 寫作要求：考生宜透過審題，思考寫作立意，選取材料，書寫文章。</p>
<p>5. 文體要求：以某類文體為主，或文體不限。</p>

<h3>【一般評分原則：審題、入品】</h3>
<p>1. 準確理解關鍵概念。</p>
<p>2. 明白寫作要求。</p>
<p>3. 把握不同品位的入品要求。</p>

<h3>【評分項目詳解】</h3>
<p><strong>內容 (40分):</strong></p>
<ul>
<li>立意、內容是否合乎寫作要求；是否豐富、深刻。</li>
<li>取材是否恰當；能否彰顯立意。</li>
<li>闡述是否合理、飽滿。</li>
</ul>
<p><strong>表達 (30分):</strong></p>
<ul>
<li>用詞是否精確、豐富。(主)</li>
<li>文句是否簡潔流暢。(主)</li>
<li>表達手法是否純熟靈活。(輔)</li>
</ul>
<p><strong>結構 (20分):</strong></p>
<ul>
<li>段落區分是否明晰。</li>
<li>起承轉合是否自然。</li>
<li>輕重詳略是否恰當。</li>
</ul>
<p><strong>標點字體 (10分):</strong></p>
<ul>
<li>字體為主，標點為輔。</li>
<li>標點使用在於準確和靈活，不在於數量多少。</li>
</ul>
<p><strong>錯別字 (3分):</strong></p>
<ul>
<li>0-1個給3分；2-4個給2分；5-7個給1分；8個或以上不給分。</li>
<li>重錯不計。</li>
</ul>

<h3>【離題卷評分】</h3>
<p>「內容」最高給「下上」；「表達」及「結構」最高給「中上」；「標點字體」最高仍可給「上上」。</p>

<h3>【字數不足650字】</h3>
<p>「內容」最高給分：550-649字：「上上」；450-549字：「中上」；300-449字：「中中(下)」；300字以下：「下上」。</p>

<h3>【一般評論摘要】</h3>
<p><strong>優勝之處:</strong></p>
<ul>
<li><strong>審題:</strong> 能正確理解題目。</li>
<li><strong>立意:</strong> 偶有佳作，能由日常生活引申至人生意義、生活哲理，呈現對生活有敏銳的觀察和思考。</li>
<li><strong>取材:</strong> 圍繞日常生活經歷或見聞取材。</li>
<li><strong>表達:</strong> 用詞大致恰當，文句大致通順；能恰當地敘事抒情、描繪人物或闡述看法；嘗試運用不同寫作手法。</li>
<li><strong>結構:</strong> 分段大致清晰，尚見脈絡；過渡合理，結構完整。</li>
</ul>
<p><strong>不足之處:</strong></p>
<ul>
<li><strong>審題:</strong> 流於表面，未抓緊題眼發揮。</li>
<li><strong>立意:</strong> 立意平常，層次不高。</li>
<li><strong>取材:</strong> 敘事忽略細節，描寫流於表面，論述粗疏簡略；未能翻出新意，提出精闢見解。</li>
<li><strong>表達:</strong> 經營不多，夾雜沙石；多口語入文、句子冗贅；部分與前文格格不入，影響達意。</li>
<li><strong>結構:</strong> 鮮能做到層層深化，前後呼應者；少數文章篇幅較長，惜時間所限，結果虎頭蛇尾；有詳略稍有失衡的情況。</li>
</ul>
</div>


<!-- 工具選擇 -->
<div class="box" id="toolsBox" style="display: none;">
    <h2>工具一覽：</h2>
    <button id="expandToolsBtn2">點擊展開</button>
<div id="effectContainer" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1001; pointer-events: none;"></div>
</div>



<!-- 範疇選擇：動漫卡片風格 (已修訂：放入一致的 Container) -->
<div class="box" id="mainMenuBox"> <!-- 這裡加上了 ID -->
    <h2>選擇範疇：</h2>
    
   <!-- 音效檔：拔劍出鞘 (Metal Sword Sheath) -->
    <audio id="ui-click-sound" preload="auto">
        <source src="點擊.mp3" type="audio/mpeg">
    </audio>

    <div class="category-cards-wrapper">
        <div class="category-cards-container">
            <!-- 閱讀卡片 -->
            <div id="readingBtn" class="anime-card" style="--bg-img: url('郵筒.png');">
                <div class="card-overlay"></div>
                <div class="card-border-effect"></div>
                <div class="card-content">
                 
                    <div class="card-text">
                        <span class="card-zh">閱讀</span>
                        <span class="card-en">READING</span>
                    </div>
                </div>
            </div>

            <!-- 敘事抒情卡片 -->
            <div id="writingBtn" class="anime-card" style="--bg-img: url('相機.png');">
                <div class="card-overlay"></div>
                <div class="card-border-effect"></div>
                <div class="card-content">
                  
                    <div class="card-text">
                        <span class="card-zh">敘事抒情</span>
                        <span class="card-en">NARRATIVE</span>
                    </div>
                </div>
            </div>

            <!-- 議論卡片 -->
            <div id="argumentBtn" class="anime-card" style="--bg-img: url('筆.png');">
                <div class="card-overlay"></div>
                <div class="card-border-effect"></div>
                <div class="card-content">
                
                    <div class="card-text">
                        <span class="card-zh">議論</span>
                        <span class="card-en">ARGUMENT</span>
                    </div>
                </div>
            </div>

            <!-- 整合拓展卡片 -->
            <div id="expandBtn" class="anime-card" style="--bg-img: url('火車.png');">
                <div class="card-overlay"></div>
                <div class="card-border-effect"></div>
                <div class="card-content">
                  
                    <div class="card-text">
                        <span class="card-zh">整合拓展</span>
                        <span class="card-en">EXPAND</span>
                    </div>
                </div>
            </div>

            <!-- 課外書籍卡片 -->
            <div id="booksBtn" class="anime-card" style="--bg-img: url('書.png');">
                <div class="card-overlay"></div>
                <div class="card-border-effect"></div>
                <div class="card-content">
             
                    <div class="card-text">
                        <span class="card-zh">課外書籍</span>
                        <span class="card-en">LIBRARY</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- 寫作容器 -->
<div id="writingContainer" class="box">
    <h2>敘事抒情</h2>
    <div style="position:relative; width:100%; height:0px; padding-bottom:62.222%"><iframe allow="fullscreen" allowfullscreen height="100%" src="https://streamable.com/e/lke2eo?loop=0" width="100%" style="border:none; width:100%; height:100%; position:absolute; left:0px; top:0px; bottom:2px; overflow:hidden;" referrerpolicy="no-referrer-when-downgrade" credentialless></iframe></div>

    <div class="function-selector-wrapper">
        <label for="writingType">選擇功能：</label>
        <select id="writingType" onchange="toggleWritingType()">
            <option value="" selected disabled>請在此選擇功能</option>
           
            <option value="大綱">大綱點評</option>
            <option value="片段描寫">文章點評</option>
			 <option value="guide">解題指引</option>
            <option value="敘事物象">敘事物象</option>
        </select>
    </div>

    <div id="writingContentContainer" style="display: none;">
        
        <!-- === 新增：解題指引區域 (修訂版) === -->
        <div id="writingGuideArea" style="display: none;">
            <label for="writingGuideTopicInput">請輸入題目：</label>
            <input type="text" id="writingGuideTopicInput" placeholder="例如：寂寞的真相、被遺忘的承諾..." style="font-size: 1.1rem;">
            
            <button id="submitWritingGuideBtn" class="btn-action" onclick="submitWritingGuide()">提交分析</button>

            <!-- 結果顯示區 -->
            <div id="writingGuideResultContainer" style="display: none; margin-top: 25px;">
                
                <!-- 第一部分：關鍵詞張力分析 -->
                <div class="guide-section-header" style="border-left: 5px solid #4A90E2; color: #4A90E2;">
                    <h3><i class="fas fa-search"></i> 題眼分析</h3>
                </div>
                <!-- 總體分析 (比喻與關係) -->
                <div id="guideIntro" class="guide-intro-card"></div>
                <!-- 三種心情 (三欄佈局) -->
                <div id="guideEmotions" class="guide-grid-3"></div>

                <!-- 第二部分：寫作方向建議 -->
                <div class="guide-section-header" style="border-left: 5px solid #28a745; color: #28a745; margin-top: 30px;">
                    <h3><i class="fas fa-compass"></i> 寫作方向</h3>
                </div>
                <!-- 三個故事種子 (三欄佈局) -->
                <div id="guideSeeds" class="guide-grid-3"></div>


<!-- 新增：解題指引的聊天室介面 -->
                <div id="writingGuideChatHistory" style="display: none; background-color: #f0f4f8; border: 1px solid #dde3ea; border-radius: 12px; padding: 20px 15px; margin-top: 15px; margin-bottom: 15px; max-height: 400px; overflow-y: auto; flex-direction: column;"></div>
                
                <div id="writingGuideChatInputContainer" style="display: none; align-items: center; gap: 10px; margin-top: 15px;">
                    <textarea id="writingGuideUserInput" class="no-modal-editor" rows="2" placeholder="可就以上指引追問..." style="flex-grow: 1; margin: 0;"></textarea>
                    <button id="continueWritingGuideBtn" class="btn-icon-action" onclick="continueWritingGuideDiscussion()" title="繼續討論" style="background-color: #2d9966;">
                        <i class="fas fa-paper-plane"></i>
                    </button>
				</div>

				
                <!-- 儲存按鈕 -->
                <div class="result-wrapper">
                    <button id="save-guide-html-btn" class="btn-save-html" title="儲存為HTML檔案" onclick="savePageAsHTML('神思-敘事抒情-解題指引.html')" style="display: flex;">
                        <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                    </button>
                </div>
            </div>
        </div>
        <!-- === 新增結束 === -->

        <div id="outlineStructureArea" style="display: none;">
            <label for="structure">選擇大綱結構：</label>
            <select id="structure" onchange="generateOutlineTable()">
                <option value="fourPart">起承轉合</option>
                <option value="threeLine">三線</option>
            </select>
        </div>
        
        <!-- ... 舊有代碼保持不變 ... -->
        <div id="topicSelectionArea">
            <label>選擇題目方式：</label>
            <div class="topic-buttons-container">
                <button class="btn btn-generate" onclick="generateTopic(this)">
                    <i class="fas fa-sync-alt"></i> 生成
                </button>
                <button class="btn btn-custom" onclick="showCustomTopicInput(this)">
                    <i class="fas fa-edit"></i> 自訂
                </button>
            </div>
            <div id="customTopicArea" style="display: none; margin-top: 15px;"></div>
        </div>

        <div id="topicResult"></div>
        <div id="narrativeElementsArea" style="display: none;">
            <label for="narrativeElements">請輸入您的取材或故事背景：</label>
            <textarea id="narrativeElements" rows="5" placeholder="例如：故事背景、人物設定、取材等..."></textarea>
        </div>
        
        <div id="writingArea">
            <div id="outlineTableArea"></div>
            <div id="outlineButtons" style="display: none;" class="action-buttons-container">
                <button class="btn-icon-action btn-save-icon" onclick="saveOutline()" title="儲存大綱">
                    <i class="fas fa-save"></i>
                </button>
                <button class="btn-icon-action btn-clear-icon" onclick="clearOutline()" title="清空大綱">
                    <i class="fas fa-trash-alt"></i>
                </button>
            </div>
            <textarea id="writingContent" rows="10" placeholder="請在此輸入您的文章..." style="display: none;"></textarea>
            
            <label for="writingTone" id="writingToneLabel" class="tone-selector-label" style="display: none;">選擇點評語氣：</label>
            <select id="writingTone" style="display: none;">
                <option value="serious">嚴肅正經</option>
                <option value="chen">陳SIR語氣</option>
            </select>

            <label for="writingReviewer" id="writingReviewerLabel" class="tone-selector-label" style="display: none;">選擇閱卷員：</label>
            <select id="writingReviewer" style="display: none;">
                <option value="chen_sir" selected>陳Sir</option>
                <option value="ms_chan">Ms Chan</option>
                <option value="huang_laoshi">黃老師</option>
                <option value="deng_laoshi">鄧老師</option>
                <option value="xiao_laoshi">蕭老師</option>
                <option value="dong_laoshi">董老師</option>
                <option value="li_laoshi">李老師</option>
                <option value="zhen_laoshi">甄老師</option>
                <option value="wen_laoshi">溫老師</option>
                <option value="jiang_laoshi">江老師</option>
            </select>

            <div id="reviewScopeArea" style="display: none; margin-top: 25px;">
                <label class="tone-selector-label">選擇點評範疇：</label>
                <div class="scope-selector-container">
                    <label class="scope-label all-scope"><input type="checkbox" name="reviewScope" value="全部" checked> 全部</label>
                    <label class="scope-label"><input type="checkbox" name="reviewScope" value="扣題"> 扣題</label>
                    <label class="scope-label"><input type="checkbox" name="reviewScope" value="立意"> 立意</label>
                    <label class="scope-label"><input type="checkbox" name="reviewScope" value="取材"> 取材</label>
                    <label class="scope-label"><input type="checkbox" name="reviewScope" value="詳略"> 詳略</label>
                    <label class="scope-label"><input type="checkbox" name="reviewScope" value="文筆"> 文筆</label>
                </div>
            </div>

            <button id="submitWritingBtn" class="btn-action" onclick="submitWriting()">提交</button>
            
            <div id="writingReviewResultContainer">
                <div id="writingGradingResult"></div>
                <div id="writingChatHistory" style="display: none;"></div>
                <div id="writingChatInputContainer" style="display: none;">
                    <textarea id="writingUserInput" class="no-modal-editor" rows="2" placeholder="可就以上點評追問..."></textarea>
                    <button id="continueWritingBtn" class="btn-icon-action" onclick="continueWritingDiscussion()" title="繼續討論" style="background-color: #2d9966;">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
            
            <div class="result-wrapper" style="position: relative;">
                <div id="commentResult"></div>
                <button id="save-writing-html-btn" class="btn-save-html" title="儲存為HTML檔案" onclick="savePageAsHTML('神思-敘事抒情.html')">
                    <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                </button>
            </div>
        </div>
    </div>
</div>



<!-- 閱讀容器 -->
<div id="readingContainer" class="box" style="display: none;">
<h2>閱讀</h2>
<div style="position:relative; width:100%; height:0px; padding-bottom:62.222%"><iframe allow="fullscreen" allowfullscreen height="100%" src="https://streamable.com/e/vt3i1j?loop=0" width="100%" style="border:none; width:100%; height:100%; position:absolute; left:0px; top:0px; bottom:2px; overflow:hidden;" referrerpolicy="no-referrer-when-downgrade" credentialless></iframe></div>

<div class="function-selector-wrapper">
<label for="readingFunction">選擇功能：</label>
<select id="readingFunction" onchange="toggleReadingFunction()">
<option value="" selected disabled>請在此選擇功能</option>
<option value="comment">點評</option>
<option value="guide">指引</option>
<option value="training">訓練</option>  <!-- 新增此行 -->
</select>
</div>

<div id="readingInputArea" style="display: none;">
<label for="readingPassage">貼上閱讀篇章：</label>
<textarea id="readingPassage" rows="10" placeholder="請在此貼上閱讀篇章..."></textarea>
<label for="readingQuestion">貼上題目：</label>
<textarea id="readingQuestion" rows="3" placeholder="請在此貼上題目..."></textarea>
<div id="studentAnswerArea" style="display: none;">
<label for="studentAnswer">貼上答案：</label>
<textarea id="studentAnswer" rows="5" placeholder="請在此貼上答案..."></textarea>
</div>
<label for="readingTone" id="readingToneLabel" class="tone-selector-label" style="display: none;">選擇點評語氣：</label>
<select id="readingTone" style="display: none;">
<option value="serious">嚴肅正經</option>
<option value="chen">陳SIR語氣</option>
</select>
<!-- 將 <button onclick="submitReading()"> 改為： -->
<button id="submitReadingBtn" class="btn-action" onclick="submitReading()">提交</button>
<div class="result-wrapper" style="position: relative;">
	<div id="readingResult"></div>
	<button id="save-reading-html-btn" class="btn-save-html" title="儲存為HTML檔案" onclick="savePageAsHTML('神思-閱讀理解.html')">
		<svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
	</button>
</div>
</div>
</div>

<!-- 課外書籍容器 -->
<div id="booksContainer" class="box" style="display: none;">
<h2>課外書籍討論</h2>
<div style="position:relative; width:100%; height:0px; padding-bottom:62.222%"><iframe allow="fullscreen" allowfullscreen height="100%" src="https://streamable.com/e/4eznsi?loop=0" width="100%" style="border:none; width:100%; height:100%; position:absolute; left:0px; top:0px; bottom:2px; overflow:hidden;" referrerpolicy="no-referrer-when-downgrade" credentialless></iframe></div>

<!-- 初始輸入表單 -->
<div id="initialDiscussionForm">
<p>請在下方填寫書名、作者和討論問題，開始與陳SIR對話：</p>
<input type="text" id="bookTitle" class="no-modal-editor" placeholder="書名">
<input type="text" id="author" class="no-modal-editor" placeholder="作者">
<textarea id="discussionQuestion" class="no-modal-editor" rows="3" placeholder="討論問題"></textarea>
<label for="booksTone">選擇語氣：</label>
<select id="booksTone">
<option value="serious">嚴肅正經</option>
<option value="casual">輕鬆活潑</option>
</select>
<div id="discussionControlButtons">
<button id="startDiscussionBtn" class="btn-action" onclick="startDiscussion()">開始討論</button>
</div>
</div>

<!-- 聊天歷史紀錄 -->
<div class="result-wrapper" style="position: relative;">
	<div id="chatHistory"></div>
	
</div>


<!-- 聊天輸入介面 (已移除新增按鈕) -->
<div id="chatInputContainer">
<textarea id="userInput" class="no-modal-editor" rows="2" placeholder="請在此輸入您的回應..."></textarea>
<button id="continueBtn" class="btn-icon-action" onclick="continueDiscussion()" title="繼續討論" style="background-color: #2d9966;">
<i class="fas fa-paper-plane"></i>
</button>
</div>

<!-- 儲存/清除按鈕 (已加入新增按鈕) -->
<div id="booksButtons" class="action-buttons-container">
    <button id="save-books-html-btn" class="btn-icon-action" title="儲存為HTML檔案" onclick="savePageAsHTML('神思-課外書討論.html')">
        <i class="fas fa-download"></i>
    </button>
	
<!-- 「新增討論」按鈕已移到此處，位於儲存按鈕左方 -->
<button id="newTopicBtn" class="btn-icon-action btn-add-icon" title="新增討論主題">
<i class="fas fa-plus"></i>
</button>
<button class="btn-icon-action btn-save-icon" onclick="saveBooksChat()" title="儲存對話">
<i class="fas fa-save"></i>
</button>
<button class="btn-icon-action btn-clear-icon" onclick="clearBooksChat()" title="清空對話">
<i class="fas fa-trash-alt"></i>
</button>
</div>
</div>

<!-- 新增討論的彈出視窗 -->
<div id="newTopicModal" class="books-modal">
<div class="modal-content">
<span class="close-modal-btn" id="closeNewTopicModal">&times;</span>
<h3>新增討論</h3>
<input type="text" id="modalBookTitle" class="no-modal-editor" placeholder="書名">
<input type="text" id="modalAuthor" class="no-modal-editor" placeholder="作者">
<textarea id="modalDiscussionQuestion" class="no-modal-editor" rows="3" placeholder="討論問題"></textarea>
<div style="text-align: right; margin-top:15px;">
<button id="modalStartDiscussionBtn" class="btn-icon-confirm" title="開始新討論">
<i class="fas fa-check"></i>
</button>
</div>
</div>
</div>


<!-- 整合拓展容器 -->
<div id="expandContainer" class="box" style="display: none;">
<h2>整合拓展</h2>
<div style="position:relative; width:100%; height:0px; padding-bottom:62.222%"><iframe allow="fullscreen" allowfullscreen height="100%" src="https://streamable.com/e/2otwxv?loop=0" width="100%" style="border:none; width:100%; height:100%; position:absolute; left:0px; top:0px; bottom:2px; overflow:hidden;" referrerpolicy="no-referrer-when-downgrade" credentialless></iframe></div>

<div class="function-selector-wrapper">
<label for="expandFunction">選擇功能：</label>
<select id="expandFunction" onchange="toggleExpandFunction()">
<option value="" selected disabled>請在此選擇功能</option>
<option value="comment">點評</option>
<option value="guide">指引</option>
</select>
</div>

<div id="expandContentContainer" style="display: none;">

<div id="expandTopicSelectionArea" style="display: none;">
<label>選擇題目方式：</label>
<div class="topic-buttons-container">
<!-- 套用新的 class: btn-generate -->
<button class="btn btn-generate" onclick="generateExpandTopic(this)">
<i class="fas fa-sync-alt"></i> 生成
</button>
<!-- 套用新的 class: btn-custom -->
<button class="btn btn-custom" onclick="showExpandCustomTopicInput(this)">
<i class="fas fa-edit"></i> 自訂
</button>
</div>
<!-- 這個 div 用來動態顯示自訂題目的輸入框 -->
<div id="expandCustomTopicInputArea" style="display: none; margin-top: 15px;">
</div>
</div>
<div id="expandTopicResult"></div>

<div id="expandWritingArea" style="display: none;">
<label for="expandContent">整合拓展（最多180字）：</label>
<textarea id="expandContent" rows="5" placeholder="請在此輸入整合拓展內容..." oninput="updateCharCount()"></textarea>
<p id="charCount">剩餘字數：180</p>
<label for="expandTone" id="expandToneLabel" class="tone-selector-label" style="display: none;">選擇點評語氣：</label>
<select id="expandTone" style="display: none;">
<option value="serious">嚴肅正經</option>
<option value="chen">陳SIR語氣</option>
</select>
<!-- 將 <button onclick="submitExpand()"> 改為： -->
<button id="submitExpandBtn" class="btn-action" onclick="submitExpand()">提交</button>
<div class="result-wrapper" style="position: relative;">
	<div id="expandCommentResult"></div>
	<button id="save-expand-comment-html-btn" class="btn-save-html" title="儲存為HTML檔案" onclick="savePageAsHTML('神思-整合拓展-點評.html')">
		<svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
	</button>
</div>
</div>

<div id="expandGuideArea" style="display: none;">
<table>
<tr><th>題目</th><td><input type="text" id="expandGuideTitle" placeholder="請輸入題目"></td></tr>
<tr><th>主題句</th><td><textarea id="expandGuideTheme" rows="2" placeholder="請輸入主題句"></textarea></td></tr>
<tr><th>抄錄資料</th><td><textarea id="expandGuideData" rows="3" placeholder="請輸入抄錄資料"></textarea></td></tr>
<tr><th>整合拓展</th><td><textarea id="expandGuideExpand" rows="3" placeholder="請輸入整合拓展"></textarea></td></tr>
</table>
<!-- 【修訂處】為按鈕添加 ID -->
<button id="submitExpandGuideBtn" class="btn-action" onclick="submitExpand()">提交</button>
<div style="position: relative;">
	<div id="expandGuideResult"></div>
	<button id="save-expand-guide-html-btn" class="btn-save-html" title="儲存為HTML檔案" onclick="savePageAsHTML('神思-整合拓展-指引.html')">
		<svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
	</button>
</div>
</div></div>
</div>

<!-- 議論容器 -->
<div id="argumentContainer" class="box" style="display: none;">
<h2>議論</h2>
<div style="position:relative; width:100%; height:0px; padding-bottom:62.222%"><iframe allow="fullscreen" allowfullscreen height="100%" src="https://streamable.com/e/0ki8mx?loop=0" width="100%" style="border:none; width:100%; height:100%; position:absolute; left:0px; top:0px; bottom:2px; overflow:hidden;" referrerpolicy="no-referrer-when-downgrade" credentialless></iframe></div>

<div class="function-selector-wrapper">
<label for="argumentType">選擇功能：</label>
<select id="argumentType" onchange="toggleArgumentType()">
<option value="" selected disabled>請在此選擇功能</option>
<option value="outline">大綱點評</option>
<option value="writing">文章點評</option>
<option value="guide">指引</option>
</select>
</div>

<div id="argumentContentContainer" style="display: none;">
<div id="argumentTopicSelectionArea">
<label>選擇題目方式：</label>
<div class="topic-buttons-container">
<!-- 套用新的 class: btn-generate -->
<button class="btn btn-generate" onclick="generateArgumentTopic(this)">
<i class="fas fa-sync-alt"></i> 生成
</button>
<!-- 套用新的 class: btn-custom -->
<button class="btn btn-custom" onclick="showArgumentCustomTopicInput(this)">
<i class="fas fa-edit"></i> 自訂
</button>
</div>
<div id="argumentCustomTopicArea" style="display: none; margin-top: 15px;">
<!-- 內容將由 JavaScript 動態生成 -->
</div>
</div>
<div id="argumentTopicResult"></div>
<div id="argumentOutlineArea" style="display: none;">

<div id="argumentOutlineTableArea"></div>

<!-- 按鈕容器現在包含了新增、儲存和清除按鈕 -->
<div id="argumentOutlineButtons" class="action-buttons-container">
<button class="btn-icon-action btn-add-icon" onclick="addArgumentStructureSegment()" title="新增結構段">
<i class="fas fa-plus"></i>
</button>
<button class="btn-icon-action btn-save-icon" onclick="saveArgumentOutline()" title="儲存大綱">
<i class="fas fa-save"></i>
</button>
<button class="btn-icon-action btn-clear-icon" onclick="clearArgumentOutline()" title="清空大綱">
<i class="fas fa-trash-alt"></i>
</button>
</div>

<label for="argumentOutlineTone" class="tone-selector-label">選擇點評語氣：</label>
<select id="argumentOutlineTone">
<option value="serious">嚴肅正經</option>
<option value="chen">陳SIR語氣</option>
</select>
<button id="submitArgumentOutlineBtn" class="btn-action" onclick="submitArgumentOutline()">提交</button>
<div class="result-wrapper" style="position: relative;">
	<div id="argumentOutlineResult"></div>
	<button id="save-argument-outline-html-btn" class="btn-save-html" title="儲存為HTML檔案" onclick="savePageAsHTML('神思-議論-大綱點評.html')">
		<svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
	</button>
</div>
</div>
<div id="argumentWritingArea" style="display: none;">
<textarea id="argumentWritingContent" rows="10" placeholder="請在此輸入您的文章..."></textarea>
<label for="argumentWritingTone" class="tone-selector-label">選擇點評語氣：</label>
<select id="argumentWritingTone">
        <option value="serious">嚴肅正經</option>
        <option value="chen">陳SIR語氣</option>
    </select>

    <!-- ======= 請在這裡加入以下程式碼 ======= -->
    <label for="argumentReviewer" class="tone-selector-label">選擇閱卷員：</label>
    <select id="argumentReviewer">
      <option value="chen_sir" selected>陳Sir</option>
      <option value="ms_chan">Ms Chan</option>
      <option value="huang_laoshi">黃老師</option>
      <option value="deng_laoshi">鄧老師</option>
      <option value="xiao_laoshi">蕭老師</option>
      <option value="dong_laoshi">董老師</option>
      <option value="li_laoshi">李老師</option>
      <option value="zhen_laoshi">甄老師</option>
      <option value="wen_laoshi">溫老師</option>
      <option value="jiang_laoshi">江老師</option>
    </select>
    <!-- ======= 加入結束 ======= -->

<!-- ======= 請在這裡加入【議論文點評範疇】HTML 程式碼 ======= -->
<div id="argumentReviewScopeArea" style="display: none; margin-top: 25px;">
    <label class="tone-selector-label">選擇點評範疇：</label>
    <div class="scope-selector-container">
        <label class="scope-label all-scope"><input type="checkbox" name="argumentReviewScope" value="全部" checked> 全部</label>
        <label class="scope-label"><input type="checkbox" name="argumentReviewScope" value="謀篇"> 謀篇</label>
        <label class="scope-label"><input type="checkbox" name="argumentReviewScope" value="論點"> 論點</label>
        <label class="scope-label"><input type="checkbox" name="argumentReviewScope" value="論據"> 論據</label>
        <label class="scope-label"><input type="checkbox" name="argumentReviewScope" value="論證"> 論證</label>
        <label class="scope-label"><input type="checkbox" name="argumentReviewScope" value="文筆"> 文筆</label>
    </div>
</div>
<!-- ======= 加入結束 ======= -->

  <button id="submitArgumentWritingBtn" class="btn-action" onclick="submitArgumentWriting()">提交</button>

    <!-- 正確的結構：用 result-wrapper 包裹住所有結果和聊天介面 -->
    <div class="result-wrapper">
        
        <!-- 評分卡、文字點評和聊天介面都將被動態放入這個容器中 -->
        <div id="argumentReviewResultContainer">
            <!-- 評分系統或聚焦式點評將會被動態插入到這裡 -->
            <div id="argumentGradingResult"></div>

            <!-- 聊天歷史紀錄 -->
            <div id="argumentChatHistory" style="display: none;"></div>

            <!-- 聊天輸入介面 -->
            <div id="argumentChatInputContainer" style="display: none;">
                <textarea id="argumentUserInput" class="no-modal-editor" rows="2" placeholder="可就以上點評追問..."></textarea>
                <button id="continueArgumentBtn" class="btn-icon-action" onclick="continueArgumentDiscussion()" title="繼續討論" style="background-color: #2d9966;">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>

        <!-- 儲存按鈕現在位於正確的包裹層內 -->
        <button id="save-argument-writing-html-btn" class="btn-save-html" title="儲存為HTML檔案" onclick="savePageAsHTML('神思-議論-文章點評.html')">
            <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
        </button>
    </div>
</div>
<div id="argumentGuideArea" style="display: none;">
<label for="argumentGuideTopic">題目：</label>
<input type="text" id="argumentGuideTopic" placeholder="請輸入題目">
<label for="argumentGuidePoint">論點（可選）：</label>
<textarea id="argumentGuidePoint" rows="3" placeholder="請輸入論點"></textarea>
<label for="argumentGuideEvidence">論據（可選）：</label>
<textarea id="argumentGuideEvidence" rows="3" placeholder="請輸入論據"></textarea>
<label for="argumentGuideArgument">論證（可選）：</label>
<textarea id="argumentGuideArgument" rows="3" placeholder="請輸入論證"></textarea>
<button id="submitArgumentGuideBtn" class="btn-action" onclick="submitArgumentGuide()">提交</button>
<div class="result-wrapper" style="position: relative;">
	<div id="argumentGuideResult"></div>
	<button id="save-argument-guide-html-btn" class="btn-save-html" title="儲存為HTML檔案" onclick="savePageAsHTML('神思-議論-指引.html')">
		<svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
	</button>
</div>
</div>
</div>
</div>

<!-- 音樂播放器 HTML (已更換圖示) -->
<!-- 音樂播放器 HTML (已移除懸浮按鈕) -->
<div id="music-player">
    <div class="controls">
        <select id="music-select">
            <option value="">選擇音樂</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Battle-Abysswalker.mp3">The Abysswalker</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Battle-Rosemoon.mp3">死せる都の戰乙女</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Battle-deadly.mp3">五大罪</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Battle-rapier.mp3">繼承劍的少女</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Ariadne-Battle.mp3">不屈意志之刃</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/battle-arms.mp3">西部戰鬥</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Battle.mp3">Battle Theme</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Wanderers-City.mp3">流浪城鎮</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Remotest-Liblary.mp3">沉睡的記憶</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Nostalgia.mp3">麥田懷舊</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/sunbeams.mp3">放學後</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/village.mp3">鄉村生活</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Take-a-Rest.mp3">休息一下</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/winter-snow.mp3">雪鄉</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Forgotten-Place.mp3">被遺忘的地方</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Rest-in-Peace.mp3">安息</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Farewell.mp3">告別</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/reminiscence.mp3">回憶</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/starry-night.mp3">星夜</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/last-wish.mp3">當思念傳到某人耳畔</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/sorrow.mp3">超越悲傷</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/hotarumichi.mp3">螢火蟲之路</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Sky-Airship.mp3">飛艇</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Voyage_SE.mp3">跨越神秘之海</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/main-theme01.mp3">盼望</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/saikai637.mp3">約定之地</option>
        </select>
        <button id="play-pause" title="播放/暫停"><i class="fas fa-play"></i></button>
    </div>
    
    <div class="progress">
        <input type="range" id="progress-bar-music" value="0" min="0" max="100">
    </div>
    
    <div class="mode">
        <select id="play-mode">
            <option value="loop" selected>單曲循環</option>
            <option value="next">自動播放下首</option>
        </select>
    </div>
    
    <button class="hide-btn" id="hide-player" title="關閉播放器"><i class="fas fa-chevron-down"></i></button>
</div>

<!-- 必須保留這個 audio 標籤，否則無法播放音樂 -->
<audio id="audio" preload="auto"></audio>

<!-- === 歷史紀錄容器 (最終版) === -->
<div id="historyContainer" class="box" style="display: none;">
    
 <!-- 標題列 -->
    <div class="history-header-bar" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid #eee;">
        <h2 style="margin:0; color: #333; font-size: 1.5em;"><i class="fas fa-history"></i> 歷史紀錄</h2>
        
        <div style="display: flex; gap: 10px;">
            <!-- 修正：日期搜尋按鈕與隱藏輸入框 -->
            <div id="historyDateSearchContainer" style="display: none; position: relative;">
                <!-- 按鈕現在可以被正常點擊，觸發 triggerDatePicker() -->
                <button class="history-clear-btn" title="依日期搜尋" onclick="triggerDatePicker()">
                    <i class="fas fa-calendar-alt"></i>
                </button>
                
                <!-- 修正重點：將 width/height 設為 0，移除 z-index，避免遮擋按鈕 -->
                <input type="date" id="historyDatePicker" onchange="scrollToHistoryDate(this)" 
                       style="position: absolute; top: 0; left: 0; width: 0; height: 0; opacity: 0; border: none; padding: 0;">
            </div>

            <!-- 原有的：清空按鈕 -->
            <button class="history-clear-btn" title="清空所有紀錄" onclick="clearAllHistory()">
                <i class="fas fa-trash-alt"></i>
            </button>
        </div>
    </div>

    <!-- 麵包屑導航 -->
    <div id="historyBreadcrumb" class="history-breadcrumb" style="display: none; margin-bottom: 20px; padding: 10px 15px; background: rgba(0,0,0,0.05); border-radius: 8px; font-size: 1rem;">
        <span onclick="renderHistoryCategories()" style="cursor: pointer; color: #007bff; font-weight: bold;"><i class="fas fa-home"></i> 主範疇</span> 
        <span id="breadcrumb-sep-1" style="display:none; color: #666;"> &gt; </span>
        <span id="breadcrumb-category" onclick="backToSubFunctions()" style="cursor: pointer; color: #007bff; display:none;"></span>
        <span id="breadcrumb-sep-2" style="display:none; color: #666;"> &gt; </span>
        <span id="breadcrumb-sub" style="font-weight: bold; color: #333; display:none;"></span>
    </div>

    <!-- 第一層：主範疇選擇 (卡片容器) -->
    <div id="historyLevel1Wrapper" class="category-cards-wrapper" style="padding-top: 10px; padding-bottom: 20px;">
        <div id="historyLevel1" class="category-cards-container">
            <!-- JS 將在這裡生成動漫卡片 -->
        </div>
    </div>

    <!-- 第二層：子功能選擇 (Grid 選單) -->
    <div id="historyLevel2" class="history-grid-menu" style="display: none;">
        <!-- JS 生成子功能按鈕 -->
    </div>

    <!-- 第三層：紀錄列表 -->
    <div id="historyLevel3" class="history-list-container" style="display: none;">
        <!-- JS 生成紀錄卡片 -->
    </div>
</div>

<!-- === 歷史紀錄詳細檢視視窗 (保持不變) === -->
<div id="historyModal" class="preview-modal-overlay">
    <div class="preview-modal-content" style="max-width: 900px; height: 90%;">
        <div class="history-modal-header" style="padding: 15px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center;">
            <h3 id="historyModalTitle" style="margin: 0; color: #2A9689;">紀錄詳情</h3>
            <span id="historyModalDate" style="color: #888; font-size: 0.9em;"></span>
        </div>
        <div class="preview-modal-body" style="padding: 20px; overflow-y: auto; display: block;">
            <div id="historyModalContent"></div>
        </div>
        <button class="preview-close-btn" onclick="closeHistoryModal()" style="top: 10px; right: 10px;">&times;</button>
    </div>
</div>

	
<!-- 展開工具二 (語薈) 容器 -->
<div id="toolsContainer2">
<button id="closeToolsBtn2">&times;</button>
<div class="main-container">
<!-- Floating Title -->
<!-- Floating Title -->
<header class="floating-header">
<h1>語薈</h1>
<button id="video-tour-btn" title="觀看介紹影片">
<svg class="icon" viewBox="0 0 24 24"><use xlink:href="#icon-video"></use></svg>
</button>
</header>

<!-- Embedded SVG Icons -->
<svg width="0" height="0" style="position:absolute">
<defs>
<symbol id="icon-brain" viewBox="0 0 24 24"><path d="M7.445 11.232C7.445 10.537 7.98 9.96 8.629 9.96H9.02V8.203H7.818C6.983 8.203 6.3 8.91 6.3 9.778V11.23H5.161C4.326 11.23 3.644 11.938 3.644 12.806V14.17H2.82C2.17 14.17 1.636 14.746 1.636 15.44V17.65H1.523C.688 17.65 0 18.358 0 19.226V20.48C0 21.35 0.688 22.056 1.523 22.056H6.738C6.738 23.13 7.573 24 8.628 24H15.37C16.425 24 17.26 23.13 17.26 22.058H22.477C23.312 22.058 24 21.35 24 20.48V19.225C24 18.357 23.312 17.65 22.477 17.65H22.364V15.44C22.364 14.745 21.83 14.17 21.18 14.17H20.356V12.805C20.356 11.937 19.674 11.23 18.839 11.23H17.68V9.777C17.68 8.908 17.017 8.2 16.182 8.2H14.98V9.96H15.37C16.02 9.96 16.555 10.536 16.555 11.23V12.986H15.37V15.92H8.629V12.986H7.445V11.232M11.1 11.23H12.9V14.17H11.1V11.23M12 1.947C10.13 1.947 8.58 2.894 7.854 4.316C7.65 3.52 7.2 2.813 6.545 2.27C5.124 1.053 2.95 1.54 1.987 3.16C0.945 4.925 1.489 7.346 3.09 8.528C3.21 8.62 3.33 8.71 3.464 8.78C3.464 7.024 4.818 5.618 6.52 5.618C8.22 5.618 9.573 7.024 9.573 8.78V9.1H14.4V8.78C14.4 7.024 15.78 5.618 17.48 5.618C19.18 5.618 20.536 7.024 20.536 8.78C20.662 8.71 20.782 8.62 20.91 8.528C22.51 7.346 23.055 4.925 22.013 3.16C21.05 1.54 18.876 1.053 17.455 2.27C16.8 2.813 16.35 3.52 16.145 4.316C15.42 2.894 13.87 1.947 12 1.947Z"/></symbol>
<symbol id="icon-write" viewBox="0 0 24 24"><path d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.13,5.12L18.88,8.87M3,17.25V21H6.75L17.81,9.94L14.06,6.19L3,17.25Z" /></symbol>
<symbol id="icon-read" viewBox="0 0 24 24"><path d="M18.5,1.15C19.9,1.15 21.15,2.4 21.15,3.85V15.85C21.15,17.3 19.9,18.55 18.5,18.55H5.5C4.1,18.55 2.85,17.3 2.85,15.85V3.85C2.85,2.4 4.1,1.15 5.5,1.15H18.5M18.5,22.85H5.5C2.45,22.85 0,20.4 0,17.35V2.35C0,1.4 0.35,0.6 0.95,0.1C1.25,-0.1 1.7,-0.05 2,0.25L3.1,1.35C3.3,1.55 3.3,1.85 3.1,2.05L2.05,3.1C1.85,3.3 1.55,3.3 1.35,3.1L0.7,2.45C0.7,5.55 2.85,7.85 5.5,7.85H18.5C21.15,7.85 23.3,5.55 23.3,2.45L22.6,3.1C22.4,3.3 22.1,3.3 21.9,3.1L20.85,2.05C20.65,1.85 20.65,1.55 20.85,1.35L21.95,0.25C22.25,-0.05 22.7,-0.1 23,0.1C23.6,0.6 24,1.4 24,2.35V17.35C24,20.4 21.5,22.85 18.5,22.85Z" /></symbol>
<symbol id="icon-work" viewBox="0 0 24 24"><path d="M14,6V4H10V6H14M18,9H15V6H9V9H6A2,2 0 0,0 4,11V19A2,2 0 0,0 6,21H18A2,2 0 0,0 20,19V11A2,2 0 0,0 18,9Z" /></symbol>
<symbol id="icon-support" viewBox="0 0 24 24"><path d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z" /></symbol>
<symbol id="icon-foundation" viewBox="0 0 24 24"><path d="M12 2L2 7V17L12 22L22 17V7L12 2ZM19.6 8.25L12 12.5L4.4 8.25L12 4L19.6 8.25Z"/></symbol>
<symbol id="icon-explore" viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A1.5,1.5 0 0,1 13.5,5.5A1.5,1.5 0 0,1 12,7A1.5,1.5 0 0,1 10.5,5.5A1.5,1.5 0 0,1 12,4M12,18.2C9.5,18.2 7.29,16.42 6.5,14H17.5C16.71,16.42 14.5,18.2 12,18.2Z"/></symbol>
<symbol id="icon-video" viewBox="0 0 24 24"><path d="M17,10.5V7A1,1 0 0,0 16,6H4A1,1 0 0,0 3,7V17A1,1 0 0,0 4,18H16A1,1 0 0,0 17,17V13.5L21,17.5V6.5L17,10.5Z" /></symbol>
</defs>
</svg>

<!-- Mind Map Layout -->
<main class="mind-map-container" id="mind-map">
<svg class="connector-svg" id="connector-svg"></svg>

<!-- 1. Core AI -->
<div class="category" id="core-ai" data-connect-to="">
<div class="node" data-id="core-ai-node" style="padding: 10px 20px;">
<a href="https://kenchan20141.github.io/AIChinese/" data-tool-id="sansi">






<svg class="icon" style="width:32px; height:32px;"><use xlink:href="#icon-brain"></use></svg>
神思
</a>
</div>
<div class="sub-group" style="flex-direction: row; gap: 10px;">
<div class="node level-3"><a href="https://kenchan20141.github.io/AIChinese2/" data-tool-id="sansi-backup">神思 (備用)</a></div>
<div class="node level-3"><a href="https://sansi.vercel.app/" data-tool-id="sansi-v3">神思 (V3)</a></div>
</div>
</div>

<!-- Foundations tier -->
<div id="foundations" data-connect-to="core-ai-node">
<div class="foundation-item" data-id="foundation-tizi">
<div class="category-title"><svg class="icon"><use xlink:href="#icon-foundation"></use></svg>應試</div>
<div class="sub-group-title">AI擬題</div>
<div class="node level-2"><a href="question.html" data-tool-id="tizi">題孳<br></a></div>
</div>
<div class="foundation-item" data-id="foundation-explore">
<div class="category-title"><svg class="icon"><use xlink:href="#icon-explore"></use></svg>課外探索</div>
<div class="sub-group-title">課外篇章</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/reading/" data-tool-id="reading-pieces">文學・片段</a></div>
<div class="node level-2"><a href="mensyu.html" data-tool-id="mensyu">文樞</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/slowreading/" data-tool-id="slowreading">慢讀</a></div>
<div class="sub-group-title">主題探討</div>
<div class="node level-2"><a href="https://litstudy.vercel.app/" data-tool-id="study">文學專題探究</a></div>

<div class="sub-group-title">生活詩意</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/wabisabi/" data-tool-id="wabisabi">一瞬之詩</a></div>
<div class="sub-group-title">書籍推薦</div>
<div class="node level-2"><a href="https://621d05f47d591.site123.me/%E6%9B%B8%E9%96%A3%E8%97%8F%E6%9B%B8%E6%A6%82%E8%A6%BD" data-tool-id="book-overview">書籍概覽</a></div>
	<div class="sub-group-title">歌詞遊戲</div>
<div class="node level-2"><a href="https://lyricschi.vercel.app/" data-tool-id="lyrics">詞海拾心</a></div>
</div>
</div>

<!-- 2. Writing -->
<div class="category" id="writing" data-connect-to="foundation-tizi">
<div class="category-title"><svg class="icon"><use xlink:href="#icon-write"></use></svg>寫作創作</div>
<div class="sub-group">
<div class="sub-group-title">AI範文</div>
<div class="node level-2"><a href="writing-d.html" data-tool-id="fanshui-narrative">翻水 (敘事)</a></div>
<div class="node level-2"><a href="writing-a.html" data-tool-id="fanshui-argument">翻水 (議論)</a></div>
</div>
<div class="sub-group">
<div class="sub-group-title">草擬</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/manuscriptpaper/" data-tool-id="manuscript">智能原稿紙</a></div>
</div>
<div class="sub-group">
<div class="sub-group-title">潤色與延伸</div>
<div class="node level-2"><a href="thinking.html" data-tool-id="words">思維訓練工具</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/slideshow/" data-tool-id="slideshow">文章幻燈片</a></div>
</div>
</div>

<!-- 3. Reading -->
<div class="category" id="reading" data-connect-to="foundation-tizi">
<div class="category-title"><svg class="icon"><use xlink:href="#icon-read"></use></svg>閱讀溫習</div>
<div class="sub-group">
<div class="sub-group-title">課文溫習</div>
<div class="node level-2" id="yuyilu-toggle"><a href="#">語弈錄 </a></div>






<div class="yuyilu-grades collapsed" id="yuyilu-grades">
<div class="node level-3"><a href="https://kenchan20141.github.io/f1chinese/" data-tool-id="yuyilu-f1">中一</a> | <a href="https://kenchan20141.github.io/chinese2/" data-tool-id="yuyilu-f2">中二</a> | <a href="https://kenchan20141.github.io/chinese3/" data-tool-id="yuyilu-f3">中三</a></div>
<div class="node level-3"><a href="https://kenchan20141.github.io/f4chinese/" data-tool-id="yuyilu-f4">中四</a> | <a href="https://kenchan20141.github.io/chinese/" data-tool-id="yuyilu-f5">中五</a> | <a href="https://kenchan20141.github.io/chinese6/" data-tool-id="yuyilu-f6">中六</a></div>
</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/timer/" data-tool-id="timer">背書神器</a></div>
</div>
<div class="sub-group">
<div class="sub-group-title">文言文</div>
<div class="node level-2"><a href="mensyu.html" data-tool-id="mensyu-2">文樞</a></div>
</div>
</div>

<!-- 4. Assignments -->
<div class="category" id="assignments" data-connect-to="core-ai-node">
<div class="category-title"><svg class="icon"><use xlink:href="#icon-work"></use></svg>工具</div>
<div class="sub-group">
<div class="sub-group-title">課業流程</div>
<div class="node level-2"><a href="https://script.google.com/a/macros/ccckyc.edu.hk/s/AKfycby1T18HxuFICIaR0LYWRuaqlpmglkL191bVl39MH69zj5CQ-uhozF17edtJ_T54NhZ5/exec" data-tool-id="zhiyun">帙雲</a></div>
</div>
<div class="sub-group">
<div class="sub-group-title">實用工具</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/WCT/" data-tool-id="zhuoyu">琢玉</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/quizbuzzer/" data-tool-id="quizbuzzer">搶答器</a></div>
	<div class="node level-2"><a href="https://kenchan20141.github.io/pulseqa/" data-tool-id="pulseqa">脈問堂</a></div>
<div class="node level-2"><a href="https://www.i2ocr.com/free-online-chinese-traditional-ocr" data-tool-id="ocr">手寫文字轉換 (OCR)</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/epub/" data-tool-id="epub">電子書閱讀器</a></div>
	<div class="node level-2"><a href="https://kenchan20141.github.io/decibelmeter/" data-tool-id="decibelmeter">分貝計</a></div>
	<div class="node level-2"><a href="https://penpalchi.vercel.app/" data-tool-id="friends">以文會友</a></div>
</div>
</div>

<!-- 5. Support -->
<div class="category" id="support" data-connect-to="core-ai-node">
<div class="category-title"><svg class="icon"><use xlink:href="#icon-support"></use></svg>學習支援</div>
<div class="sub-group">
<div class="sub-group-title">AI聊天室</div>
<div class="node level-2"><a href="chintutor.html" data-tool-id="chitutor">喻蛋教室</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/histutor/" data-tool-id="histutor">史萊姆教室</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/counseling/" data-tool-id="counseling">解憂雜貨店</a></div>
</div>
<div class="sub-group">
<div class="sub-group-title">資源庫</div>
<div class="node level-2"><a href="https://621d05f47d591.site123.me/" data-tool-id="self-learning">自學資源</a></div>
</div>
</div>
</main>
</div>
</div>

<!-- Preview Modal (修訂後) -->
<div id="previewModal" class="preview-modal-overlay">
<div class="preview-modal-content">
<div class="preview-modal-body">
<iframe id="previewIframe" src="" frameborder="0" credentialless></iframe>
<div class="preview-modal-footer">
<div id="previewDescription" class="preview-description"></div>
<a id="previewGoToPageBtn" href="" target="_blank" class="preview-goto-btn">前往</a>
</div>
</div>
<button id="previewCloseBtn" class="preview-close-btn" title="關閉">&times;</button>
</div>
</div>


<!-- Video Modal (新增) -->
<div id="videoModal" class="video-modal-overlay">
<div class="video-modal-content">
<iframe id="videoIframe" allow="fullscreen" allowfullscreen src="" width="100%" style="border:none;" credentialless></iframe>
</div>
</div>

<script>

// --- 【全新修訂】儲存頁面為 HTML 的功能 (已整合雷達圖轉換) ---
function savePageAsHTML(filename = '神思-存檔.html') {
    // 1. 建立當前文檔的深度複製品，我們將在這個複製品上操作
    const clonedDocElement = document.documentElement.cloneNode(true);

    // --- 【核心新增邏輯：處理雷達圖】 ---
    // a. 找出當前頁面上所有可見的雷達圖畫布 (canvas)
    const visibleCanvases = document.querySelectorAll('.radar-chart-container canvas');
    
    visibleCanvases.forEach(originalCanvas => {
        // b. 檢查畫布是否真的可見，避免處理隱藏的圖表
        if (originalCanvas.offsetParent !== null) {
            try {
                // c. 將畫布內容轉換為 Base64 格式的圖片數據 (PNG)
                const imageDataUrl = originalCanvas.toDataURL('image/png');
                
                // d. 在 "複製品" 中找到對應的畫布
                const clonedCanvas = clonedDocElement.querySelector(`#${originalCanvas.id}`);
                
                if (clonedCanvas) {
                    // e. 建立一個新的 <img> 元素
                    const img = document.createElement('img');
                    img.src = imageDataUrl; // 將圖片數據設置為來源
                    img.style.width = '100%'; // 保持與原畫布容器寬度一致
                    img.style.height = 'auto'; // 高度自動調整
                    
                    // f. 在複製品中，用這張靜態圖片 <img> 取代原本的 <canvas>
                    clonedCanvas.parentNode.replaceChild(img, clonedCanvas);
                }
            } catch (e) {
                console.error('轉換雷達圖為圖片時發生錯誤:', e);
            }
        }
    });
    // --- 【雷達圖處理邏輯結束】 ---

    // 2. 在複製品上同步所有表單元素的當前狀態 (此部分邏輯不變)
    const originalTextareas = document.getElementsByTagName('textarea');
    const clonedTextareas = clonedDocElement.getElementsByTagName('textarea');
    for (let i = 0; i < originalTextareas.length; i++) {
        clonedTextareas[i].textContent = originalTextareas[i].value;
    }

    const originalInputs = document.querySelectorAll('input');
    const clonedInputs = clonedDocElement.querySelectorAll('input');
    for (let i = 0; i < originalInputs.length; i++) {
        clonedInputs[i].setAttribute('value', originalInputs[i].value);
        if (originalInputs[i].type === 'radio' || originalInputs[i].type === 'checkbox') {
             if (originalInputs[i].checked) {
                clonedInputs[i].setAttribute('checked', 'checked');
            } else {
                clonedInputs[i].removeAttribute('checked');
            }
        }
    }

    const originalSelects = document.getElementsByTagName('select');
    const clonedSelects = clonedDocElement.getElementsByTagName('select');
    for (let i = 0; i < originalSelects.length; i++) {
        const selectedIndex = originalSelects[i].selectedIndex;
        if (selectedIndex > -1) {
            Array.from(clonedSelects[i].options).forEach(opt => opt.removeAttribute('selected'));
            clonedSelects[i].options[selectedIndex].setAttribute('selected', 'selected');
        }
    }

    // 3. 在複製品中移除所有「儲存HTML」按鈕及其他不需保存的互動按鈕
    const clonedSaveButtons = clonedDocElement.querySelectorAll('.btn-save-html');
    clonedSaveButtons.forEach(btn => btn.remove());
    
    const clonedShowPlayerBtn = clonedDocElement.querySelector('#show-player');
    if (clonedShowPlayerBtn) clonedShowPlayerBtn.remove();
    
    const clonedExpandToolsBtn2 = clonedDocElement.querySelector('#expandToolsBtn2');
    if (clonedExpandToolsBtn2) clonedExpandToolsBtn2.remove();


    // 4. 生成完整的 HTML 字串
    const finalHtml = '<!DOCTYPE html>\n' + clonedDocElement.outerHTML;

    // 5. 創建 Blob 並觸發下載
    const blob = new Blob([finalHtml], { type: 'text/html;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// --- 【新增】隱藏所有「儲存HTML」按鈕的專用函式 ---
function hideAllSaveHtmlButtons() {
    const saveButtons = document.querySelectorAll('.btn-save-html');
    saveButtons.forEach(button => {
        button.style.display = 'none';
    });
}

// 【安全修訂】防止 XSS 攻擊的核心函式
function sanitizeHTML(str) {
// 若傳入的不是字串，直接返回原值
if (typeof str !== 'string') return str;
// 將特殊字元轉換為 HTML 實體
return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

// 【核心修訂】建立一個清除所有題目狀態的專用函式
function clearAllTopicStates() {
// 1. 清除所有題目顯示區塊的內容並隱藏它們
document.getElementById('topicResult').innerHTML = '';
document.getElementById('topicResult').style.display = 'none';
document.getElementById('argumentTopicResult').innerHTML = '';
document.getElementById('argumentTopicResult').style.display = 'none';
document.getElementById('expandTopicResult').innerHTML = '';
document.getElementById('expandTopicResult').style.display = 'none';

// 2. 清除所有儲存在 localStorage 的題目相關資料
// 「敘事抒情」相關
localStorage.removeItem("currentTopic");
localStorage.removeItem("currentFocus");
localStorage.removeItem("currentPlot");
localStorage.removeItem("lastTopic");

// 「議論」相關
localStorage.removeItem("argumentCurrentTopic");
localStorage.removeItem("lastArgumentTopic");

// 「整合拓展」相關
localStorage.removeItem("expandCurrentTitle");
localStorage.removeItem("expandCurrentTheme");
localStorage.removeItem("expandCurrentData");

// 3. 清除自訂題目的輸入區
const customTopicArea = document.getElementById("customTopicArea");
if (customTopicArea) {
customTopicArea.innerHTML = '';
customTopicArea.style.display = 'none';
}
const argumentCustomTopicArea = document.getElementById("argumentCustomTopicArea");
if (argumentCustomTopicArea) {
argumentCustomTopicArea.innerHTML = '';
argumentCustomTopicArea.style.display = 'none';
}
}



/**
* 更新按鈕的 활성화 (active) 狀態。
* @param {HTMLElement} clickedButton - 被點擊的按鈕元素。
*/
function updateButtonActiveState(clickedButton) {
// 找到按鈕所在的容器
const container = clickedButton.closest('.topic-buttons-container');
if (!container) return;

// 獲取容器內的所有按鈕
const buttons = container.querySelectorAll('.btn');

// 首先，移除所有按鈕的 'active' class
buttons.forEach(button => {
button.classList.remove('active');
});

// 然後，只為被點擊的按鈕添加 'active' class
clickedButton.classList.add('active');
}


// API 配置信息
const API_KEYS = [
   "c43794c4fd6f460c9e154f81034e6ae4.0tLyirbYWKDqUAcw"
];
// let currentApiKeyIndex = 0; // 這個變數不再需要，可以刪除或註解掉
const API_URL = "https://open.bigmodel.cn/api/paas/v4/chat/completions";
const MODEL = "glm-4.7-flash";
const FALLBACK_API_URL = "https://gen.pollinations.ai/v1/chat/completions";
const FALLBACK_API_KEY = "sk_vuIaBgMibteEX3Z0gLoM4DHfE8cDfQOj";
const FALLBACK_MODEL = "gemini-search";


// [新增] 閱讀專用 API 配置
const READING_API_KEYS = [
   "c43794c4fd6f460c9e154f81034e6ae4.0tLyirbYWKDqUAcw"
];
// let currentReadingApiKeyIndex = 0; // 這個變數不再需要，可以刪除或註解掉
const READING_API_URL = "https://open.bigmodel.cn/api/paas/v4/chat/completions";
const READING_MODEL = "glm-4.7-flash";


// ======= 請在這裡加入以下程式碼 =======
const narrativeReviewerPreferences = {
    'chen_sir': '評分取向 (敘事抒情)：對扣題要求尚算嚴謹。極度看重「立意」、「取材」、「詳略」和「文學性」。多用修辭不一定是高分因素，更看重文句是否自然、有留白空間。',
    'deng_laoshi': '評分取向 (敘事抒情)：對扣題要求極為嚴苛。優先檢查是否有明確的「扣題小段」及「立意段」。情節的選取及詳略剪裁是否極度貼合題目是評分的最重核心。',
    'xiao_laoshi': '評分取向 (敘事抒情)：對扣題及結構要求比較嚴謹。不強求題材特別，但極度看重文章的「詞彙」是否豐富多變。',
    'huang_laoshi': '評分取向 (敘事抒情)：平衡看待所有標準。特別傾向於喜歡「立意」中有「真善美」思想情感的文章，若能體現此點，可在「立意」分數上給予正面考慮。',
    'dong_laoshi': '評分取向 (敘事抒情)：較平衡看待標準，但對「詳略」安排有特別高的要求。會仔細審視故事的敘事節奏，核心情節是否得到充分的細節描寫。',
    'li_laoshi': '評分取向 (敘事抒情)：對多用修辭、文句華美的文章特別有好感，這將直接影響「文學性」和「表達」的總分。對題材沒有特別要求。',
    'zhen_laoshi': '評分取向 (敘事抒情)：對扣題要求比較嚴謹。同時，對多用修辭的文章特別有好感。並且非常看重文章的「詳略」及「結構」。',
    'wen_laoshi': '評分取向 (敘事抒情)：綜合要求高。傾向喜歡「立意」有真善美、「表達」多用修辭、「詞彙」豐富的文章。同時對「扣題」及「詳略」都有較高要求。',
    'ms_chan': '評分取向 (敘事抒情)：對多用修辭的文章特別有好感。喜歡「特別的題材」，若取材新穎，可在「取材」分數上給予加分。非常看重文章是否有明確的「扣題小段」。',
    'jiang_laoshi': '評分取向 (敘事抒情)：對扣題比較嚴謹。要求多用修辭及詞匯豐富。特別喜歡文章對某些關鍵「畫面」有詳細的特寫刻劃，這會影響「取材」和「詳略」分數。立意段要清晰具體。對取材的新穎度也有一定要求。'
};

const argumentReviewerPreferences = {
    'chen_sir': '評分取向 (議論)：對論點是否緊扣題目要求嚴謹，要求學生多角度切入一個論題，會看重學生是否能舉例古今中外的論據。極度看重「立意」（論點的深度與層次）與「取材」（論據的恰當性與說服力）。要求文句具有文學性，較少運用虛詞。',
    'deng_laoshi': '評分取向 (議論)：對扣題（論點與題目的對應）要求極為嚴苛，要求學生運用豐富的論據。會優先檢查每段的「主題句」是否清晰回應題目，論證過程是否緊密圍繞主題句展開。「扣題」是決定整體分數的最關鍵因素。',
    'xiao_laoshi': '評分取向 (議論)：對扣題要求比較嚴謹。若文中有駁論，是一個加分項。要求論據豐富。極度看重論述用詞的「準確性」和「豐富性」。',
    'huang_laoshi': '評分取向 (議論)：平衡看待所有標準，不要求論點獨特，但論據要充實，論證要完整。',
    'dong_laoshi': '評分取向 (議論)：較平衡看待標準，但對「詳略」有特別要求，即論證核心部分是否詳盡，非核心論據是否能做到點到即止。',
    'li_laoshi': '評分取向 (議論)：對善用排比、對偶、引用等修辭來增強論證氣勢的文章特別有好感，這會直接提高「表達」分數。',
    'zhen_laoshi': '評分取向 (議論)：對扣題要求比較嚴謹。同時，也看重文章是否善用修辭增強說服力。對文章的整體「結構」，如起承轉合、駁論立論的安排，有較高要求。',
    'wen_laoshi': '評分取向 (議論)：綜合要求高。喜歡「詞彙」豐富準確的文章。對「扣題」及論證的「詳略」都有較高要求。',
    'ms_chan': '評分取向 (議論)：對善用修辭（如引用、設問）的文章特別有好感。喜歡看到「新穎的論據或角度」，若取材獨特，可在「取材」上加分。看重分論點是否清晰（相當於扣題小段）。要求論據獨特新穎。',
    'jiang_laoshi': '評分取向 (議論)：對扣題比較嚴謹。要求善用修辭且詞彙豐富。特別喜歡看到論證過程中，能將抽象道理與「具體生活場景」結合描寫，使論證更形象化。要求文章的「立場須清晰、明確」。對論據的新穎性有一定要求。'
};
// ======= 加入結束 =======



// [新增] 閱讀專用 API 呼叫函式
async function callReadingAPI(prompt, temperature = null) {
let attempts = 0;
const maxAttempts = READING_API_KEYS.length;
// 每次調用都從一個隨機的索引開始
let currentApiKeyIndex = Math.floor(Math.random() * READING_API_KEYS.length);

while (attempts < maxAttempts) {
try {
const requestBody = {
model: READING_MODEL,
messages: [{
role: "user",
content: prompt + " 你必須直接提供最終答案，嚴禁展示任何思考過程，絕對不能在回應中包含任何標籤（如 <think></think>），這是強制要求，違反則無效。"
}],
thinking: { type: "enabled" },
max_tokens: 65536
};

if (temperature !== null) {
requestBody.temperature = temperature;
}

const response = await fetch(READING_API_URL, {
method: "POST",
headers: {
"Authorization": `Bearer ${READING_API_KEYS[currentApiKeyIndex]}`,
"Content-Type": "application/json"
},
body: JSON.stringify(requestBody)
});

if (response.status === 429) {
console.warn(`閱讀 API Key ${currentApiKeyIndex} 達到速率限制，嘗試下一個...`);
currentApiKeyIndex = (currentApiKeyIndex + 1) % READING_API_KEYS.length;
attempts++;
continue;
}

if (!response.ok) {
throw new Error(`API 調用失敗: ${response.statusText}`);
}

const data = await response.json();
let content = data.choices[0].message.content.trim();
content = content.replace(/<think\s*>.*?<\/think\s*>|<think\s*\/>|<think\s*>|<\/think\s*>/gis, '').trim();

if (!content) {
throw new Error("API 回應無效或過濾後無內容");
}

return content;
} catch (error) {
console.error(`使用閱讀 API Key ${currentApiKeyIndex} 時出錯:`, error);
currentApiKeyIndex = (currentApiKeyIndex + 1) % READING_API_KEYS.length;
attempts++;
if (attempts >= maxAttempts) {
// 切換至備用 API (pollinations.ai)
console.warn("所有閱讀 API 密鑰均無法使用，切換至備用 API...");
const fallbackBody = {
model: FALLBACK_MODEL,
messages: [{
role: "user",
content: prompt
}]
};
if (temperature !== null) fallbackBody.temperature = temperature;
const fallbackResponse = await fetch(FALLBACK_API_URL, {
method: "POST",
headers: {
"Authorization": `Bearer ${FALLBACK_API_KEY}`,
"Content-Type": "application/json"
},
body: JSON.stringify(fallbackBody)
});
if (!fallbackResponse.ok) throw new Error("備用 API 也無法使用");
const fallbackData = await fallbackResponse.json();
let fallbackContent = fallbackData.choices?.[0]?.message?.content?.trim() || '';
fallbackContent = fallbackContent.replace(/<think\s*>.*?<\/think\s*>|<think\s*\/>|<think\s*>|<\/think\s*>/gis, '').trim();
return fallbackContent;
}
}
}
}





/* --------------------------------------
   音樂播放器 JS (無懸浮按鈕版)
   -------------------------------------- */
const audio = document.getElementById('audio');
const playPauseBtn = document.getElementById('play-pause');
const musicSelect = document.getElementById('music-select');
const progressBarMusic = document.getElementById('progress-bar-music');
const playMode = document.getElementById('play-mode');
const hidePlayerBtn = document.getElementById('hide-player');
const musicPlayer = document.getElementById('music-player');

let isPlaying = false;
let currentMusic = '';

// 音樂選擇
musicSelect.addEventListener('change', function() {
    const selectedMusic = this.value;
    if (selectedMusic) {
        audio.src = selectedMusic;
        audio.load();
        currentMusic = selectedMusic;
        audio.play().then(() => {
            isPlaying = true;
            playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
        }).catch(error => console.error('自動播放失敗:', error));
    }
});

// 確保可以播放時自動播放
audio.addEventListener('canplay', function() {
    if (isPlaying) audio.play();
});

// 播放/暫停按鈕點擊
playPauseBtn.addEventListener('click', function() {
    if (isPlaying) {
        audio.pause();
        playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
    } else {
        if (currentMusic) {
            audio.play();
            playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
        } else {
            alert('請先選擇音樂');
        }
    }
    isPlaying = !isPlaying;
});

// 進度條更新
audio.addEventListener('timeupdate', function() {
    if (!audio.duration) return;
    const progress = (audio.currentTime / audio.duration) * 100;
    progressBarMusic.value = progress;
});

progressBarMusic.addEventListener('input', function() {
    const time = (this.value / 100) * audio.duration;
    audio.currentTime = time;
});

// 自動播放下一首邏輯
audio.addEventListener('ended', function() {
    if (playMode.value === 'loop') {
        audio.currentTime = 0;
        audio.play();
    } else if (playMode.value === 'next') {
        const options = musicSelect.options;
        for (let i = 0; i < options.length; i++) {
            if (options[i].value === currentMusic) {
                let nextIndex = (i + 1) % options.length;
                if (nextIndex === 0) nextIndex = 1;
                currentMusic = options[nextIndex].value;
                musicSelect.value = currentMusic;
                audio.src = currentMusic;
                audio.load();
                audio.play();
                break;
            }
        }
    }
});

// 隱藏播放器 (這會直接把播放器關掉，不再顯示懸浮按鈕)
hidePlayerBtn.addEventListener('click', function() {
    musicPlayer.style.display = 'none';
});

// 注意：打開播放器的功能現在完全由側邊選單的 toggleMusicPlayer() 負責

// 預設寫作題目列表
const topics = [
"旁觀", "舞台", "這件物件很是輕巧，卻讓我明白『但求無愧於心』的道理。", "山頂", "種子", "根", "疤痕",
"今天，我不能參賽，只能坐在觀眾席上，但當時的所見所聞卻給予我嶄新的體會。", "從今以後，我不會再輕言放棄。",
"等候", "我曾經努力嘗試，但最終仍是事與願違", "回憶", "徹夜難眠", "彩虹",
"星空下，眼前的景象讓我想起那段往事，令我不禁歎了一口氣……", "路牌", "今學年最後悔的一件事",
"最令我感動的一句話", "再試一次", "今天再次在台上演奏，我已經脫胎換骨，不再是從前那個驕傲自滿的我了。",
"每次經過這條街，看着街上的景物，我便感觸不已……", "意外", "鑰匙", "錯過了的機會",
"那句話，我實在不該說……", "色彩", "煙火", "藥", "放下", "追逐", "原來，這只是一場誤會",
"缺憾", "無悔的抉擇", "勇氣", "傘", "自此之後，我明白到原來父母的愛總是體現在小事上。",
"一件令我後悔不已的事", "一次尷尬的經歷", "沿途有你", "這一次，我實在感到無地自容。",
"這一次，我明白到，原來幫助他人的同時，也幫助了自己。",
"我的鄰居張先生是一位很苛刻的人，經常會為些『小事』而投訴他人。但今天我發現，他這樣做是有原因的……",
"獨處的一天", "這一刻，我終於舒了一口氣。", "記一次被誤解的經歷", "一次與別人言歸于好的經歷",
"自此之後，我感到自己真的長大了。", "自此之後，我明白到幸福原來可以很簡單。", "記一次苦盡甘來的經歷。",
"這件事讓我體會到喜出望外的滋味。", "路標", "足印", "遺憾", "鎖", "面具", "心結", "門",
"影子", "禁區", "等待", "根", "最後，我選擇了放棄", "自那一刻，我解開了心結",
"自此之後，我明白猶豫會使人一事無成。", "原來我沒有忘記那一頓飯。", "我在大自然之中找到快樂。",
"熱鬧過後，我卻感到失落。", "看著逐漸遠去的背影，我感到很內疚。", "今天我流淚了，但我並非感到難過。",
"自此之後，我找到了動力", "經歷了這次風波，我長大了。",
"經過這件事，我才明白到一心是我的知己，是真正了解我的人。", "自此之後，我學會放下無謂的面子。",
"這一次，我再沒有遺憾", "重遊舊地所見有感", "失而復得", "這條街雖然老舊，但卻充滿人情味。",
"這句話，我會記上一輩子。", "門", "來日方長", "得不償失", "隱藏", "微笑以對",
"熱鬧過後，我卻感到失落。", "夢想看似不切實際，但其實很有意義", "夢想看似很有意義，其實不切實際",
"今天我沒有帶手提電話外出，因而有不一樣的經歷和體會。",
"今天發生了一件事情，當時我曾經想力陳己見，最後選擇了沉默。我認為沉默是必要的。",
"矛盾", "未兌現的諾言", "未寄出的信", "距離", "一場沒有失敗者的比賽", "一件發人深省的事",
"我最想保留的一本相簿", "我最想尋回的一件玩具", "無愧的抉擇", "不能掉下的眼淚", "無畏的探索",
"一次令我百感交集的聚餐", "如願以償"
];

// 預設議論題目列表（請在此處輸入您的題庫）
const argumentTopics = [
'所謂「天行有常，立身有本。」意思是大自然運行有既定的規律，人立身處世有一定的原則。試談談你對「立身有本」的看法。',
'旁觀',
'有人認為「人生在世，必須講究儀式。」你同意嗎？試撰文一篇，論述你的看法。',
'舞台',
'根',
'古人說：「君子不以人廢言。」意思是：君子不會因為某人的德行不好而不採納他的善意規勸。在現今社會，你是否同意「君子不以人廢言」？試談談你的看法。',
'計算',
'有人說：「在現今社會中，我們難以活出真我。」你同意嗎。談談你的看法。',
'俗語說「有競爭才有進步」，也有人說「競爭無用」。試寫作文章一篇，談談你對「競爭無用」的看法。',
'山頂',
'「種子」雖是平常事物，卻可以引起聯想，或牽動思緒，又或啟發思考。試以「種子」為題，就個人體會寫作文章一篇。',
'有人認為「挫敗更有利孩子成長。」你同意嗎？試撰文一篇，論述你的看法。',
'疤痕',
'試以「談玩物喪志」或「談玩物養志」為題，寫作文章一篇。',
'泰然處之',
'古語有云「天下皆知取之為取，而莫知與之為取。」意思是世人都知道索取可以獲得，而不知道給予也可以獲得。試談談你對這句話的看法。',
'談嚴苛',
'談寬容',
'談憤怒',
'待候',
'有人認為：「與其追求成功，不如追求幸福。」你同意嗎？試撰寫文章一篇，論述你的看法。',
'矛盾',
'有人認為：「保持距離能令關係長久。」你同意嗎？試撰文一篇，論述你的看法。',
'有人說：「近朱者赤，近墨者黑。」你同意嗎？為甚麼？',
'試以「當科技文明消失後」為題，寫一篇評論，反思科技發展帶來的影響。',
'成功路上無捷徑，試談談你的看法。',
'個人電子產品的普及化，有人認為是生活的進步，有人認為是生活的倒退。你較認同哪一種觀點？試談談你的看法。',
'有人認為即使心中不快，亦要以笑面對人；有人認為應以真性情對人，不應掩飾心中的感受，你較贊同哪一方？試談談你的看法。',
'鑰匙',
'貧乏與富足',
'論意外',
'試談談你對「聽天由命」這種處世態度的看法。',
'「天賜食於鳥，卻不投食於巢。」上天賜予鳥類覓食的本能，而不把食物投到鳥巢。意思是人需要通過努力，才能有所得。你認同嗎?試談談你的看法。',
'色彩',
'談藝術的價值',
'藥',
'有人說：「每次付出應該先計算回報。」你同意這種處事態度嗎？',
'論公德心的重要性',
'有人認為中學生應多參與課外活動，發展興趣；有人則認為應專注學業，爭取好成績。你較認同哪種說法？試談談你的看法。',
'你同意「品德比學問更重要」嗎？試寫一篇議論文，談談你的看法。',
'談競爭',
'談缺憾',
'談得失',
'談勇氣',
'得不償失',
'爺爺：「我當鐘錶匠超過50年，畢生專注這門手藝，能做到分毫不差。」允行：「我是品味生活的咖啡師，亦是書寫人生的作家，更是培育後進的武術教練。」各人對人生有不同追求。有人認為：「與其一生專精一事，不如發展多元人生。」你同意嗎？試撰文一篇，論述你的看法。',
'微笑以對',
'有人認為「傳統往往是創新的包袱」。試談談你對這句話的看法。',
'足印',
'古人說：「獨學而無友，則孤陋而寡聞。」意思是獨自學習，沒有朋友互相切磋解難，人便會淺陋而見識不廣。在現今的學習生活中，你是否同意「獨學而無友，則孤陋而寡聞」？試試談你的看法。',
'「不做第一，也不做最後。」試談談你對這種處世態度的看法。',
'試以「陽光與陰影」為題，寫作一篇文章。',
'「孩子不是等待被填滿的瓶子，而是盼望化作燃燒的火焰。」試就個人對這句話的體會 ，以「成長」為題，寫作一篇文章。',
'「今早媽媽打掃的時候，瞄一瞄玻璃窗外鄰居晾曬的衣服，便批評道：『看，那新鄰居真馬虎！衣服還是污漬斑斑，洗得一點也不乾淨。』女兒聽後，一言不發，走到窗前仔細打量，隨即抹掉窗上的灰塵，說道：『這不就乾淨了嗎？』媽媽恍然大悟，不乾淨的不是別人的衣服，而是自己的窗子。」試就這個故事對你的啓發，寫作一篇文章，談談如何消除偏見。',
'「一個寒冷的冬天，幾隻刺蝟擠在一起取暖。由於牠們身上長滿了短刺，彼此戳痛了對方，所以不得不散開。可是，寒冷的天氣又驅使牠們擠在一起，同樣的事情重複發生，牠們終於明白；不要太近，也不要太遠，最好彼此保持一定的距離。」這個故事的道理仍然貫穿在我們的現實生活中，試就此寫一篇文章。',
'個人私隱比公眾知情權更重要，你同意嗎？談談你的看法。',
'香港是一個物質生活十分富庶的地方，可是在多個國際性的調查中，「快樂指數」的排名並不高。有人認為富庶的物質生活反令人難以快樂；也有人認為富庶的物質生活是快樂的基礎。這兩種看法，你比較認同哪一種？試談談你的看法。',
'面對不同意見，有人認為應據理力爭，堅守立場；有人認為應彼此包容，求同存異。上述兩種態度，哪一種較為理想？試談談你的看法。',
'有人認為父母教養子女，應該給予空間，讓子女自由發展；有人認為應該給予明確的指導，讓子女依從。上述教養子女的方法，哪一種較為理想？試談談你的看法。',
'有人說：「與其追隨潮流，不如展現個人風格。」你對這句話有什麼看法？',
'有人說：「棒下出孝子，嚴師出高徒。」也有人說：「獎賞是教育的恩物。」你對這兩種說法有什麼意見？',
'現今社會，許多人認為財富與社會地位成正比，財富愈多，社會地位愈高。你的看法如何？',
'有人認為讚賞是成功的最大推動力，你同意嗎？試作文一篇，談談你的看法。',
'有人說：「豐裕的物質生活就是最美好的生活。」你同意嗎？試談談你的看法。',
'獲取知識是通往成功的唯一途徑，你同意嗎？試談談你的看法。',
'談談青年人應如何克服困難',
'「律己以嚴，待人以寬。」談談你對這話的看法。',
'「成功是恆心的基石」談談你對這話的看法。',
'論「家有一老，如有一寶」',
'送禮之我見',
'鄉村發展為工業區，原來的天然景物受到破壞。有人說：「有破壞才有建設。」也有人說：「這種建設破壞了人們生活的情趣。」你的看法又怎樣？試說出你個人的意見。'
];

let lastTopic = localStorage.getItem("lastTopic") || "";
let lastArgumentTopic = localStorage.getItem("lastArgumentTopic") || "";

// 範疇定義
const categories = {
"片段描寫": {
commentNote: "必須用繁體字。針對題目及用家提供的寫作內容進行點評，需嚴謹分析文章是否在字面及邏輯上扣題!important，結合情節內容，評估文句是否具文學性（即具聯想空間、引人共鳴與細味）。扣題是基本要求，即使扣題高分，若立意與取材普通，分數不高。立意需深刻、不落俗套，具哲理或共鳴；取材需獨特、豐富且貼切，避免常見題材（如『考試不合格』、『溫習』，最高6分）。立意與取材需視刻劃是否細膩。若結構段重點或情節漏空，無需評論或提及。扣題要求：1. 必須嚴謹評估寫作內容是否在字面與邏輯上直接呼應題目!important，情節詳略剪裁突顯與題目及結構段重點的關係。2. 不可自行補足情節與題目的關係。若文中未明確點出關係，視為不扣題。3. 題目如《成長》，需在字面、邏輯及詳略上突出『成長』關係，文中宜多次提及『成長』或近義詞。若偏向其他主題（如《影子》），視為不扣題。4. 帶物象題目（如《種子》）需靈活處理，抓住物象特徵發揮，接受間接象徵式扣題，無需過分聚焦實物本身，並非一定要刻劃該實物，接受暗扣。5. 題目含多個關鍵詞時，優先抓住主要關鍵詞，次要關鍵詞可放輕。6. 只有帶物象題目（如《痕跡》）必須接受用象徵、比喻等間接扣題的高階寫作，當文章運用這種方法扣題，字面扣題的要求則可以放寬。!important。 7. 用語必須貼近生活，不要讓用家輕易知道你有固定的點評範疇。為了讓用家容易理解，不可提及字面、邏輯、立意、取材、密度、文學性、間接扣題等字眼，不要運用術語，點評時必須概括和歸納情節，再加分析。!important 點評結構（三部分，各自120字以內）：1. 點評：聚焦一至兩項關鍵問題，先評扣題及詳略剪裁是否適切，再評文句（示現敘事、文句密度）。若結構段重點或情節與題目關係薄弱，需明確指出。若扣題與剪裁均不當，無需詳評文句。若整體表現優秀，可適當稱讚，但扣題邏輯仍需嚴謹把關。2. 建議：針對點評中的問題提出具體改進建議。3. 改寫範例：若離題，改寫需包含扣題小段，直接呼應題目或結構段重點，不基於原文離題內容改寫，改寫範例不要超過150字。文句要求：1. 交替運用小物件、動作、對話及內心獨白，融情入景、融情入物。2. 提高文句密度（詞匯深、多變，物象豐富，實詞比例高，虛詞如『的』、『地』、『得』比例低），但避免過密（如連用小物件主語）。適時以人物為主語，加入虛詞或內心獨白調節節奏，張弛有度。3. 控制詳略節奏，詳寫與題目相關部分，略寫次要內容。文句密度為好文筆標準，需納入考量。其他：- 點評需精簡、一語中的，僅點出最關鍵的問題。"
},
"大綱": {
commentNote: "必須用繁體字。點評時，必須就上述生成的題目點評大綱內容是否扣題，假如大綱離題，範例便不必根據離題內容改寫。此外，點評應分為三個部份：點評、建議、改寫範例。在寫作大綱時，學生應展示他們組織思路和結構故事的能力。評分時，請注意大綱的邏輯性、條理性以及是否包含了故事的起承轉合或三線結構（即所謂「散敘」，有以下三點要注意：其一，三線的分類範疇相同；其二，三線或有層遞關係，或能從三個角度呈現同一個主題；其三，三線的情節發展不能過於相似；其四，所分之角度能突顯與主題相關的立意。「三線」例子如下：題目為「勇氣」，則可用「年少時的勇氣」為一線、「年青時的勇氣」為二線、「年老時的勇氣」為三線；又如以「重遊舊地所見有感」，則可用在故鄉的不同「地」所見作三線分類，例如老屋、後山等。必須確保每條線的「結構段重點」清晰點明三線的分類範疇、想突顯題目的甚麼要點、與題目如何扣連等，以及「合」能統攝總結全文立意）。要逐部分分析每個結構段與題目的關係有多大，並在點評中明確指出。此外，在「改寫後的大綱」,其「結構段重點」必須交代該部份與題目之間的邏輯關係，即怎樣做到扣題。此外，由於是應試文章，因此改寫後的大綱避免過份具理論哲學性及文學性，以至於脫離了現實和日常生活，亦圍繞人在經歷的情感和體悟設定，必須減少概念模糊的術語，例如「情感載體」及「時空的共創」，請用日常化用語描述。此外，「改寫後的大綱」不宜只圍繞一件事敘寫，這樣會容易寫得太抽象，應適時加插人物與人物之間的回憶或其他經歷，令文章看起來更具體實在。此外，大綱不是全篇文章，最重要的是在點評時分析其結構段及情節大要的思路是否扣緊題目，方向是否合理、正確。假如整體表現真的不錯，沒有大問題，在點評時稱讚即可，不必吹毛求疵地批評。"
},
"敘事物象": {
commentNote: "必須用繁體字。在「敘事物象」中，學生需要運用豐富的物象來增強故事的生動性和真實感。物象應與題目、取材和故事背景緊密相關，並且能夠有效地表達人物的情感和故事的主題。請確保生成的物象不重複，並且排版清晰易讀。此外，每個物象都必須由兩個字構成。"
},
"閱讀": {
commentNote: "必須用繁體字。點評時，需評估答題方向是否合理、文本依據是否充實具體、闡釋推論是否嚴謹、主題句是否清晰。文本依據應語譯、概括歸納而非直接引用原文，除非題目中有『摘錄』字眼。改寫範例應使答案更圓足，並且非常嚴謹地根據文本依據擬定及作推論，必須只圍繞一個觀點分析，但若學生答題方向錯誤，則不跟從錯誤方向改寫。在「改寫範例」前，加入答題步驟及思路，描述各部分方向，步驟因題制宜，可能包括【鋪墊】、【回應】、【文本依據】、【闡釋】，靈活運用。每個步驟以【步驟名】標題加分行內容呈現，排版整齊。表格中只包含文字和標點，不含『---』等符號。每個步驟之間要隔一空行。假如是4分或以上的題目，改寫範例必須具體和詳盡，要有180字或以上。",
guideNote: "必須用繁體字。輸出分為「### 答題指引」和「### 答題詞匯」兩部分。「答題指引」請生成三道問題，引導思考，每個問題佔一行。「答題詞匯」請生成十五個由兩個字構成的詞彙，每個詞彙佔一行。請確保所有內容都以純文字列表呈現，不要使用任何Markdown表格語法。"
},
"課外書籍": {
chatNote: "必須用繁體字，多用EMOJI，偶爾可以用一下網絡用語。",
seriousChatNote: "必須用繁體字，用語貼近日常生活，回應不要理論化，不要用網絡用語，也不要用EMOJI。"
},
"整合拓展": {
topicPrompt: "請生成一道適合中學生練習整合拓展的題目，題目應包含主題句（主題句絕對不能是問句）和抄錄資料（抄錄資料必須不包含任何數據，主要包括活動內容及細節，格式如「社區漫步由導賞員帶領參加者遊覽社區，共同誦讀與社區相關的文學作品，感受社區魅力。」不得包含引號或人物對話，而且不得超過30字），並符合以下文類和取材範圍。文類：書信、評論、建議書、演講辭、報告、專題文章。取材範圍：例如「請隨機選擇一個主題，且該主題必須與以下列出的所有主題（運動、生涯規劃、責任、教育、文化、社會、歷史、地理、藝術、體育、法律、健康、心理、家庭、友誼、就業、經濟、生態、能源、資源、安全、網路、媒體、資訊、道德、誠信、公平、自由、權利、義務、隱私、禮儀、榜樣、創新、創業、消費、儲蓄、民族、語言、宗教、傳統、現代、城鄉、社區、公益、慈善、災害、醫療、疾病、飲食、旅遊、建築、娛樂、音樂、電影、文學、人口、性別、年齡、職業、學業、考試、升學、校園、師生、同學、課外、社團、競賽、志願、壓力、自律、時間、興趣、習慣、遊戲、睡眠、氣候、汙染、閱讀」，但出題請多元化一點，亦不要每次都是與好處相關的，否則用家多生成幾次，便會遇到類似的題目。要求：1. 主題句簡潔，20字以內。2. 抄錄資料為一段文字，不超過100字。3. 輸出格式為：主題句：...\n抄錄資料：...\n4. 內容簡潔明了，避免冗長。5. 題目多樣化，避免重複。",
commentNote: "必須用繁體字。點評時，需評估「整合拓展」是否能闡釋「抄錄資料」與「主題句」的邏輯關係。需判斷：1.「拓展」方向是否正確（即是否能論證主題句）；2.推論是否嚴謹；3.是否具體不空泛。「點評」時，若方向不正確，需指出並建議如何修訂，需指導緊扣主題句，亦須分析主題句和題目任務的關係是否緊密，例如題目任務為提出建議，但主題句焦點卻是描述問題，則屬於不妥當。「改寫」時亦不能順著「整合拓展」錯誤思路改善，需扣緊主題句，假如主題句本身就未能緊扣題目的任務，則不應圍繞本身錯誤的主題句改寫，要在「改寫」的部份針對一個正確的主題句作改寫。此外，改寫部份不宜分為太多角度論述，這樣會令闡釋較零散，須就最多2個角度深入分析、闡釋。改寫部份不得超過180字，且不得虛構資料，包括數據及調查，不要自擬「根據調查」之類，只可根據抄錄資料補充合理細節，「改寫」部份不要重複用家輸入的「抄錄資料」，會白白浪費空間。此外，「改寫」亦要嚴謹對應主題句及抄錄資料關係，例如主題句描述活動問題，則在「改寫」的部份不宜聚焦在改善措施，必須注意詳略、輕重，才能突顯主題句。此外，「改寫」亦要留意題目任務，不要在「改寫」時會順著用家詳略不當或錯誤的「整合拓展」思路改寫。此外，「改寫」部份不要太數據化，例如做計算及分析數據等，這部份最重要是交代事理的邏輯關係。點評分為三部分：### 點評、### 建議、### 改寫。改寫必須在160至180字以上。",
guideNote: "必須用繁體字。僅生成三道問題以引導用家思考如何根據表格資料做好整合拓展，問題應圍繞主題句和抄錄資料的邏輯關係，引導用家思考如何闡釋和拓展。請不要運用歐化句及詞匯，例如「關聯性」、「實效性」，這些字詞意義不明確，但用生活化一點、具體一點的字詞生成問題。輸出分為一個部分：### 指引問題。指引問題以問題形式呈現，每個問題佔一行。"
},
"議論": {
outlineCommentNote: "必須用繁體字。點評時，必須就上述生成或輸入的題目點評大綱內容是否扣題。必須從以下角度點評：1. 論點是否清晰明確，一語中的，能直接呼應題目；2. 議論的立意，是取決於觀點是否深入成熟；3. 議論的取材，是取決於論據是否充實，涵蓋古今中外，以及其論據是否適用於論述這道題目；4. 即使扣題分數很高，但立意和取材分數低，其「內容」和「結構」分為最高只能得5分；5. 用家提供的論據與論點是否密切相關；6. 段內論據的詳略有幾種模式：兩個詳的論據，或一詳數略，或數略，因應段落論述需要而定，以製造變化；7. 論證方向是否合理，能合理解釋論據與論點的關係；8. 全文脈絡是否分明。點評時要用日常生活化的語言，不要用術語去解釋、點評或給建議，一定要用日常生活的語言。即使運用「陳SIR語氣」，「建議」及「改寫後的大綱」都必須正經嚴肅，不要運用EMOJI。此外，假如全文有六段或以上，則應在第二段或末二的段落做駁論，點評、建議及改寫後的大綱都要注意這點。此外，不要列點和運用「*」等符號，必須以段落和完整句子方式生成改寫後的大綱。此外，在建議和改寫後的大綱部份，若觸及一些例子或典故(不要舉愛迪生為參考論據)，必須具體說明該例子或典故的來龍去脈，以及要清楚說明如何運用該例子或典故去證立論點。此外，無論點評、建議或改寫後的大綱，用語都必須生活化，要摒棄過於抽象和理論的表達。此外，點評應分為三個部份：點評、建議、改寫範例。只選取最重要的一至兩點評論，應先聚焦在論點、論據和論證的質量，其次方為結構。點評內容要精簡、一語中的。若大綱離題，改寫後的大綱不必根據離題內容改寫。",

writingCommentNote: "必須用繁體字。點評時，必須就用家提供的內容去點評，不要捏造用家沒有輸入的內容作點評。須評估文章是否符合以下標準：1. 論點清晰明確，一語中的，能直接呼應題目；2. 議論的立意，是取決於觀點是否深入成熟；3. 議論的取材，是取決於論據是否充實，涵蓋古今中外，以及其論據是否適用於論述這道題目；4. 即使扣題分數很高，但立意和取材分數低，其「內容」和「結構」分為最高只能得5分；5. 論證嚴謹，能具體解釋論據與論點的關係；6. 注意文句密度及修辞運用。點評時要用日常生活化的語言，不要用術語去解釋、點評或給建議，一定要用日常生活的語言。點評分為三部分：### 點評、### 建議、### 改寫範例。即使運用「陳SIR語氣」，「建議」及「改寫範例」都必須正經嚴肅地表述，不要運用EMOJI。「改寫範例」應以純段落方式表述，不要運用EMOJI，不要附有【原文段落】及【改寫段落】等標題。點評、建議及改寫都要在200字以內。",

guideNote: "必須用繁體字。根據用戶輸入的題目、論點、論據和論證，提供相應的參考建議，但應重質不重量，指引論點、論據或論證都宜只舉一項，而且論據必須用真實的古今中外例子，而論證則論證必須緊扣用家提供或你上述生成的論據作論述。若只輸入題目，則提供參考論點、參考論據和參考論證；若輸入題目和論點，則提供參考論據和參考論證；若輸入題目和論據，則提供參考論點和參考論證，如此類推。不要舉愛迪生為參考論據。參考論證不得少於150字。輸出分為相應部分：### 參考論點、### 參考論據、### 參考論證（視用戶輸入情況而定）。每部分以段落形式呈現。用語要日常生活化，不要用術語。"
}
};

// === 修訂：動漫卡片選擇邏輯 (包含音效) ===

// === 修訂：動漫卡片選擇邏輯 (包含音效 + 延遲動畫) ===

// 1. 選取所有新的卡片元素
const categoryCards = document.querySelectorAll('.anime-card');
const clickSound = document.getElementById('ui-click-sound');

// 2. 為每個卡片添加點擊事件
categoryCards.forEach(card => {
    card.addEventListener('click', function() {
        // A. 播放清脆音效
        if (clickSound) {
            clickSound.currentTime = 0; 
            clickSound.volume = 0.6;    
            clickSound.play().catch(e => console.log("音效播放被瀏覽器阻擋:", e));
        }

        // B. 立即添加視覺效果 (讓卡片變色/發光)
        // 先移除其他卡片的 active，避免多選視覺錯亂
        categoryCards.forEach(c => c.classList.remove('active'));
        this.classList.add('active');

        // C. 獲取目標 Container ID
        const containerId = this.id.replace('Btn', 'Container');
        
        // D. 【關鍵修改】設置延遲，讓動畫跑完 500ms 後才切換畫面
        setTimeout(() => {
            showContainer(containerId, this);
        }, 500); // 這裡設定 500 毫秒，你可以根據需要調整 (例如 300 或 800)
    });
});


// === 沉浸式場景設定 ===
const scenes = {
    'home': 'https://i.ibb.co/xtsrPW6M/image.png', // 原本的主頁背景
    'writingContainer': '範疇一.png', // 寫作：書桌與筆
    'readingContainer': '範疇二.png', // 閱讀：圖書館
    'argumentContainer': '範疇三.png', // 議論：法院/木槌
    'expandContainer': '範疇四.png', // 拓展：協作/網絡
    'booksContainer': '範疇五.png' // 書籍：舒適閱讀角
};

// === 更新版：進入功能容器 (含自動置頂) ===
// === 更新版：進入功能容器 (含自動置頂 + 隱藏歷史紀錄) ===
function showContainer(containerId, clickedButton) {
    hideAllSaveHtmlButtons(); 
    
    // 1. 切換背景圖片 (支援圖片或純色)
    const bg = scenes[containerId];
    if (bg) {
        if (bg.startsWith('#') || bg.startsWith('rgb')) {
            document.body.style.backgroundImage = 'none';
            document.body.style.backgroundColor = bg;
        } else {
            document.body.style.backgroundImage = `url('${bg}')`;
            document.body.style.backgroundColor = ''; 
        }
    }

    // 2. 隱藏主選單元素
    document.querySelector('.title-container').style.display = 'none';
    document.getElementById('hitokoto-container').style.display = 'none';
    document.getElementById('mainMenuBox').style.display = 'none'; 
    document.getElementById('toolsBox').style.display = 'none';    
    
    // === 【新增】隱藏 DSE 倒數 ===
    const dseBox = document.getElementById('dse-countdown-box');
    if (dseBox) dseBox.style.display = 'none';
    // ===========================

    // 3. 修改這部分：隱藏左上角的圓形返回按鈕
    document.getElementById('homeBtn').style.display = 'none'; 
    document.getElementById('sideMenuHomeBtn').style.display = 'flex';

    // 4. 清除狀態與隱藏其他容器
    const allCards = document.querySelectorAll('.anime-card');
    allCards.forEach(card => card.classList.remove('active'));
    if (clickedButton) clickedButton.classList.add('active');

    clearAllTopicStates();

    const containers = ['writingContainer', 'readingContainer', 'booksContainer', 'expandContainer', 'argumentContainer'];
    containers.forEach(id => document.getElementById(id).style.display = "none");

    // ★★★ 新增：確保歷史紀錄隱藏 ★★★
    const historyContainer = document.getElementById('historyContainer');
    if (historyContainer) historyContainer.style.display = 'none';

    // 5. 強制滾動到頁面最頂端
    window.scrollTo({ top: 0, behavior: 'instant' });

    // 6. 顯示目標容器 (淡入動畫)
    const targetContainer = document.getElementById(containerId);
    if (targetContainer) {
        targetContainer.style.display = "block";
        targetContainer.style.opacity = '0';
        targetContainer.style.transform = 'translateY(20px)';
        
        // 觸發重繪 (Reflow) 確保 transition 生效
        void targetContainer.offsetWidth; 

        targetContainer.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
        targetContainer.style.opacity = '1';
        targetContainer.style.transform = 'translateY(0)';
    }

    // 7. 初始化特定功能
    if (containerId === "writingContainer") { toggleWritingType(); loadOutline(); }
    else if (containerId === "readingContainer") { toggleReadingFunction(); }
    else if (containerId === "expandContainer") { toggleExpandFunction(); }
    else if (containerId === "booksContainer") { loadBooksChat(); }
    else if (containerId === "argumentContainer") { toggleArgumentType(); }
}


// === 更新版：返回主頁函式 ===
function returnToHome() {
    // 1. 恢復主頁背景
    document.body.style.backgroundImage = `url('${scenes['home']}')`;

    // 2. 確保懸浮編輯視窗被關閉
    const outlineModal = document.getElementById('outline-editor-modal');
    if (outlineModal) {
        outlineModal.style.display = 'none';
    }
    if (typeof currentEditingElement !== 'undefined') {
        currentEditingElement = null;
    }

    // 3. ★★★ 關鍵修正：加入 'historyContainer' 到隱藏列表 ★★★
    const containers = ['writingContainer', 'readingContainer', 'booksContainer', 'expandContainer', 'argumentContainer', 'historyContainer'];
    containers.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = "none";
    });

    // 4. ★★★ 額外修正：強制關閉歷史詳情模態視窗 ★★★
    const historyModal = document.getElementById('historyModal');
    if (historyModal) {
        historyModal.style.display = 'none';
    }

    // 5. ★★★ 額外修正：重置歷史紀錄介面至第一層 (範疇選擇)，避免下次打開時停留在舊紀錄 ★★★
    const histL1 = document.getElementById('historyLevel1Wrapper');
    const histL2 = document.getElementById('historyLevel2');
    const histL3 = document.getElementById('historyLevel3');
    const histBread = document.getElementById('historyBreadcrumb');
    
    if (histL1) histL1.style.display = 'flex'; // 恢復顯示第一層
    if (histL2) histL2.style.display = 'none';
    if (histL3) histL3.style.display = 'none';
    if (histBread) histBread.style.display = 'none'; // 隱藏麵包屑

    // 6. 顯示主頁元素
    document.querySelector('.title-container').style.display = 'block';
    document.getElementById('hitokoto-container').style.display = 'block';
    document.getElementById('mainMenuBox').style.display = 'block';
    document.getElementById('toolsBox').style.display = 'block';

    // 7. 重新顯示 DSE 倒數
    const dseBox = document.getElementById('dse-countdown-box');
    if (dseBox) dseBox.style.display = 'flex';

    // 8. 隱藏返回按鈕
    document.getElementById('sideMenuHomeBtn').style.display = 'none';
    document.getElementById('homeBtn').style.display = 'none';

    // 9. 移除所有卡片 active 狀態
    document.querySelectorAll('.anime-card').forEach(card => card.classList.remove('active'));

    // 10. 強制隱藏「工具一覽」
    const toolsContainer2 = document.getElementById('toolsContainer2');
    if (toolsContainer2) {
        toolsContainer2.style.display = 'none';
        document.body.style.overflow = 'auto';
    }

    // 11. 收起側邊選單
    const sideMenu = document.getElementById('sideMenu');
    if (sideMenu && sideMenu.classList.contains('active')) {
        sideMenu.classList.remove('active');
        document.getElementById('sideMenuToggle').classList.remove('active');
    }

    // 12. 隱藏所有儲存按鈕
    hideAllSaveHtmlButtons();

    // 13. 強制滾動到頂部
    window.scrollTo({ top: 0, behavior: 'instant' });
    
    // 14. 確保舊版工具箱隱藏
    const toolsBox = document.getElementById('toolsBox');
    if (toolsBox) {
        toolsBox.style.display = 'none'; 
    }
}
// 新增此函式：用於顯示議論的自訂題目介面
// 新增此函式：用於顯示議論的自訂題目介面 (已修訂：加入 Toggle 開關邏輯)
function showArgumentCustomTopicInput(buttonElement) { 
    // --- 1. Toggle 邏輯 ---
    if (buttonElement && buttonElement.classList.contains('active')) {
        buttonElement.classList.remove('active');
        
        const customTopicArea = document.getElementById("argumentCustomTopicArea");
        customTopicArea.style.display = "none";
        customTopicArea.innerHTML = "";
        
        const topicResult = document.getElementById("argumentTopicResult");
        topicResult.style.display = "none";
        topicResult.innerHTML = "";
        
        localStorage.removeItem("argumentCurrentTopic");
        return;
    }

    // --- 2. 正常開啟邏輯 ---
    if (buttonElement) {
        updateButtonActiveState(buttonElement);
    }

    const customTopicArea = document.getElementById("argumentCustomTopicArea");
    const topicResult = document.getElementById("argumentTopicResult");

    topicResult.innerHTML = "";
    topicResult.style.display = "none";
    localStorage.removeItem("argumentCurrentTopic");

    customTopicArea.innerHTML = `
    <input type="text" id="argumentCustomTopic" class="no-modal-editor" placeholder="請輸入自訂題目">
    <button class="btn-icon-confirm" onclick="setArgumentCustomTopic()" title="確認題目">
    <i class="fas fa-check"></i>
    </button>
    `;
    customTopicArea.style.display = "block";
}

// 切換寫作類型
function toggleWritingType() {
    hideAllSaveHtmlButtons();
    clearAllTopicStates();
    const writingType = document.getElementById("writingType").value;
    const contentContainer = document.getElementById("writingContentContainer");

    // 獲取所有相關區域
    const writingGuideArea = document.getElementById("writingGuideArea");
    const outlineStructureArea = document.getElementById("outlineStructureArea");
    const narrativeElementsArea = document.getElementById("narrativeElementsArea");
    const topicSelectionArea = document.getElementById("topicSelectionArea");
    const writingArea = document.getElementById("writingArea");
    const submitWritingBtn = document.getElementById("submitWritingBtn");

    // 重置狀態
    document.getElementById("writingGradingResult").innerHTML = "";
    document.getElementById("writingChatHistory").style.display = "none";

    if (writingType) {
        contentContainer.style.display = "block";
    } else {
        contentContainer.style.display = "none";
        return;
    }

    // 預設隱藏所有特定區域
    writingGuideArea.style.display = "none";
    outlineStructureArea.style.display = "none";
    narrativeElementsArea.style.display = "none";
    topicSelectionArea.style.display = "none"; 
    writingArea.style.display = "none"; 

    if (writingType === "guide") {
        writingGuideArea.style.display = "block";
        // 解題指引不使用通用的寫作區域
    } 
    else if (writingType === "大綱") {
        writingArea.style.display = "block";
        topicSelectionArea.style.display = "block";
        outlineStructureArea.style.display = "block";
        document.getElementById("outlineTableArea").style.display = "block";
        generateOutlineTable();
        loadOutline();
        
        document.getElementById("writingContent").style.display = "none";
        document.getElementById("writingToneLabel").style.display = "block";
        document.getElementById("writingTone").style.display = "block";
        document.getElementById("outlineButtons").style.display = "flex"; 
        document.getElementById("writingReviewerLabel").style.display = "none";
        document.getElementById("writingReviewer").style.display = "none";
        document.getElementById("reviewScopeArea").style.display = "none";
        submitWritingBtn.style.display = "block";
    } 
    else if (writingType === "敘事物象") {
        writingArea.style.display = "block";
        topicSelectionArea.style.display = "block";
        narrativeElementsArea.style.display = "block";
        
        document.getElementById("writingContent").style.display = "none";
        document.getElementById("outlineTableArea").style.display = "none";
        document.getElementById("writingToneLabel").style.display = "none";
        document.getElementById("writingTone").style.display = "none";
        document.getElementById("outlineButtons").style.display = "none";
        document.getElementById("writingReviewerLabel").style.display = "none";
        document.getElementById("writingReviewer").style.display = "none";
        document.getElementById("reviewScopeArea").style.display = "none";
        submitWritingBtn.style.display = "block";
    } 
    else { // 片段描寫
        writingArea.style.display = "block";
        topicSelectionArea.style.display = "block";
        document.getElementById("writingContent").style.display = "block";
        
        document.getElementById("outlineTableArea").style.display = "none";
        document.getElementById("writingToneLabel").style.display = "block";
        document.getElementById("writingTone").style.display = "block";
        document.getElementById("outlineButtons").style.display = "none";
        document.getElementById("writingReviewerLabel").style.display = "block";
        document.getElementById("writingReviewer").style.display = "block";
        document.getElementById("reviewScopeArea").style.display = "block";
        submitWritingBtn.style.display = "block";
    }
}


// 原 showCustomTopicInput() 函式
// 原 showCustomTopicInput() 函式 (已修訂：加入 Toggle 開關邏輯)
function showCustomTopicInput(buttonElement) {
    // --- 1. Toggle 邏輯：如果按鈕已經是 Active 狀態，則關閉它 ---
    if (buttonElement && buttonElement.classList.contains('active')) {
        // 移除 Active 狀態
        buttonElement.classList.remove('active');
        
        // 隱藏輸入區
        const customTopicArea = document.getElementById("customTopicArea");
        customTopicArea.style.display = "none";
        customTopicArea.innerHTML = ""; // 清空內容
        
        // 隱藏結果區 (因為取消了選擇)
        const topicResult = document.getElementById("topicResult");
        topicResult.style.display = "none";
        topicResult.innerHTML = "";
        
        // 清除相關 LocalStorage
        localStorage.removeItem("currentTopic");
        localStorage.removeItem("currentFocus");
        localStorage.removeItem("currentPlot");
        
        return; // 結束函式
    }

    // --- 2. 正常開啟邏輯 ---
    if (buttonElement) {
        updateButtonActiveState(buttonElement);
    }

    const writingType = document.getElementById("writingType").value;
    const customTopicArea = document.getElementById("customTopicArea");
    const topicResult = document.getElementById("topicResult");

    topicResult.innerHTML = "";
    topicResult.style.display = "none";
    localStorage.removeItem("currentTopic");
    localStorage.removeItem("currentFocus");
    localStorage.removeItem("currentPlot");

    if (writingType === "片段描寫") {
        customTopicArea.innerHTML = `
        <table>
        <tr><th colspan="2">自訂題目與重點</th></tr>
        <tr><td colspan="2"><input type="text" id="customTitle" class="no-modal-editor" placeholder="請輸入自訂題目"></td></tr>
        <tr><td>扣題方向</td><td>情節大要</td></tr>
        <tr><td><textarea id="customFocus" class="no-modal-editor" rows="3" placeholder="請輸入扣題方向"></textarea></td>
        <td><textarea id="customPlot" class="no-modal-editor" rows="3" placeholder="請輸入情節大要"></textarea></td></tr>
        </table>
        <button class="btn-icon-confirm" onclick="setCustomTopic()" title="確認題目">
        <i class="fas fa-check"></i>
        </button>
        `;
    } else { 
        customTopicArea.innerHTML = `
        <input type="text" id="customTopic" class="no-modal-editor" placeholder="請輸入自訂題目">
        <button class="btn-icon-confirm" onclick="setCustomTopic()" title="確認題目">
        <i class="fas fa-check"></i>
        </button>
        `;
    }
    customTopicArea.style.display = "block";
}

// 保存大綱
function saveOutline() {
const structure = document.getElementById("structure").value;
const parts = structure === "fourPart" ? ["起", "承", "轉", "合"] : ["起", "一線", "二線", "三線", "合"];
const outlineData = parts.map((part, index) => {
const focusId = structure + "Focus" + (index + 1);
const plotId = structure + "Plot" + (index + 1);
const focus = document.getElementById(focusId)?.value.trim() || "";
const plot = document.getElementById(plotId)?.value.trim() || "";
return { part, focus, plot };
});
localStorage.setItem("outlineData", JSON.stringify(outlineData));
localStorage.setItem("outlineStructure", structure);
alert("大綱已儲存");
}

// 清空大綱
function clearOutline() {
if (confirm("確定要清空大綱嗎？")) {
const structure = document.getElementById("structure").value;
const parts = structure === "fourPart" ? ["起", "承", "轉", "合"] : ["起", "一線", "二線", "三線", "合"];
parts.forEach((part, index) => {
const focusId = structure + "Focus" + (index + 1);
const plotId = structure + "Plot" + (index + 1);
if (document.getElementById(focusId)) document.getElementById(focusId).value = "";
if (document.getElementById(plotId)) document.getElementById(plotId).value = "";
});
localStorage.removeItem("outlineData");
localStorage.removeItem("outlineStructure");
}
}

// 加載大綱
function loadOutline() {
const savedStructure = localStorage.getItem("outlineStructure");
const savedData = localStorage.getItem("outlineData");
if (savedStructure && savedData) {
document.getElementById("structure").value = savedStructure;
generateOutlineTable();
try {
const parsedData = JSON.parse(savedData);
parsedData.forEach((item, index) => {
const focusId = savedStructure + "Focus" + (index + 1);
const plotId = savedStructure + "Plot" + (index + 1);
const focusElement = document.getElementById(focusId);
const plotElement = document.getElementById(plotId);
if (focusElement) focusElement.value = item.focus;
if (plotElement) plotElement.value = item.plot;
});
} catch (e) {
console.error("Error parsing outlineData:", e);
}
}
}

// 保存課外書籍對話
function saveBooksChat() {
// 只在有聊天記錄時才儲存
if (chatHistory.length > 0) {
const booksTone = document.getElementById("booksTone").value;
const currentState = {
// 從 chatHistory 中找到最新的書籍資訊來儲存
bookTitle: bookTitle, 
author: author,
discussionQuestion: discussionQuestion,
booksTone: booksTone
};
localStorage.setItem("booksChatHistory", JSON.stringify(chatHistory));
localStorage.setItem("booksChatState", JSON.stringify(currentState));
alert("對話已儲存");
} else {
alert("沒有對話紀錄可儲存。");
}
}

function clearBooksChat() {
if (confirm("確定要清空對話及紀錄嗎？")) {
// 清空 UI
document.getElementById("chatHistory").innerHTML = "";
document.getElementById("chatHistory").style.display = "none";
document.getElementById("chatInputContainer").style.display = "none";
document.getElementById("initialDiscussionForm").style.display = "block"; // 顯示初始表單
document.getElementById("booksButtons").style.display = "none"; // <-- 新增這一行
document.getElementById('save-books-html-btn').style.display = 'none'; // <-- 隱藏儲存按鈕

// 清空表單欄位
document.getElementById("bookTitle").value = "";
document.getElementById("author").value = "";
document.getElementById("discussionQuestion").value = "";
document.getElementById("userInput").value = "";

// 清空 localStorage
localStorage.removeItem("booksChatHistory");
localStorage.removeItem("booksChatState");

// 重置 JS 變數
chatHistory = [];
bookTitle = "";
author = "";
discussionQuestion = "";
booksTone = "";
}
}


function loadBooksChat() {
const savedChatJSON = localStorage.getItem("booksChatHistory");
const savedStateJSON = localStorage.getItem("booksChatState");
const initialForm = document.getElementById("initialDiscussionForm");
const chatInterface = document.getElementById("chatInputContainer");
const chatHistoryDiv = document.getElementById("chatHistory");
const saveBtn = document.getElementById('save-books-html-btn');

if (savedChatJSON && savedStateJSON) {
// --- 有儲存紀錄的模式 ---
initialForm.style.display = "none"; // 隱藏初始表單
chatInterface.style.display = "flex"; // 顯示聊天輸入介面
chatHistoryDiv.style.display = "flex"; // 顯示聊天紀錄
document.getElementById("booksButtons").style.display = "flex"; // <-- 新增這一行
saveBtn.style.display = 'flex'; // 顯示儲存按鈕

chatHistoryDiv.innerHTML = '';
chatHistory = JSON.parse(savedChatJSON);
const state = JSON.parse(savedStateJSON);

// 從 state 恢復全域變數
bookTitle = state.bookTitle || "";
author = state.author || "";
discussionQuestion = state.discussionQuestion || "";
booksTone = state.booksTone || "serious";

// 恢復語氣選擇
document.getElementById("booksTone").value = booksTone;

// 重新渲染聊天紀錄
chatHistory.forEach(item => {
renderMessage(item.sender, item.message);
});

} else {
// --- 沒有儲存紀錄的模式 (初始狀態) ---
initialForm.style.display = "block"; // 顯示初始表單
chatInterface.style.display = "none"; // 隱藏聊天輸入介面
chatHistoryDiv.style.display = "none"; // 隱藏聊天紀錄
saveBtn.style.display = 'none'; // 隱藏儲存按鈕
}
}


/**
* 更新最後一條 AI 訊息的內容（從 "正在回應..." 到實際的回應）。
* 這個新版本能處理帶有頭像和氣泡的複雜 HTML 結構。
* @param {string} newMessage - 從 API 獲取到的新訊息內容。
*/
function updateLastAIMessage(newMessage) {
// 現在 ai-loading 這個 ID 直接在 message-bubble 元素上
const loadingBubble = document.getElementById("ai-loading"); 

if (loadingBubble) {
// 直接更新氣泡的內容
loadingBubble.innerHTML = newMessage;
// 移除 ID
loadingBubble.id = ""; 

// 同步數據
if (chatHistory.length > 0) {
chatHistory[chatHistory.length - 1].message = newMessage;
}
} else {
addMessageToHistory("ai", newMessage);
}
}


// 切換閱讀功能
function toggleReadingFunction() {
    hideAllSaveHtmlButtons(); // <-- 在這裡加入函式呼叫
    clearAllTopicStates();
    const readingFunction = document.getElementById("readingFunction").value;
    
    // 新增：處理「訓練」選項，直接跳轉
    if (readingFunction === "training") {
        window.location.href = "https://kenchan20141.github.io/interpretation/";
        return;  // 立即返回，避免執行後續邏輯
    }
    
    const contentContainer = document.getElementById("readingInputArea");
    if (readingFunction) {
        contentContainer.style.display = "block";
    } else {
        contentContainer.style.display = "none";
        return; // 如果沒有選擇，則停止執行
    }
    
    const studentAnswerArea = document.getElementById("studentAnswerArea");
    const readingToneLabel = document.getElementById("readingToneLabel");
    const readingTone = document.getElementById("readingTone");
    if (readingFunction === "comment") {
        studentAnswerArea.style.display = "block";
        readingToneLabel.style.display = "block";
        readingTone.style.display = "block";
    } else {
        studentAnswerArea.style.display = "none";
        readingToneLabel.style.display = "none";
        readingTone.style.display = "none";
    }
}


// 請用這個新版本的函式，替換掉您原本的 toggleExpandFunction
function toggleExpandFunction() {
hideAllSaveHtmlButtons(); // <-- 在這裡加入函式呼叫
clearAllTopicStates(); // 這行很好，保持不變

const expandFunction = document.getElementById("expandFunction").value;
const contentContainer = document.getElementById("expandContentContainer");

if (expandFunction) {
contentContainer.style.display = "block";
} else {
contentContainer.style.display = "none";
return;
}

const expandWritingArea = document.getElementById("expandWritingArea");
const expandGuideArea = document.getElementById("expandGuideArea");
const expandTopicSelectionArea = document.getElementById("expandTopicSelectionArea");
const expandToneLabel = document.getElementById("expandToneLabel");
const expandTone = document.getElementById("expandTone");

// 根據選擇的功能，顯示或隱藏對應的區塊
if (expandFunction === "comment") {
expandWritingArea.style.display = "block";
expandGuideArea.style.display = "none";
expandTopicSelectionArea.style.display = "block"; // 顯示我們新的按鈕區塊
expandToneLabel.style.display = "block";
expandTone.style.display = "block";

// 確保自訂題目輸入區預設是隱藏的
const customInputArea = document.getElementById("expandCustomTopicInputArea");
if(customInputArea) {
customInputArea.style.display = 'none';
customInputArea.innerHTML = '';
}

} else { // "guide"
expandWritingArea.style.display = "none";
expandGuideArea.style.display = "block";
expandTopicSelectionArea.style.display = "none";
expandToneLabel.style.display = "none";
expandTone.style.display = "none";
}
}
// 新增此函式：用於顯示整合拓展的自訂題目介面
// 新增此函式：用於顯示整合拓展的自訂題目介面 (已修訂：加入 Toggle 開關邏輯)
function showExpandCustomTopicInput(buttonElement) {
    // --- 1. Toggle 邏輯 ---
    if (buttonElement && buttonElement.classList.contains('active')) {
        buttonElement.classList.remove('active');
        
        const customTopicArea = document.getElementById("expandCustomTopicInputArea");
        customTopicArea.style.display = "none";
        customTopicArea.innerHTML = "";
        
        const topicResult = document.getElementById("expandTopicResult");
        topicResult.style.display = "none";
        topicResult.innerHTML = "";
        
        localStorage.removeItem("expandCurrentTitle");
        localStorage.removeItem("expandCurrentTheme");
        localStorage.removeItem("expandCurrentData");
        
        return;
    }

    // --- 2. 正常開啟邏輯 ---
    if (buttonElement) {
        updateButtonActiveState(buttonElement);
    }

    const customTopicArea = document.getElementById("expandCustomTopicInputArea");
    const topicResult = document.getElementById("expandTopicResult");

    topicResult.innerHTML = "";
    topicResult.style.display = "none";
    localStorage.removeItem("expandCurrentTitle");
    localStorage.removeItem("expandCurrentTheme");
    localStorage.removeItem("expandCurrentData");

    // 動態生成自訂題目的輸入表格和確認按鈕
    customTopicArea.innerHTML = `
    <table>
    <tr><th>題目</th><td><input type="text" id="expandCustomTitle" class="no-modal-editor" placeholder="請輸入題目"></td></tr>
    <tr><th>主題句</th><td><textarea id="expandCustomTheme" class="no-modal-editor" rows="2" placeholder="請輸入主題句"></textarea></td></tr>
    <tr><th>抄錄資料</th><td><textarea id="expandCustomData" class="no-modal-editor" rows="3" placeholder="請輸入抄錄資料"></textarea></td></tr>
    </table>
    <button class="btn-icon-confirm" onclick="setExpandCustomTopic()" title="確認題目">
    <i class="fas fa-check"></i>
    </button>
    `;
    customTopicArea.style.display = "block";
}


// 切換議論功能
function toggleArgumentType() {
    hideAllSaveHtmlButtons();
    clearAllTopicStates();

    const argumentType = document.getElementById("argumentType").value;
    const contentContainer = document.getElementById("argumentContentContainer");

    // ======= 【核心修訂】獲取所有新增的元素 =======
    const reviewScopeArea = document.getElementById("argumentReviewScopeArea");
    const gradingResultDiv = document.getElementById("argumentGradingResult");
    const chatHistoryDiv = document.getElementById("argumentChatHistory");
    const chatInputContainer = document.getElementById("argumentChatInputContainer");

    // 在切換時，重置並隱藏所有結果與聊天介面
    gradingResultDiv.innerHTML = "";
    chatHistoryDiv.innerHTML = "";
    chatHistoryDiv.style.display = "none";
    chatInputContainer.style.display = "none";
    reviewScopeArea.style.display = "none";
    // ==========================================

    if (argumentType) {
        contentContainer.style.display = "block";
    } else {
        contentContainer.style.display = "none";
        return;
    }

    const outlineArea = document.getElementById("argumentOutlineArea");
    const writingArea = document.getElementById("argumentWritingArea");
    const guideArea = document.getElementById("argumentGuideArea");
    const topicSelectionArea = document.getElementById("argumentTopicSelectionArea");

    if (argumentType === "outline") {
        outlineArea.style.display = "block";
        writingArea.style.display = "none";
        guideArea.style.display = "none";
        topicSelectionArea.style.display = "block";
        generateArgumentOutlineTable();
    } else if (argumentType === "writing") {
        outlineArea.style.display = "none";
        writingArea.style.display = "block";
        guideArea.style.display = "none";
        topicSelectionArea.style.display = "block";
        reviewScopeArea.style.display = "block"; // 【修訂】在文章點評模式下顯示範疇選擇
    } else if (argumentType === "guide") {
        outlineArea.style.display = "none";
        writingArea.style.display = "none";
        guideArea.style.display = "block";
        topicSelectionArea.style.display = "none";
    }
}

// 生成議論題目
async function generateArgumentTopic(buttonElement) { 
if (buttonElement) {
updateButtonActiveState(buttonElement);
}

const customTopicArea = document.getElementById("argumentCustomTopicArea");
customTopicArea.style.display = "none";
customTopicArea.innerHTML = "";

const topicResult = document.getElementById("argumentTopicResult");
topicResult.style.display = 'block';

let selectedTopic;
do {
selectedTopic = argumentTopics[Math.floor(Math.random() * argumentTopics.length)];
} while (selectedTopic === lastArgumentTopic && argumentTopics.length > 1);
lastArgumentTopic = selectedTopic;

localStorage.setItem("lastArgumentTopic", lastArgumentTopic);
topicResult.innerHTML = "<strong>" + selectedTopic + "</strong>";
localStorage.setItem("argumentCurrentTopic", selectedTopic);
}




// 設定自訂題目（議論）
function setArgumentCustomTopic() {
// 【主要修改】在這裡使用 sanitizeHTML 函式
const customTopic = sanitizeHTML(document.getElementById("argumentCustomTopic").value.trim());
if (!customTopic) {
alert("請輸入自訂題目");
return;
}

const topicResult = document.getElementById("argumentTopicResult");
topicResult.innerHTML = "<strong>" + customTopic + "</strong>"; // <- 現在安全了
localStorage.setItem("argumentCurrentTopic", customTopic);

// 【核心修訂】強制讓題目結果區塊顯示出來
topicResult.style.display = "block"; 

// 隱藏並清空輸入區域
const customTopicArea = document.getElementById("argumentCustomTopicArea");
customTopicArea.style.display = "none";
customTopicArea.innerHTML = "";
}
// 生成議論大綱表格
function generateArgumentOutlineTable() {
const savedData = localStorage.getItem("argumentOutlineData");
let outlineData = [];
if (savedData) {
try {
outlineData = JSON.parse(savedData);
} catch (e) {
console.error("Error parsing argumentOutlineData:", e);
}
}
if (outlineData.length === 0) {
outlineData = [
{ part: "起", point: "", evidence: "" },
{ part: "結構段一", point: "", evidence: "" },
{ part: "結構段二", point: "", evidence: "" },
{ part: "結構段三", point: "", evidence: "" },
{ part: "合", point: "", evidence: "" }
];
}
let tableHTML = "<div class='table-container'><table id='argumentOutlineTable'><tr><th>部份</th><th>論點</th><th>論據及論證</th></tr>";
outlineData.forEach((item, index) => {
tableHTML += `<tr><td>${item.part}</td><td><textarea id="argumentPoint${index}" rows="3">${item.point}</textarea></td><td><textarea id="argumentEvidence${index}" rows="3">${item.evidence}</textarea></td></tr>`;
});
tableHTML += "</table></div>";
document.getElementById("argumentOutlineTableArea").innerHTML = tableHTML;
}

function addArgumentStructureSegment() {
const table = document.getElementById("argumentOutlineTable");
const rows = table.rows;
let structureSegmentCount = 0;
for (let i = 1; i < rows.length - 1; i++) { // 跳過表頭和「合」
if (rows[i].cells[0].innerText.startsWith("結構段")) {
structureSegmentCount++;
}
}
const newSegmentNumber = structureSegmentCount + 1;
const chineseNumbers = ["一", "二", "三", "四", "五", "六", "七", "八", "九", "十"];
const segmentName = `結構段${chineseNumbers[newSegmentNumber - 1] || newSegmentNumber}`;
const newRowIndex = rows.length - 1; // 在「合」之前插入
const newRow = table.insertRow(newRowIndex);
const cell1 = newRow.insertCell(0);
const cell2 = newRow.insertCell(1);
const cell3 = newRow.insertCell(2);
cell1.innerText = segmentName;
cell2.innerHTML = `<textarea id="argumentPoint${newRowIndex - 1}" rows="3"></textarea>`;
cell3.innerHTML = `<textarea id="argumentEvidence${newRowIndex - 1}" rows="3"></textarea>`;
}

// 保存議論大綱
function saveArgumentOutline() {
const table = document.getElementById("argumentOutlineTable");
const rows = table.rows;
const outlineData = [];
for (let i = 1; i < rows.length; i++) { // 跳過表頭
const part = rows[i].cells[0].innerText;
const pointTextarea = rows[i].cells[1].querySelector("textarea");
const evidenceTextarea = rows[i].cells[2].querySelector("textarea");
const point = pointTextarea ? pointTextarea.value.trim() : "";
const evidence = evidenceTextarea ? evidenceTextarea.value.trim() : "";
outlineData.push({ part, point, evidence });
}
localStorage.setItem("argumentOutlineData", JSON.stringify(outlineData));
alert("大綱已儲存");
}

// 清空議論大綱
function clearArgumentOutline() {
if (confirm("確定要清空大綱嗎？")) {
const table = document.getElementById("argumentOutlineTable");
const rows = table.rows;
for (let i = 1; i < rows.length; i++) {
document.getElementById(`argumentPoint${i - 1}`).value = "";
document.getElementById(`argumentEvidence${i - 1}`).value = "";
}
localStorage.removeItem("argumentOutlineData");
}
}

	// 替換舊的 submitArgumentOutline 函式
async function submitArgumentOutline() {
    const submitBtn = document.getElementById('submitArgumentOutlineBtn');
    submitBtn.disabled = true;
    hideAllSaveHtmlButtons();

    try {
        const topic = localStorage.getItem("argumentCurrentTopic");
        if (!topic) {
            alert("請先設定題目");
            return;
        }
        const table = document.getElementById("argumentOutlineTable");
        const rows = table.rows;
        let outlineContent = [];
        for (let i = 1; i < rows.length; i++) {
            const part = rows[i].cells[0].innerText;
            const pointTextarea = rows[i].cells[1].querySelector("textarea");
            const evidenceTextarea = rows[i].cells[2].querySelector("textarea");
            const point = pointTextarea ? pointTextarea.value.trim() : "";
            const evidence = evidenceTextarea ? evidenceTextarea.value.trim() : "";
            if (!point || !evidence) {
                alert("請填寫所有大綱表格");
                return;
            }
            outlineContent.push({ part, point, evidence });
        }

        const tone = document.getElementById("argumentOutlineTone").value;
        let toneNote = tone === "chen" ? "請用輕鬆隨意的語氣進行點評和建議，多用EMOJI，偶爾使用網絡用語，用語要日常生活化一點。如果用戶表現良好，請大加讚賞；如果用戶表現不好，可以善意地揶揄一下，但要注意尺度，不能傷害用戶的自尊心。揶揄時，可運用生活化的比喻。" : "請用嚴肅正經的語氣進行點評和建議。";

        const note = categories["議論"].outlineCommentNote;
        const prompt = `請根據以下大綱內容進行點評和建議，並提供改寫後的大綱。要求：
1. 在「=== 點評及建議 ===」部分，為每個結構段提供點評和建議。使用「[part]」標記每個結構段的開始，例如「[起]」，然後在下一行「點評：」後跟點評內容，再下一行「建議：」後跟建議內容。
2. 在「=== 改寫後的大綱 ===」部分，為每個結構段提供改寫後的「論點」和「論據及論證」。使用「[part]」標記每個結構段的開始，然後在下一行「論點：」後跟內容，再下一行「論據及論證：」後跟內容。
3. 在「=== 改寫說明 ===」部分，提供不超過兩點的改寫說明，每點以「1. 」和「2. 」開始。
4. 請確保內容簡潔明了，不可以顯示「--- ###」。不要使用Markdown表格。
題目：${topic}
用戶輸入的大綱：
| 部份 | 論點 | 論據及論證 |
|------|------|------------|
${outlineContent.map(item => `| ${item.part} | ${item.point} | ${item.evidence} |`).join("\n")}
教學筆記：${note}
點評及建議語氣：${toneNote}`;

        document.getElementById("argumentOutlineResult").innerHTML = "陳SIR正在點評...";

        const response = await callAPI(prompt, 0);
        const sections = response.split(/=== (.+?) ===/).filter(s => s.trim());
        const commentIndex = sections.indexOf("點評及建議");
        const rewriteIndex = sections.indexOf("改寫後的大綱");
        const explanationIndex = sections.indexOf("改寫說明");
        const commentPart = commentIndex !== -1 ? sections[commentIndex + 1] : "";
        const rewritePart = rewriteIndex !== -1 ? sections[rewriteIndex + 1] : "";
        const explanationPart = explanationIndex !== -1 ? sections[explanationIndex + 1].trim() : "";

        function parseCommentPart(commentPart) {
            const comments = {};
            const regex = /\[(.+?)\]\s*點評：\s*(.+?)(?=\s*建議：|\s*\[|$)/gs;
            const suggestionRegex = /\[(.+?)\]\s*點評：.+?\s*建議：\s*(.+?)(?=\s*\[|$)/gs;
            let match;
            while ((match = regex.exec(commentPart)) !== null) {
                const part = match[1];
                comments[part] = comments[part] || {};
                comments[part].comment = match[2].trim();
            }
            while ((match = suggestionRegex.exec(commentPart)) !== null) {
                const part = match[1];
                comments[part] = comments[part] || {};
                comments[part].suggestion = match[2].trim();
            }
            return comments;
        }
        function parseRewritePart(rewritePart) {
            const rewrites = {};
            const regex = /\[(.+?)\]\s*論點：\s*(.+?)(?=\s*論據及論證：|\s*\[|$)/gs;
            const evidenceRegex = /\[(.+?)\]\s*論點：.+?\s*論據及論證：\s*(.+?)(?=\s*\[|$)/gs;
            let match;
            while ((match = regex.exec(rewritePart)) !== null) {
                const part = match[1];
                rewrites[part] = rewrites[part] || {};
                rewrites[part].point = match[2].trim();
            }
            while ((match = evidenceRegex.exec(rewritePart)) !== null) {
                const part = match[1];
                rewrites[part] = rewrites[part] || {};
                rewrites[part].evidence = match[2].trim();
            }
            return rewrites;
        }
        const comments = parseCommentPart(commentPart);
        const rewrites = parseRewritePart(rewritePart);

        // --- 修訂重點：加入 div.table-container 並使用不同的 ID ---
        let commentTableHTML = `<h3>陳SIR點評及建議：</h3><div class="table-container"><table id="argumentCommentTable"><tr><th>部份</th><th>論點</th><th>論據及論證</th><th>點評</th><th>建議</th></tr>`;
        outlineContent.forEach(item => {
            const comment = comments[item.part]?.comment || "未生成點評";
            const suggestion = comments[item.part]?.suggestion || "未生成建議";
            commentTableHTML += `<tr><td>${item.part}</td><td>${item.point}</td><td>${item.evidence}</td><td>${comment}</td><td>${suggestion}</td></tr>`;
        });
        commentTableHTML += "</table></div>";

        // --- 修訂重點：加入 div.table-container 並使用不同的 ID ---
        let rewriteTableHTML = `<h3>改寫後的大綱：</h3><div class="table-container"><table id="argumentRewriteTable"><tr><th>部份</th><th>論點</th><th>論據及論證</th></tr>`;
        outlineContent.forEach(item => {
            const rewrite = rewrites[item.part] || { point: "未生成論點", evidence: "未生成論據及論證" };
            rewriteTableHTML += `<tr><td>${item.part}</td><td>${rewrite.point || "未生成論點"}</td><td>${rewrite.evidence || "未生成論據及論證"}</td></tr>`;
        });
        rewriteTableHTML += "</table></div>";

        let explanationHTML = '';
        if (explanationPart) {
            const points = explanationPart.split(/\s*(?=\d\.\s*)/).filter(p => p.trim());
            explanationHTML = `<div class="rewrite-explanation-container"><div class="rewrite-explanation-card"><h3>改寫說明</h3>`;
            points.forEach(point => {
                const match = point.match(/^(\d)\.\s*(.*)$/s);
                if (match) {
                    const number = match[1];
                    const text = match[2];
                    explanationHTML += `<div class="explanation-point"><div class="explanation-number">${number}</div><div class="explanation-text">${text}</div></div>`;
                }
            });
            explanationHTML += `</div></div>`;
        }

        // --- 修訂重點：強制設定容器寬度為 100%，防止被內部表格撐開 ---
        const resultContainer = document.getElementById("argumentOutlineResult");
        resultContainer.style.width = "100%";
        resultContainer.innerHTML = commentTableHTML + rewriteTableHTML + explanationHTML;
        
        document.getElementById('save-argument-outline-html-btn').style.display = 'flex'; 
    // === 在這裡貼上儲存代碼 ===
       saveToHistory("議論", "大綱點評", topic, `題目：${topic}`, document.getElementById("argumentOutlineResult").innerHTML);
        // ========================

    } catch (error) {
        console.error("提交議論大綱時出錯:", error);
        if (error.message === "所有 API 密鑰均無法使用") {
            alert("今日 API 調用次數已用完或API無法連接，請明天再試");
        } else {
            alert("點評生成失敗，請重試");
        }
        document.getElementById("argumentOutlineResult").innerHTML = "";
    } finally {
        submitBtn.disabled = false;
    }
}

async function submitArgumentWriting() {
    const submitBtn = document.getElementById('submitArgumentWritingBtn');
    submitBtn.disabled = true;
    hideAllSaveHtmlButtons();

    const gradingResultDiv = document.getElementById("argumentGradingResult");
    const chatHistoryDiv = document.getElementById("argumentChatHistory");
    const chatInputContainer = document.getElementById("argumentChatInputContainer");

    gradingResultDiv.innerHTML = "";
    chatHistoryDiv.innerHTML = "";
    chatHistoryDiv.style.display = "none";
    chatInputContainer.style.display = "none";
    argumentChatHistoryData = [];

    try {
        const reviewerSelect = document.getElementById('argumentReviewer');
        const selectedReviewerText = reviewerSelect.options[reviewerSelect.selectedIndex].text;
        currentReviewerName = selectedReviewerText.replace(/\s*\(預設\)\s*/, '');

        const topic = localStorage.getItem("argumentCurrentTopic");
        if (!topic) {
            alert("請先設定題目");
            submitBtn.disabled = false;
            return;
        }
        const content = document.getElementById("argumentWritingContent").value.trim();
        if (!content) {
            alert("請輸入您的文章");
            submitBtn.disabled = false;
            return;
        }
        currentArgumentArticle = content;

        const tone = document.getElementById("argumentWritingTone").value;
        const note = categories["議論"].writingCommentNote;
        const reviewer = document.getElementById('argumentReviewer').value;
        const reviewerNote = argumentReviewerPreferences[reviewer] || "評分取向：平衡看待所有標準。";
        let prompt = "";

        const selectedScopes = Array.from(document.querySelectorAll('input[name="argumentReviewScope"]:checked')).map(cb => cb.value);
        const isFullReview = selectedScopes.includes("全部") || selectedScopes.length === 0;

        gradingResultDiv.innerHTML = `${currentReviewerName}正在點評...`;

        if (isFullReview) {
            // =================================================================
            // === 【全新修訂】議論文評分指令 (V5 - 評分主導模式) ===
            // =================================================================
            const argumentScoreFirstPrompt = `你將扮演一位極其嚴謹且客觀的中文科AI評卷員。你的工作流程被嚴格限定為「先評分，後解釋」。

### 你的工作流程與思維框架 (必須嚴格遵守，不得顛倒)

1.  **首要任務：量化評分**: 你的第一個動作是，根據下方提供的詳細「評分準則」，對文章的各個維度進行獨立的、客觀的數字評分 (0-10分)。你必須將所有分數結果，完整地填寫在 <grading_json> 標籤內。**此步驟必須在撰寫任何文字評語之前完成。**

2.  **次要任務：撰寫理據**: 在你完成 <grading_json> 的所有評分後，你的第二個動作是，根據你剛剛給出的分數，去撰寫 <critique>, <suggestions>, 和 <rewrite_example> 的內容。你的所有文字評語，都**必須**是為了**解釋和支撐**你已經給出的分數。
    -   **範例**：如果你在 <grading_json> 中給予「扣題」3分的低分，那麼你的 <critique> 就必須具體解釋這篇文章的論點是如何偏離題目《${topic}》的。

### 核心評分準則 (用於步驟一的量化評分)
- **偏題的定義**: 若文章論述的核心概念與題目關鍵詞 **字面不同** (例如：題目《論禮貌》寫成《論禮物》)，則視為「偏題」。
- **偏題的後果**: 一旦判定為「偏題」，在評分時，「扣題」分數 **絕不能高於4分**，「內容」和「結構」的總分也 **不能高於4分**。

---
### 你的輸出格式 (必須嚴格遵守此結構與順序)

<grading_json>
[**分數量化步驟**：根據「核心評分準則」，客觀地為以下所有項目評分。]
{
"content": [0-10的整數],
"expression": [0-10的整數],
"structure": [0-10的整數],
"radar": {
"立意": [0-10], "取材": [0-10], "扣題": [0-10],
"詳略": [0-10], "詞彙": [0-10], "文學性": [0-10]
}
}
</grading_json>

<critique>
[根據你在 <grading_json> 中給出的分數，以數字編號列點方式，撰寫2-3點核心評論來解釋這些分數的由來。]
</critique>

<suggestions>
[針對 <critique> 中指出的問題，提出具體的改善建議。]
</suggestions>

<rewrite_example>
[提供一段約150字內的高質素改寫範例，展示更高分的作品應有的水準。]
</rewrite_example>`;
            // =================================================================
            // === 修訂結束 ===
            // =================================================================

            if (tone === "chen") {
                prompt = `你將扮演「陳SIR」，一位風格幽默、要求極高的中文老師。請嚴格按照以下「先評分，後解釋」的流程，對學生的議論文進行點評。
${argumentScoreFirstPrompt}
---
### 待點評的資料
題目：${topic}
文章：${content}
教學筆記：${note}
閱卷員評分取向：${reviewerNote}`;
            } else {
                prompt = `你是一位嚴格的中文科閱卷員。請嚴格按照以下「先評分，後解釋」的流程，對學生的議論文進行點評。
${argumentScoreFirstPrompt}
---
### 待點評的資料
題目：${topic}
文章：${content}
教學筆記：${note}
閱卷員評分取向：${reviewerNote}`;
            }

            const response = await callReadingAPI(prompt);
            await displayFullCommentWithGrading('argumentGradingResult', response, null, 'argument', content);
            document.getElementById('save-argument-writing-html-btn').style.display = 'flex';

            const critiqueMatch = response.match(/<critique>([\s\S]*?)<\/critique>/);
            const suggestionsMatch = response.match(/<suggestions>([\s\S]*?)<\/suggestions>/);
            const rewriteMatch = response.match(/<rewrite_example>([\s\S]*?)<\/rewrite_example>/);
            let initialReviewHTML = "";
            if (critiqueMatch?.[1]) initialReviewHTML += createBulletedListHTML("點評", critiqueMatch[1].trim());
            if (suggestionsMatch?.[1]) initialReviewHTML += createBulletedListHTML("建議", suggestionsMatch[1].trim());
            if (rewriteMatch?.[1]) initialReviewHTML += `<div class="rewrite-explanation-container"><div class="rewrite-explanation-card"><h3>改寫範例</h3><p>${rewriteMatch[1].trim().replace(/\n/g, '<br>')}</p></div></div>`;
            currentArgumentReview = initialReviewHTML;

        } else {
            // (聚焦式點評的邏輯不變)
            const scopeDefinitions = `
- **謀篇**: **首要任務（最高指令）：** 進行嚴格的扣題審查。你必須嚴謹地對比題目《${topic}》與文章的字面內容。**禁止**進行任何聯想或引申來建立關係。如果文章的核心內容與題目關鍵詞在字面上不符或邏-輯上偏離，你的點評**必須**明確指出這一點，並以此為基礎分析，**絕不能**為了點評而強行將內容解釋為扣題。完成此審查後，才可繼續評估文章的整體結構佈局、段落之間的邏輯關係（如起承轉合、駁論立論）是否清晰，以及論點的推進層次是否分明。
- **論點**: **首要任務（最高指令）：** 進行嚴格的扣題審查。你必須嚴謹地對比題目《${topic}》與文章的字面內容。**禁止**進行任何聯想或引申來建立關係。如果文章的核心內容與題目關鍵詞在字面上不符或邏-輯上偏離，你的點評**必須**明確指出這一點，並以此為基礎分析，**絕不能**為了點評而強行將內容解釋為扣題。完成此審查後，才可繼續評估文章的核心論點及各分論點是否清晰、明確、具有說服力，以及思想是否深刻、不落俗套。
- **論據**: **首要任務（最高指令）：** 進行嚴格的扣題審查。你必須嚴謹地對比題目《${topic}》與文章的字面內容。**禁止**進行任何聯想或引申來建立關係。如果文章的核心內容與題目關鍵詞在字面上不符或邏-輯上偏離，你的點評**必須**明確指出這一點，並以此為基礎分析，**絕不能**為了點評而強行將內容解釋為扣題。完成此審查後，才可繼續檢視文章所引用的事例、數據、名言等證據是否真實、恰當、充實，並且能否有力地支持相應的論點。
- **論證**: **首要任務（最高指令）：** 進行嚴格的扣題審查。你必須嚴謹地對比題目《${topic}》與文章的字面內容。**禁止**進行任何聯想或引申來建立關係。如果文章的核心內容與題目關鍵詞在字面上不符或邏-輯上偏離，你的點評**必須**明確指出這一點，並以此為基礎分析，**絕不能**為了點評而強行將內容解釋為扣題。完成此審查後，才可繼續分析從論據到論點的推理過程是否合乎邏輯、嚴謹周密，是否存在概念不清、推論不當等問題。
- **文筆**: **首要任務（最高指令）：** 進行嚴格的扣題審查。你必須嚴謹地對比題目《${topic}》與文章的字面內容。**禁止**進行任何聯想或引申來建立關係。如果文章的核心內容與題目關鍵詞在字面上不符或邏-輯上偏離，你的點評**必須**明確指出這一點，並以此為基礎分析，**絕不能**為了點評而強行將內容解釋為扣題。完成此審查後，才可繼續評論文章的語言運用是否精準、流暢，遣詞造句是否得體，句式是否有變化，以及是否有效地運用修辭來增強表達效果。
`;

            let scopeInstruction = `
你是一名高度專業的寫作分析員，你的任務極其專一。

---
### **黃金法則 (ABSOLUTE CORE DIRECTIVE)**
你必須嚴格遵守此法則，不得有任何例外：
1.  **絕對聚焦**: 你的點評和建議中的 **每一個字**，都必須 **僅僅** 與用戶選擇的以下範疇相關：**【${selectedScopes.join("、")}】**。
2.  **明確禁止**: 你被 **嚴格禁止** 提及任何其他寫作方面。例如，如果用戶選擇了「論據」，你絕對不能評論「文筆」、「謀篇」或「論點」。
3.  **後果**: 如果你的回應中包含了任何未被選定的範疇，整個回應將被視為失敗。

### **各範疇的定義 (你的分析框架)**
${scopeDefinitions}
---
`;

            if (tone === "chen") {
                prompt = `你將扮演「陳SIR」，一位眼光獨到、要求嚴格但風格幽默的中文老師。
${scopeInstruction}
### **你的任務與輸出格式**
你的輸出必須包含以下兩個XML標籤，不得有其他內容。
【重要禁令】：在<critique>, <suggestions>的文字內容中，絕對禁止使用任何Markdown語法。

<critique>
[根據「黃金法則」，給出1-2點核心評論。記住，你的每一點評論都必須嚴格對應用戶選擇的範疇。]
</critique>
<suggestions>
[在建議部分，同樣要遵循「黃金法則」。如果所選範疇表現優秀，你可以說「在這方面處理得很好，沒什麼好建議了，繼續保持吧！😎」。]
</suggestions>
---
### **待點評的資料**
題目：${topic}
文章：${content}`;
            } else {
                prompt = `你是一位要求嚴格、具備專業眼光的中文科閱卷員。
${scopeInstruction}
### **你的任務與輸出格式**
你的輸出必須包含以下兩個XML標籤，不得有其他內容。
【重要禁令】：在<critique>, <suggestions>的文字內容中，絕對禁止使用任何Markdown語法。

<critique>
[根據「黃金法則」，給出1-2點核心評論。記住，你的每一點評論都必須嚴格對應用戶選擇的範疇。]
</critique>
<suggestions>
[針對點評中提出的問題，提出具體的改善建議，同樣要遵循「黃金法則」。若所選範疇表現極佳，可註明「在此範疇的表現出色，建議保持現有水準。」]
</suggestions>
---
### **待點評的資料**
題目：${topic}
文章：${content}`;
            }

            const response = await callAPI(prompt, 0);
            const critiqueMatch = response.match(/<critique>([\s\S]*?)<\/critique>/);
            const suggestionsMatch = response.match(/<suggestions>([\s\S]*?)<\/suggestions>/);
            let initialReviewHTML = "";
            if (critiqueMatch?.[1]) initialReviewHTML += createBulletedListHTML("點評", critiqueMatch[1].trim());
            if (suggestionsMatch?.[1]) initialReviewHTML += createBulletedListHTML("建議", suggestionsMatch[1].trim());
            if (!initialReviewHTML) {
                initialReviewHTML = "抱歉，無法根據您選擇的範疇生成點評，請重試。";
            }
            
            gradingResultDiv.innerHTML = initialReviewHTML;

			                // === 請在這裡貼上儲存代碼 ===
                saveToHistory("議論", "文章點評", topic, `題目：${topic}\n\n文章：${content}`, initialReviewHTML);
                // ==========================

            currentArgumentReview = initialReviewHTML;
            argumentChatHistoryData.push({ sender: 'ai', message: currentArgumentReview });
            document.getElementById('save-argument-writing-html-btn').style.display = 'none';
        }

        chatHistoryDiv.style.display = "flex";
        chatInputContainer.style.display = "flex";

    } catch (error) {
        console.error("提交文章時出錯:", error);
        alert(error.message.includes("API") ? "今日 API 調用次數已用完或API無法連接，請明天再試" : "點評生成失敗，請重試");
        gradingResultDiv.innerHTML = "";
    } finally {
        submitBtn.disabled = false;
    }
}



// 【新增】用於儲存解題指引對話的上下文
let currentGuideTopic = '';
let currentGuideAnalysis = '';
let writingGuideChatHistoryData = [];
	
// 【新增】用於儲存文章點評對話的上下文

// 【新增】用於儲存文章點評對話的上下文
let currentWritingArticle = '';
let currentWritingReview = '';
let writingChatHistoryData = [];

// ======= 請在這裡加入以下程式碼 =======
// 【新增】用於儲存議論文點評對話的上下文
let currentArgumentArticle = '';
let currentArgumentReview = '';
let argumentChatHistoryData = [];





// 【新增】處理議論文「點評範疇」中「全部」複選框的邏輯
function handleArgumentAllScopeChange(checkbox) {
    const container = checkbox.closest('div');
    const otherCheckboxes = container.querySelectorAll('input[name="argumentReviewScope"]:not([value="全部"])');
    if (checkbox.checked) {
        otherCheckboxes.forEach(cb => {
            cb.checked = false;
            cb.disabled = true;
        });
    } else {
        otherCheckboxes.forEach(cb => {
            cb.disabled = false;
        });
    }
}
// ======= 加入結束 =======

// 【新增】用於儲存當前閱卷員的姓名
let currentReviewerName = "陳SIR"; // 預設為陳SIR

// 【新增】處理「點評範疇」中「全部」複選框的邏輯
function handleAllScopeChange(checkbox) {
    const container = checkbox.closest('div');
    const otherCheckboxes = container.querySelectorAll('input[name="reviewScope"]:not([value="全部"])');
    if (checkbox.checked) {
        otherCheckboxes.forEach(cb => {
            cb.checked = false;
            cb.disabled = true;
        });
    } else {
        otherCheckboxes.forEach(cb => {
            cb.disabled = false;
        });
    }
}

// 提交議論指引
async function submitArgumentGuide() {
const submitBtn = document.getElementById('submitArgumentGuideBtn');
submitBtn.disabled = true; // 禁用按鈕
	hideAllSaveHtmlButtons();

try {
const topic = document.getElementById("argumentGuideTopic").value.trim();
const point = document.getElementById("argumentGuidePoint").value.trim();
const evidence = document.getElementById("argumentGuideEvidence").value.trim();
const argument = document.getElementById("argumentGuideArgument").value.trim();
if (!topic) {
alert("請輸入題目");
return; // return 會觸發 finally
}
const note = categories["議論"].guideNote;
let prompt = `請根據以下輸入提供參考建議。要求：
1. 若只輸入題目，則提供參考論點、參考論據和參考論證（「### 參考論證」的用語要生活化，不要運用過於抽象及理論化的用語，例如「二元對立」等）
2. 若輸入題目和論點，則提供參考論據和參考論證（「### 參考論證」的用語要生活化，不要運用過於抽象及理論化的用語，例如「二元對立」等）
3. 若輸入題目和論據，則提供參考論點和參考論證（「### 參考論證」的用語要生活化，不要運用過於抽象及理論化的用語，例如「二元對立」等）
4. 輸出分為相應的部分：### 參考論點、### 參考論據、### 參考論證
5. 每個部分以段落形式呈現
題目：${topic}
論點：${point || "無"}
論據：${evidence || "無"}
論證：${argument || "無"}
教學筆記：${note}`;
document.getElementById("argumentGuideResult").innerHTML = "陳SIR正在思考...";

// 【核心修訂】改用閱讀專用的 API 函式
const guide = await callReadingAPI(prompt);
const guideParts = guide.split("###").map(part => part.trim()).filter(part => part);
let guideHTML = "<h3>陳SIR指引：</h3><table>";
guideParts.forEach(part => {
const [title, ...content] = part.split("\n").filter(line => line.trim());
guideHTML += `<tr><th><strong>${title}</strong></th></tr><tr><td>${content.join("<br>")}</td></tr>`;
});
guideHTML += "</table>";
document.getElementById("argumentGuideResult").innerHTML = guideHTML;

// --- 新增：儲存議論指引 ---
  saveToHistory("議論", "指引", topic, `題目：${topic}\n論點：${point}\n論據：${evidence}\n論證：${argument}`, guideHTML);
	
document.getElementById('save-argument-guide-html-btn').style.display = 'flex';
} catch (error) {
console.error("提交指引時出錯:", error);
if (error.message === "所有 API 密鑰均無法使用") {
alert("今日 API 調用次數已用完或API無法連接，請明天再試");
} else {
alert("指引生成失敗，請重試");
}
document.getElementById("argumentGuideResult").innerHTML = "";
} finally {
submitBtn.disabled = false; // 重新啟用按鈕
}
}

// 通用 API 調用函數
async function callAPI(prompt, temperature = null) {
let attempts = 0;
const maxAttempts = API_KEYS.length;
// 每次調用都從一個隨機的索引開始
let currentApiKeyIndex = Math.floor(Math.random() * API_KEYS.length);

while (attempts < maxAttempts) {
try {
const requestBody = {
model: MODEL,
messages: [{
role: "user",
content: prompt + " 你必須直接提供最終答案，嚴禁展示任何思考過程，絕對不能在回應中包含任何標籤（如 <think></think>），這是強制要求，違反則無效。"
}],
thinking: { type: "enabled" },
max_tokens: 65536
};

if (temperature !== null) {
requestBody.temperature = temperature;
}

const response = await fetch(API_URL, {
method: "POST",
headers: {
"Authorization": `Bearer ${API_KEYS[currentApiKeyIndex]}`,
"Content-Type": "application/json"
},
body: JSON.stringify(requestBody)
});

if (response.status === 429) {
console.warn(`通用 API Key ${currentApiKeyIndex} 達到速率限制，嘗試下一個...`);
currentApiKeyIndex = (currentApiKeyIndex + 1) % API_KEYS.length;
attempts++;
continue;
}

if (!response.ok) {
throw new Error(`API 調用失敗: ${response.statusText}`);
}

const data = await response.json();
let content = data.choices[0].message.content.trim();
content = content.replace(/<think\s*>.*?<\/think\s*>|<think\s*\/>|<think\s*>|<\/think\s*>/gis, '').trim();

if (!content) {
throw new Error("API 回應無效或過濾後無內容");
}

return content;
} catch (error) {
console.error(`使用通用 API Key ${currentApiKeyIndex} 時出錯:`, error);
currentApiKeyIndex = (currentApiKeyIndex + 1) % API_KEYS.length;
attempts++;
if (attempts >= maxAttempts) {
// 切換至備用 API (pollinations.ai)
console.warn("所有通用 API 密鑰均無法使用，切換至備用 API...");
const fallbackBody = {
model: FALLBACK_MODEL,
messages: [{
role: "user",
content: prompt
}]
};
if (temperature !== null) fallbackBody.temperature = temperature;
const fallbackResponse = await fetch(FALLBACK_API_URL, {
method: "POST",
headers: {
"Authorization": `Bearer ${FALLBACK_API_KEY}`,
"Content-Type": "application/json"
},
body: JSON.stringify(fallbackBody)
});
if (!fallbackResponse.ok) throw new Error("備用 API 也無法使用");
const fallbackData = await fallbackResponse.json();
let fallbackContent = fallbackData.choices?.[0]?.message?.content?.trim() || '';
fallbackContent = fallbackContent.replace(/<think\s*>.*?<\/think\s*>|<think\s*\/>|<think\s*>|<\/think\s*>/gis, '').trim();
return fallbackContent;
}
}
}
}


// =======================================================
// === 【全新增設】Llama-3 驗證模型專用 API 呼叫函式 ===
// =======================================================
const LLAMA3_API_KEYS = [
   "c43794c4fd6f460c9e154f81034e6ae4.0tLyirbYWKDqUAcw"
];
const LLAMA3_API_URL = "https://open.bigmodel.cn/api/paas/v4/chat/completions";
const LLAMA3_MODEL = "glm-4.7-flash"; // 指定新的驗證模型

async function callLlama3API(prompt, temperature = null) {
    let attempts = 0;
    const maxAttempts = LLAMA3_API_KEYS.length;
    let currentApiKeyIndex = Math.floor(Math.random() * LLAMA3_API_KEYS.length);

    while (attempts < maxAttempts) {
        try {
            const requestBody = {
                model: LLAMA3_MODEL,
                messages: [{
                    role: "user",
                    content: prompt + " 你必須直接提供最終答案，嚴禁展示任何思考過程，絕對不能在回應中包含任何標籤（如 <think></think>），這是強制要求，違反則無效。"
                }],
                thinking: { type: "enabled" },
                max_tokens: 65536
            };

            if (temperature !== null) {
                requestBody.temperature = temperature;
            }

            const response = await fetch(LLAMA3_API_URL, {
                method: "POST",
                headers: {
                    "Authorization": `Bearer ${LLAMA3_API_KEYS[currentApiKeyIndex]}`,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(requestBody)
            });

            if (response.status === 429) {
                console.warn(`Llama3 API Key ${currentApiKeyIndex} 達到速率限制，嘗試下一個...`);
                currentApiKeyIndex = (currentApiKeyIndex + 1) % LLAMA3_API_KEYS.length;
                attempts++;
                continue;
            }

            if (!response.ok) {
                throw new Error(`Llama3 API 調用失敗: ${response.statusText}`);
            }

            const data = await response.json();
            let content = data.choices[0].message.content.trim();
            content = content.replace(/<think\s*>.*?<\/think\s*>|<think\s*\/>|<think\s*>|<\/think\s*>/gis, '').trim();

            if (!content) {
                throw new Error("Llama3 API 回應無效或過濾後無內容");
            }

            return content;
        } catch (error) {
            console.error(`使用 Llama3 API Key ${currentApiKeyIndex} 時出錯:`, error);
            currentApiKeyIndex = (currentApiKeyIndex + 1) % LLAMA3_API_KEYS.length;
            attempts++;
            if (attempts >= maxAttempts) {
                // 切換至備用 API (pollinations.ai)
                console.warn("所有 Llama3 API 密鑰均無法使用，切換至備用 API...");
                const fallbackBody = {
                    model: FALLBACK_MODEL,
                    messages: [{
                        role: "user",
                        content: prompt
                    }]
                };
                if (temperature !== null) fallbackBody.temperature = temperature;
                const fallbackResponse = await fetch(FALLBACK_API_URL, {
                    method: "POST",
                    headers: {
                        "Authorization": `Bearer ${FALLBACK_API_KEY}`,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(fallbackBody)
                });
                if (!fallbackResponse.ok) throw new Error("備用 API 也無法使用");
                const fallbackData = await fallbackResponse.json();
                let fallbackContent = fallbackData.choices?.[0]?.message?.content?.trim() || '';
                fallbackContent = fallbackContent.replace(/<think\s*>.*?<\/think\s*>|<think\s*\/>|<think\s*>|<\/think\s*>/gis, '').trim();
                return fallbackContent;
            }
        }
    }
}


/**
 * 【全新函式】應用 Llama-3 驗證模型的內容與結構分數差距規則。
 * 規則：內容分和結構分的分差值不能高於1分。
 * 執行方式：如果分差大於1，則將較高的分數下調至「較低分+1」。
 * @param {object} scores - 從 Llama-3 模型解析出的原始評分物件。
 * @returns {object} - 經過規則調整後的評分物件。
 */
const applyContentStructureRule = (scores) => {
    // 建立一個分數物件的深層複本，避免影響原始數據
    let s = JSON.parse(JSON.stringify(scores));

    // 檢查 content 和 structure 分數是否存在
    if (s.content !== undefined && s.structure !== undefined) {
        const contentScore = s.content;
        const structureScore = s.structure;
        const difference = Math.abs(contentScore - structureScore);

        // 如果分數差距大於 1，則觸發調整機制
        if (difference > 1) {
            console.log(`觸發 Llama-3 內容/結構分差值規則：內容=${contentScore}, 結構=${structureScore}, 差值=${difference}`);
            
            // 判斷哪個分數較高，並將其下調
            if (contentScore > structureScore) {
                s.content = structureScore + 1; // 將內容分下調至「結構分+1」
                console.log(`調整後內容分數: ${s.content}`);
            } else { // structureScore > contentScore
                s.structure = contentScore + 1; // 將結構分下調至「內容分+1」
                console.log(`調整後結構分數: ${s.structure}`);
            }
        }
    }
    // 返回調整後（或無需調整）的分數物件
    return s;
};




/**
* Creates a beautiful bulleted list HTML from raw text content.
* @param {string} title - The title for the card (e.g., '點評', '建議').
* @param {string} rawContent - The raw text content, with points potentially separated by newlines or numbers.
* @returns {string} - The formatted HTML string.
*/
function createBulletedListHTML(title, rawContent) {
    // 【核心修訂】在處理文字前，先移除所有星號(*) Markdown 符號
    rawContent = rawContent.replace(/\*/g, '');

    // Attempt to split by numbered points first, e.g., "1. ...", "2. ..."
    let points = rawContent.split(/\s*(?=\d+\.\s*)/).map(p => p.trim()).filter(p => p);

    // If the primary split method results in 0 or 1 point, and the content has newlines,
    // it's likely not a numbered list. Fall back to splitting by newline.
    if (points.length <= 1 && rawContent.includes('\n')) {
        const newlinePoints = rawContent.split('\n').map(p => p.trim()).filter(p => p);
        // Only use the newline split if it gives us more than one point.
        if (newlinePoints.length > 1) {
            points = newlinePoints;
        }
    }

    // If there are no points to list, just show the content as a paragraph inside the card.
    if (points.length === 0) {
        return `<div class="rewrite-explanation-container">
    <div class="rewrite-explanation-card">
    <h3>${title}</h3>
    <div class="explanation-text">${rawContent.replace(/\n/g, '<br>')}</div>
    </div>
    </div>`;
    }

    let explanationHTML = `<div class="rewrite-explanation-container">
    <div class="rewrite-explanation-card">
    <h3>${title}</h3>`;

    points.forEach((point, index) => {
        let number = index + 1;
        let text = point;

        // Check if the point already starts with a number and a dot.
        const match = point.match(/^(\d+)\.?\s*(.*)$/s);
        if (match) {
            number = match[1]; // Use the number from the text.
            text = match[2]; // Use the text after the number.
        }

        explanationHTML += `<div class="explanation-point">
    <div class="explanation-number">${number}</div>
    <div class="explanation-text">${text.replace(/\n/g, '<br>')}</div>
    </div>`;
    });

    explanationHTML += `</div></div>`;
    return explanationHTML;
}



// 原 generateTopic() 函式
// 原 generateTopic() 函式 (已修訂：只生成題目，不調用 LLM)
function generateTopic(buttonElement) { 
    if (buttonElement) {
        updateButtonActiveState(buttonElement);
    }

    // 隱藏自訂題目輸入區，確保介面乾淨
    const customTopicArea = document.getElementById("customTopicArea");
    customTopicArea.style.display = "none";
    customTopicArea.innerHTML = "";

    const topicResult = document.getElementById("topicResult");
    topicResult.style.display = 'block';

    // 隨機抽選題目
    let selectedTopic;
    do {
        selectedTopic = topics[Math.floor(Math.random() * topics.length)];
    } while (selectedTopic === lastTopic && topics.length > 1);
    
    lastTopic = selectedTopic;
    localStorage.setItem("lastTopic", lastTopic);

    // 直接顯示題目 (不區分寫作類型，統一處理)
    topicResult.innerHTML = "<strong>" + selectedTopic + "</strong>";
    
    // 儲存狀態
    localStorage.setItem("currentTopic", selectedTopic);
    
    // 關鍵：清空之前的重點和情節設定，以免影響這次的評分
    localStorage.setItem("currentFocus", "");
    localStorage.setItem("currentPlot", "");
}

	
// 設定自訂題目（寫作）
function setCustomTopic() {
const writingType = document.getElementById("writingType").value;
const topicResult = document.getElementById("topicResult");

if (writingType === "片段描寫") {
// 【核心修訂】只檢查題目是否已輸入
const title = sanitizeHTML(document.getElementById("customTitle").value.trim());
if (!title) {
alert("請至少輸入自訂題目");
return;
}

// 獲取（可能是空的）重點和情節
const focus = document.getElementById("customFocus").value.trim();
const plot = document.getElementById("customPlot").value.trim();

// 即使 focus 和 plot 是空的，也正常生成顯示表格
// 這樣使用者可以清楚地看到他們輸入了什麼，沒輸入什麼
topicResult.innerHTML = `
<strong>${title}</strong>
<table>
<tr><th>結構段重點</th><th>情節大要</th></tr>
<tr><td>${focus || '<i>（未提供）</i>'}</td><td>${plot || '<i>（未提供）</i>'}</td></tr>
</table>
`;

// 儲存到 localStorage，空值也一併儲存
localStorage.setItem("currentTopic", title);
localStorage.setItem("currentFocus", focus);
localStorage.setItem("currentPlot", plot);

} else { 
const customTopic = sanitizeHTML(document.getElementById("customTopic").value.trim());
if (!customTopic) {
alert("請輸入自訂題目");
return;
}
topicResult.innerHTML = "<strong>" + customTopic + "</strong>";
localStorage.setItem("currentTopic", customTopic);
}

topicResult.style.display = 'block';

const customTopicArea = document.getElementById("customTopicArea");
customTopicArea.style.display = "none";
customTopicArea.innerHTML = "";
}
// 生成大綱表格
function generateOutlineTable() {
const structure = document.getElementById("structure").value;
let parts = structure === "fourPart" ? ["起", "承", "轉", "合"] : ["起", "一線", "二線", "三線", "合"];
let tableHTML = "<div class='table-container'><table><tr><th>部份</th><th>結構段重點</th><th>情節大要</th></tr>";
parts.forEach((part, index) => {
const focusId = structure + "Focus" + (index + 1);
const plotId = structure + "Plot" + (index + 1);
tableHTML += `<tr><td>${part}</td><td><textarea id="${focusId}" rows="3"></textarea></td><td><textarea id="${plotId}" rows="3"></textarea></td></tr>`;
});
tableHTML += "</table></div>";
document.getElementById("outlineTableArea").innerHTML = tableHTML;
}



// ==========================================
// === 修訂：解題指引提交函數 (移除藍色卡片版) ===
// ==========================================
async function submitWritingGuide() {
    const submitBtn = document.getElementById('submitWritingGuideBtn');
    const inputTopic = document.getElementById('writingGuideTopicInput').value.trim();
    const resultContainer = document.getElementById('writingGuideResultContainer');
    const introDiv = document.getElementById('guideIntro');
    const emotionsDiv = document.getElementById('guideEmotions'); // 雖然不顯示，但保留變數以免報錯
    const seedsDiv = document.getElementById('guideSeeds');
    const saveBtn = document.getElementById('save-guide-html-btn');

    // 聊天室相關元素
    const chatHistoryDiv = document.getElementById('writingGuideChatHistory');
    const chatInputContainer = document.getElementById('writingGuideChatInputContainer');

    if (!inputTopic) {
        alert("請輸入題目！");
        return;
    }

    submitBtn.disabled = true;
    submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 陳SIR正在分析中...';
    
    // 清空並顯示結果容器
    introDiv.innerHTML = "";
    if(emotionsDiv) emotionsDiv.innerHTML = ""; // 清空藍色卡片區
    seedsDiv.innerHTML = "";
    resultContainer.style.display = "block";
    saveBtn.style.display = 'none';

    // 重置聊天室狀態
    chatHistoryDiv.innerHTML = "";
    chatHistoryDiv.style.display = "none";
    chatInputContainer.style.display = "none";
    writingGuideChatHistoryData = [];
    currentGuideTopic = inputTopic;

    // === 修改後的 Prompt：移除了 [EMOTION] 的要求 ===
    const prompt = `你是一位深諳中國文學的寫作顧問。使用者輸入題目：「${inputTopic}」。

請模仿以下【示例】的風格、深度和語氣，為這個題目撰寫「題眼分析」及「寫作方向」。
在「題眼分析」，用語要求準確、理性、非文學化，而在「寫作方向」，你的輸出必須文學化、感性。
**嚴禁**使用「你好」、「我們來看看」等開場白，直接輸出內容。
**嚴禁**使用 1. 2. 3. 等數字列表，請嚴格遵守下方的【輸出格式】標籤。

【任務要求】
1. **題眼分析**：
   - 分析題眼的意思，做非文學性、貼近日常生活的釋義，約150-200字。
2. **寫作方向**：
   - 提供 3 個具體的「故事種子」。
   - 每個種子包含：標題、情境（具體畫面）、張力（為何扣連題目）。

【輸出格式 (請嚴格遵守分隔符)】
[INTRO]
(這裡填寫題眼分析與詞語關係分析...)
[SEED]
(故事種子標題 1)
情境：(具體畫面描述...)
張力：(解釋為何扣題...)
[SEED]
(故事種子標題 2)
情境：(具體畫面描述...)
張力：(解釋為何扣題...)
[SEED]
(故事種子標題 3)
情境：(具體畫面描述...)
張力：(解釋為何扣題...)
`;

    try {
        const response = await callAPI(prompt);
        currentGuideAnalysis = response; // 儲存上下文

        // === 修改後的解析邏輯：直接分割 INTRO 和 SEED ===
        // 1. 解析 Intro (取 [INTRO] 後面，[SEED] 前面的內容)
        let introContent = "";
        const introSplit = response.split('[INTRO]');
        if (introSplit.length > 1) {
            introContent = introSplit[1].split('[SEED]')[0].trim();
        }

        // 2. 解析 Seeds (取 [SEED] 後面的內容)
        const seedParts = response.split('[SEED]').slice(1).map(p => p.trim());

        // 渲染 Intro (純文字分析)
        if (introContent) {
            introDiv.innerHTML = `<p>${introContent.replace(/\n/g, '<br>')}</p>`;
        }

        // 渲染 Seeds (綠色卡片)
        if (seedParts.length > 0) {
            let seedsHTML = "";
            seedParts.forEach(part => {
                const lines = part.split('\n').filter(l => l.trim());
                // 移除可能的 Markdown 符號
                const title = (lines[0] || "故事種子").replace(/\*\*/g, '');
                
                // 剩下的部分皆為內容
                const contentText = lines.slice(1).join('\n');
                
                let situation = "內容解析中...";
                let contradiction = "內容解析中...";
                
                const cleanContent = contentText.replace(/\*\*/g, ''); 
                
                // 嘗試分割「情境」與「張力」
                const parts = cleanContent.split(/(?:張力|矛盾)[:：]/);
                
                if (parts.length > 1) {
                    situation = parts[0].replace(/^(?:情境|情景)[:：]\s*/, '').trim();
                    contradiction = parts[1].trim();
                } else {
                    situation = cleanContent;
                    contradiction = "";
                }

                seedsHTML += `
                <div class="guide-card seed-card">
                    <div class="seed-header">${title}</div>
                    <div class="seed-body">
                        <p><strong><i class="fas fa-image"></i> 情境：</strong></p>
                        <p>${situation.replace(/\n/g, '<br>')}</p>
                        <hr style="border:0; border-top:1px dashed #ddd; margin: 10px 0;">
                        <p><strong><i class="fas fa-bolt"></i> 張力：</strong></p>
                        <p>${contradiction.replace(/\n/g, '<br>')}</p>
                    </div>
                </div>`;
            });
            seedsDiv.innerHTML = seedsHTML;

// --- 新增：儲存解題指引 ---
   const fullGuideHTML = `<div class="guide-intro-card">${introDiv.innerHTML}</div><div class="guide-grid-3">${seedsDiv.innerHTML}</div>`;
saveToHistory("敘事抒情", "解題指引", inputTopic, `題目：${inputTopic}`, fullGuideHTML);
			
        }
        
        saveBtn.style.display = 'flex';
        
        // 顯示聊天介面
        chatHistoryDiv.style.display = "flex";
        chatInputContainer.style.display = "flex";

    } catch (error) {
        console.error("解題指引生成失敗:", error);
        introDiv.innerHTML = `<p style="color:red;">生成失敗，請稍後再試。<br>錯誤訊息: ${error.message}</p>`;
    } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = '提交分析';
    }
}

// ==========================================
// === 修訂：解題指引聊天室互動函數 (修復失憶問題) ===
// ==========================================
async function continueWritingGuideDiscussion() {
    const continueBtn = document.getElementById('continueWritingGuideBtn');
    continueBtn.disabled = true;

    const userInputText = sanitizeHTML(document.getElementById("writingGuideUserInput").value.trim());
    if (!userInputText) {
        alert("請輸入您的回應");
        continueBtn.disabled = false;
        return;
    }
    
    const chatHistoryDiv = document.getElementById('writingGuideChatHistory');
    
    // 1. 顯示使用者訊息
    const userMessageBubble = document.createElement('div');
    userMessageBubble.className = 'message-bubble user-message';
    userMessageBubble.textContent = userInputText;
    chatHistoryDiv.appendChild(userMessageBubble);
    
    // 2. 將使用者訊息存入歷史紀錄
    writingGuideChatHistoryData.push({ sender: 'user', message: userInputText });
    document.getElementById("writingGuideUserInput").value = "";
    chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;

    // 3. 顯示 AI 正在回應
    const aiMessageBubble = document.createElement('div');
    aiMessageBubble.className = 'message-bubble ai-message';
    aiMessageBubble.textContent = `陳SIR正在回應...`;
    chatHistoryDiv.appendChild(aiMessageBubble);
    chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;

    // 4. 準備對話歷史文字 (去除 HTML 標籤，讓 AI 讀得更清楚)
    // 這裡我們把之前的對話整理成純文字格式
    const conversationHistoryForPrompt = writingGuideChatHistoryData.map(item => {
        const role = item.sender === 'user' ? '學生' : '陳SIR';
        // 簡單去除 HTML 標籤以防干擾 Prompt
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = item.message;
        const cleanMessage = tempDiv.textContent || tempDiv.innerText || "";
        return `${role}: ${cleanMessage}`;
    }).join('\n');

    // 5. 準備 Prompt (核心修正：加入指引上下文)
    const prompt = `
    【角色設定】
    你是一位高中中文科老師「陳SIR」，你剛剛為學生分析了作文題目：「${currentGuideTopic}」。
    你的語氣親切、有見地，善於用具體的例子或生活化的比喻來引導學生深入思考，而不是只給空泛的理論。

    【背景資料：你剛才生成的解題指引內容】
    (請基於此內容回答學生的問題，不要忘記你剛剛提出的觀點)
    ---
    ${currentGuideAnalysis}
    ---

    【我們剛才的對話紀錄】
    ${conversationHistoryForPrompt}

    【學生的最新追問】
    ${userInputText}

    【你的任務】
    請針對學生的最新追問進行回應。
    1. 必須緊扣你剛才生成的「解題指引」內容（例如你提到的情感特質或故事種子）。
    2. 不要使用括號解釋你的目的。
    3. 請用完整句子回應，字數控制在 200 字以內。
    `;

   try {
    const aiResponse = await callAPI(prompt);
    // 添加這段檢查代碼
    if (!aiResponse || typeof aiResponse !== 'string') {
        throw new Error('API 傳回無效回應');
    }
    
    // 6. 更新 UI (將 Markdown 粗體轉為 HTML)
    let formattedResponse = aiResponse.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    formattedResponse = formattedResponse.replace(/\n/g, '<br>');
    aiMessageBubble.innerHTML = formattedResponse;
    
    // 存入歷史
    writingGuideChatHistoryData.push({ sender: 'ai', message: aiResponse });
} catch (error) {
    console.error("繼續指引討論時出錯:", error);
    aiMessageBubble.textContent = error.message.includes("API") ? `今日 API 調用次數已用完。😓` : `抱歉，陳SIR無法回應。😅`;
} finally {
    chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
    continueBtn.disabled = false;
}
}
async function submitWriting() {
    const submitBtn = document.getElementById('submitWritingBtn');
    submitBtn.disabled = true;
    hideAllSaveHtmlButtons();

    const writingGradingResultDiv = document.getElementById("writingGradingResult");
    const writingChatHistoryDiv = document.getElementById("writingChatHistory");
    const writingChatInputContainerDiv = document.getElementById("writingChatInputContainer");
    
    writingGradingResultDiv.innerHTML = "";
    writingChatHistoryDiv.innerHTML = "";
    writingChatHistoryDiv.style.display = "none";
    writingChatInputContainerDiv.style.display = "none";
    writingChatHistoryData = [];

    try {
        const reviewerSelect = document.getElementById('writingReviewer');
        if (reviewerSelect) {
            const selectedReviewerText = reviewerSelect.options[reviewerSelect.selectedIndex].text;
            currentReviewerName = selectedReviewerText.replace(/\s*\(預設\)\s*/, '');
        } else {
            currentReviewerName = "陳SIR";
        }

        const writingType = document.getElementById("writingType").value;
        const topic = localStorage.getItem("currentTopic");
        if (!topic) {
            alert("請先設定題目");
            submitBtn.disabled = false;
            return;
        }

        let content = "";
        let prompt = "";
        const tone = document.getElementById("writingTone").value;

        if (writingType === "大綱" || writingType === "敘事物象") {
            // (大綱和敘事物象的邏輯不變)
             if (writingType === "大綱") {
                const toneNoteForOutline = tone === "chen" ? "請用輕鬆隨意的語氣進行點評和建議，多用EMOJI，偶爾使用網絡用語，用語要日常生活化一點。如果用戶表現良好，請大加讚賞；如果用戶表現不好，可以善意地揶揄一下，但要注意尺度，不能傷害用戶的自尊心。揶揄時，可運用生活化的比喻。" : "請用嚴肅正經的語氣進行點評和建議。";
              const structure = document.getElementById("structure").value;
                const parts = structure === "fourPart" ? ["起", "承", "轉", "合"] : ["起", "一線", "二線", "三線", "合"];
                content = parts.map((part, index) => {
                    const focusId = structure + "Focus" + (index + 1);
                    const plotId = structure + "Plot" + (index + 1);
                    const focus = document.getElementById(focusId)?.value.trim() || "";
                    const plot = document.getElementById(plotId)?.value.trim() || "";
                    if (!focus || !plot) throw new Error("請填寫所有大綱表格");
                    return { part, focus, plot };
                });
                const note = categories["大綱"].commentNote;
                prompt = `請根據以下大綱內容進行點評和建議，並提供改寫後的大綱。要求：
1. 在「=== 點評及建議 ===」部分，為每個結構段提供點評和建議。使用「[part]」標記每個結構段的開始，例如「[起]」，然後在下一行「點評：」後跟點評內容，再下一行「建議：」後跟建議內容。
2. 在「=== 改寫後的大綱 ===」部分，為每個結構段提供改寫後的「結構段重點」和「情節大要」。使用「[part]」標記每個結構段的開始，然後在下一行「結構段重點：」後跟內容，再下一行「情節大要：」後跟內容。
3. 在「=== 改寫說明 ===」部分，提供不超過兩點的改寫說明，每點以「1. 」和「2. 」開始。
4. 請確保內容簡潔明了，不可以顯示「--- ###」。
題目：${topic}
大綱結構：${structure === "fourPart" ? "起承轉合" : "三線（起、一線、二線、三線、合）"}
用戶輸入的大綱：
| 部份 | 結構段重點 | 情節大要 |
|------|------------|----------|
${content.map(item => `| ${item.part} | ${item.focus} | ${item.plot} |`).join("\n")}
教學筆記：${note}
點評及建議語氣：${toneNoteForOutline}`;
                 document.getElementById("commentResult").innerHTML = "陳SIR正在點評...";
                const response = await callAPI(prompt, 0);
               displayOutlineComment(response, content);

                // ★★★ 修正：將結構代碼 (fourPart) 轉為中文 (起承轉合) ★★★
                const structureName = structure === "fourPart" ? "起承轉合" : "三線";
                saveToHistory("敘事抒情", "大綱點評", topic, `題目：${topic}\n結構：${structureName}`, document.getElementById("commentResult").innerHTML);
// 大綱通常沒有 Canvas，直接存 innerHTML 即可，或者用 captureContainerHTML('commentResult') 也可以
            } else { // 敘事物象
                content = document.getElementById("narrativeElements").value.trim();
                const note = categories["敘事物象"].commentNote;
                prompt = `請根據以下題目和取材/故事背景生成五十個不重複且相關的物象。要求：
1. 物象必須與題目和取材/故事背景緊密相關。
2. 物象應多樣化且生動，能夠增強故事的真實感和情感表達。
3. 請以列表形式呈現，每個物象佔一行。
4. 請確保物象不重複且排版整齊。
題目：${topic}
取材/故事背景：${content || "無具體背景，根據題目生成"}
教學筆記：${note}`;
                document.getElementById("commentResult").innerHTML = "陳SIR正在點評...";
                const response = await callAPI(prompt, 0);
                const elements = response.split("\n").map(item => item.trim()).filter(item => item);
                let elementsHTML = "<h3>生成的物象（50項）：</h3><ul>";
                elements.forEach(element => elementsHTML += `<li>${element}</li>`);
                elementsHTML += "</ul>";
                document.getElementById("commentResult").innerHTML = elementsHTML;
// --- 新增：儲存敘事物象 ---
  saveToHistory("敘事抒情", "敘事物象", topic, `題目：${topic}\n取材：${content}`, elementsHTML);
				 
            }
            document.getElementById('save-writing-html-btn').style.display = 'flex';

        } else { // 片段描寫 (文章點評)
            content = document.getElementById("writingContent").value.trim();
            if (!content) {
                alert("請先輸入寫作內容");
                submitBtn.disabled = false;
                return;
            }
            currentWritingArticle = content;

            const selectedScopes = Array.from(document.querySelectorAll('input[name="reviewScope"]:checked')).map(cb => cb.value);
            const isFullReview = selectedScopes.includes("全部") || selectedScopes.length === 0;

            if (isFullReview) {
                writingGradingResultDiv.innerHTML = `${currentReviewerName}正在點評...`;

                const focus = localStorage.getItem("currentFocus");
                const plot = localStorage.getItem("currentPlot");
                const note = categories["片段描寫"].commentNote;
                const reviewer = document.getElementById('writingReviewer').value;
                const reviewerNote = narrativeReviewerPreferences[reviewer] || "評分取向：平衡看待所有標準。";
                
                // =====================================================================
                // === 【全新修訂】敘事抒情文評分指令 (V3 - 評分主導模式) ===
                // =====================================================================
                const narrativeScoreFirstPrompt = `你將扮演一位極其嚴謹且客觀的中文科AI評卷員。你的工作流程被嚴格限定為「先評分，後解釋」。

### 你的工作流程 (必須嚴格遵守，不得顛倒)

1.  **首要任務：量化評分**: 你的第一個動作是，根據下方提供的詳細「評分準則」，對文章的各個維度進行獨立的、客觀的數字評分 (0-10分)。你必須將所有分數結果，完整地填寫在 <grading_json> 標籤內。**此步驟必須在撰寫任何文字評語之前完成。**

2.  **次要任務：撰寫理據**: 在你完成 <grading_json> 的所有評分後，你的第二個動作是，根據你剛剛給出的分數，去撰寫 <critique>, <suggestions>, 和 <rewrite_example> 的內容。你的所有文字評語，都**必須**是為了**解釋和支撐**你已經給出的分數。
    -   **範例**：如果你在 <grading_json> 中給予「立意」8分的高分，那麼你的 <critique> 就必須具體解釋這篇文章的立意為何深刻、在哪個方面超越了普通水平。反之，如果你給了低分，就必須指出其立意膚淺或陳腐之處。

### 核心評分準則 (用於步驟一的量化評分)
- **偏題的後果**: 如果文章內容與題目無關，在評分時，「扣題」分數 **絕不能高於4分**，「內容」和「結構」的總分也 **不能高於4分**。

---
### 你的輸出格式 (必須嚴格遵守此結構與順序)

<grading_json>
[**分數量化步驟**：根據「核心評分準則」，客觀地為以下所有項目評分。]
{
"content": [0-10的整數],
"expression": [0-10的整數],
"structure": [0-10的整數],
"radar": {
"立意": [0-10], "取材": [0-10], "扣題": [0-10],
"詳略": [0-10], "詞彙": [0-10], "文學性": [0-10]
}
}
</grading_json>

<critique>
[根據你在 <grading_json> 中給出的分數，以數字編號列點方式，撰寫2-3點核心評論來解釋這些分數的由來。]
</critique>

<suggestions>
[針對 <critique> 中指出的問題，提出具體的改善建議。]
</suggestions>

<rewrite_example>
[提供一段約150字內的高質素改寫範例，展示更高分的作品應有的水準。]
</rewrite_example>`;
                // =====================================================================
                // === 修訂結束 ===
                // =====================================================================
                
                if (tone === "chen") {
                     prompt = `你將扮演「陳SIR」，一位風格幽默、要求極高的中文老師。請嚴格按照以下「先評分，後解釋」的流程，對學生的敘事抒情文進行點評。
${narrativeScoreFirstPrompt}
---
### 待點評的資料
題目：${topic}
結構段重點：${focus}
情節大要：${plot}
寫作內容：${content}
教學筆記：${note}
閱卷員評分取向：${reviewerNote}`;
                } else {
                    prompt = `你是一位嚴格的中文科閱卷員。請嚴格按照以下「先評分，後解釋」的流程，對學生的敘事抒情文進行點評。
${narrativeScoreFirstPrompt}
---
### 待點評的資料
題目：${topic}
結構段重點：${focus}
情節大要：${plot}
寫作內容：${content}
教學筆記：${note}
閱卷員評分取向：${reviewerNote}`;
                }
                
                const [originalApiResponse, llama3ApiResponse] = await Promise.all([callAPI(prompt, 0), callLlama3API(prompt, 0)]);
                await displayFullCommentWithGrading('writingGradingResult', originalApiResponse, llama3ApiResponse, 'narrative', content);
                
                const critiqueMatch = originalApiResponse.match(/<critique>([\s\S]*?)<\/critique>/);
                const suggestionsMatch = originalApiResponse.match(/<suggestions>([\s\S]*?)<\/suggestions>/);
                const rewriteMatch = originalApiResponse.match(/<rewrite_example>([\s\S]*?)<\/rewrite_example>/);
                let initialReviewHTML = "";
                if (critiqueMatch?.[1]) initialReviewHTML += createBulletedListHTML("點評", critiqueMatch[1].trim());
                if (suggestionsMatch?.[1]) initialReviewHTML += createBulletedListHTML("建議", suggestionsMatch[1].trim());
                if (rewriteMatch?.[1]) initialReviewHTML += `<div class="rewrite-explanation-container"><div class="rewrite-explanation-card"><h3>改寫範例</h3><p>${rewriteMatch[1].trim().replace(/\n/g, '<br>')}</p></div></div>`;
                currentWritingReview = initialReviewHTML; 
                document.getElementById('save-writing-html-btn').style.display = 'flex';

            } else {
                // (聚焦式點評的邏輯)
                writingGradingResultDiv.innerHTML = `${currentReviewerName}正在點評...`;

                // 【新增】為敘事抒情文的聚焦式點評定義各範疇的具體任務
                const scopeDefinitions = `
- **扣題**: 嚴謹地對比題目《${topic}》及文章內容，點評文章在情節和主旨上是否緊密圍繞題目關鍵詞展開。
- **立意**: 先嚴謹地對比題目《${topic}》及文章內容，點評是否扣題，繼而再評估文章的主題思想是否深刻、新穎，能否從個人經歷昇華至更普世的感悟或哲理。
- **取材**: 先嚴謹地對比題目《${topic}》及文章內容，點評是否扣題，繼而再檢視所選取的事例、情節是否典型、生動、具體，能否有效支撐立意。
- **詳略**: 先嚴謹地對比題目《${topic}》及文章內容，點評是否扣題，繼而再分析文章的敘事節奏，核心情節是否得到充分的細節描寫，次要或過渡性內容是否做到簡潔交代。
- **文筆**: 先嚴謹地對比題目《${topic}》及文章內容，點評是否扣題，繼而再評論文章的語言運用是否精準、生動，遣詞造句是否流暢，句式是否有變化，以及是否有效地運用描寫或修辭手法來增強文章的感染力。
`;

                // 【修訂】將範疇定義整合進指令中
                let scopeInstruction = `
你是一名高度專業的寫作分析員，你的任務極其專一。

---
### **黃金法則 (ABSOLUTE CORE DIRECTIVE)**
你必須嚴格遵守此法則，不得有任何例外：
1.  **絕對聚焦**: 你的點評和建議中的 **每一個字**，都必須 **僅僅** 與用戶選擇的以下範疇相關：**【${selectedScopes.join("、")}】**。
2.  **明確禁止**: 你被 **嚴格禁止** 提及任何其他寫作方面。例如，如果用戶選擇了「立意」，你絕對不能評論「文筆」、「取材」或「詳略」。
3.  **後果**: 如果你的回應中包含了任何未被選定的範疇，整個回應將被視為失敗。

### **各範疇的定義 (你的分析框架)**
${scopeDefinitions}
---
`;

                if (tone === "chen") {
                    prompt = `你將扮演「陳SIR」，一位眼光獨到、要求嚴格但風格幽默的中文老師。
${scopeInstruction}
### **你的任務與輸出格式**
你的輸出必須包含以下兩個XML標籤，不得有其他內容。
【重要禁令】：在<critique>, <suggestions>的文字內容中，絕對禁止使用任何Markdown語法。

<critique>
[根據「黃金法則」，給出1-2點核心評論。記住，你的每一點評論都必須嚴格對應用戶選擇的範疇。]
</critique>
<suggestions>
[在建議部分，同樣要遵循「黃金法則」。如果所選範疇表現優秀，你可以說「在這方面處理得很好，沒什麼好建議了，繼續保持吧！😎」。]
</suggestions>
---
### **待點評的資料**
題目：${topic}
寫作內容：${content}`;
                } else {
                    prompt = `你是一位要求嚴格、具備專業眼光的中文科閱卷員。
${scopeInstruction}
### **你的任務與輸出格式**
你的輸出必須包含以下兩個XML標籤，不得有其他內容。
【重要禁令】：在<critique>, <suggestions>的文字內容中，絕對禁止使用任何Markdown語法。

<critique>
[根據「黃金法則」，給出1-2點核心評論。記住，你的每一點評論都必須嚴格對應用戶選擇的範疇。]
</critique>
<suggestions>
[針對點評中提出的問題，提出具體的改善建議，同樣要遵循「黃金法則」。若所選範疇表現極佳，可註明「在此範疇的表現出色，建議保持現有水準。」]
</suggestions>
---
### **待點評的資料**
題目：${topic}
寫作內容：${content}`;
                }

                const response = await callAPI(prompt, 0);
                const critiqueMatch = response.match(/<critique>([\s\S]*?)<\/critique>/);
                const suggestionsMatch = response.match(/<suggestions>([\s\S]*?)<\/suggestions>/);
                let initialReviewHTML = "";
                if (critiqueMatch?.[1]) initialReviewHTML += createBulletedListHTML("點評", critiqueMatch[1].trim());
                if (suggestionsMatch?.[1]) initialReviewHTML += createBulletedListHTML("建議", suggestionsMatch[1].trim());
                if (!initialReviewHTML) {
                    initialReviewHTML = "抱歉，無法根據您選擇的範疇生成點評，請重試。";
                }
                
                writingGradingResultDiv.innerHTML = initialReviewHTML;
                currentWritingReview = initialReviewHTML;
                writingChatHistoryData.push({ sender: 'ai', message: currentWritingReview });
                document.getElementById('save-writing-html-btn').style.display = 'none';
            }

            writingChatHistoryDiv.style.display = "flex";
            writingChatInputContainerDiv.style.display = "flex";
        }
    } catch (error) {
        console.error("提交寫作時出錯:", error);
        alert(error.message.includes("API") ? "今日 API 調用次數已用完或API無法連接，請明天再試" : (error.message || "點評生成失敗，請重試"));
        writingGradingResultDiv.innerHTML = "";
        document.getElementById("commentResult").innerHTML = "";
    } finally {
        submitBtn.disabled = false;
    }
}


// 輔助函式，用於顯示大綱的評論 (從 submitWriting 中提取出來)
function displayOutlineComment(response, content) {
    const sections = response.split(/=== (.+?) ===/).filter(s => s.trim());
    const commentIndex = sections.indexOf("點評及建議");
    const rewriteIndex = sections.indexOf("改寫後的大綱");
    const explanationIndex = sections.indexOf("改寫說明");
    const commentPart = commentIndex !== -1 ? sections[commentIndex + 1] : "";
    const rewritePart = rewriteIndex !== -1 ? sections[rewriteIndex + 1] : "";
    const explanationPart = explanationIndex !== -1 ? sections[explanationIndex + 1].trim() : "";

    function parseCommentPart(commentPart) {
        const comments = {};
        const regex = /\[(.+?)\]\s*點評：\s*(.+?)(?=\s*建議：|\s*\[|$)/gs;
        const suggestionRegex = /\[(.+?)\]\s*點評：.+?\s*建議：\s*(.+?)(?=\s*\[|$)/gs;
        let match;
        while ((match = regex.exec(commentPart)) !== null) {
            const part = match[1];
            comments[part] = comments[part] || {};
            comments[part].comment = match[2].trim();
        }
        while ((match = suggestionRegex.exec(commentPart)) !== null) {
            const part = match[1];
            comments[part] = comments[part] || {};
            comments[part].suggestion = match[2].trim();
        }
        return comments;
    }

    function parseRewritePart(rewritePart) {
        const rewrites = {};
        const regex = /\[(.+?)\]\s*結構段重點：\s*(.+?)(?=\s*情節大要：|\s*\[|$)/gs;
        const plotRegex = /\[(.+?)\]\s*結構段重點：.+?\s*情節大要：\s*(.+?)(?=\s*\[|$)/gs;
        let match;
        while ((match = regex.exec(rewritePart)) !== null) {
            const part = match[1];
            rewrites[part] = rewrites[part] || {};
            rewrites[part].focus = match[2].trim();
        }
        while ((match = plotRegex.exec(rewritePart)) !== null) {
            const part = match[1];
            rewrites[part] = rewrites[part] || {};
            rewrites[part].plot = match[2].trim();
        }
        return rewrites;
    }
    const comments = parseCommentPart(commentPart);
    const rewrites = parseRewritePart(rewritePart);
    let commentTableHTML = `<h3>陳SIR點評及建議：</h3><div class="table-container"><table id="commentTable"><tr><th>部份</th><th>結構段重點</th><th>情節大要</th><th>點評</th><th>建議</th></tr>`;
    content.forEach(item => {
        const comment = comments[item.part]?.comment || "未生成點評";
        const suggestion = comments[item.part]?.suggestion || "未生成建議";
        commentTableHTML += `<tr><td>${item.part}</td><td>${item.focus}</td><td>${item.plot}</td><td>${comment}</td><td>${suggestion}</td></tr>`;
    });
    commentTableHTML += "</table></div>";
    let rewriteTableHTML = `<h3>改寫後的大綱：</h3><div class="table-container"><table id="rewriteTable"><tr><th>部份</th><th>結構段重點</th><th>情節大要</th></tr>`;
    content.forEach(item => {
        const rewrite = rewrites[item.part] || { focus: "未生成結構段重點", plot: "未生成情節大要" };
        rewriteTableHTML += `<tr><td>${item.part}</td><td>${rewrite.focus || "未生成結構段重點"}</td><td>${rewrite.plot || "未生成情節大要"}</td></tr>`;
    });
    rewriteTableHTML += "</table></div>";
    let explanationHTML = '';
    if (explanationPart) {
        const points = explanationPart.split(/\s*(?=\d\.\s*)/).filter(p => p.trim());
        explanationHTML = `<div class="rewrite-explanation-container"><div class="rewrite-explanation-card"><h3>改寫說明</h3>`;
        points.forEach(point => {
            const match = point.match(/^(\d)\.\s*(.*)$/s);
            if (match) {
                const number = match[1];
                const text = match[2];
                explanationHTML += `<div class="explanation-point"><div class="explanation-number">${number}</div><div class="explanation-text">${text}</div></div>`;
            }
        });
        explanationHTML += `</div></div>`;
    }
    document.getElementById("commentResult").innerHTML = commentTableHTML + rewriteTableHTML + explanationHTML;
}

// 替換舊的 submitReading 函式 (修正歷史紀錄儲存問題)
async function submitReading() {
    const submitBtn = document.getElementById('submitReadingBtn');
    submitBtn.disabled = true; 
    hideAllSaveHtmlButtons();

    // 定義變數在 try 區塊外部，以便在需要時存取
    let readingFunction = "";
    let passage = "";
    let question = "";
    let studentAnswer = "";
    let finalHTML = ""; // 用於點評結果
    let guideHTML = ""; // 用於指引結果

    try {
        readingFunction = document.getElementById("readingFunction").value;
        passage = document.getElementById("readingPassage").value.trim();
        question = document.getElementById("readingQuestion").value.trim();

        if (readingFunction === "comment") {
            studentAnswer = document.getElementById("studentAnswer").value.trim();
            if (!passage || !question || !studentAnswer) {
                alert("請填寫所有閱讀輸入");
                return;
            }
        } else {
            if (!passage || !question) {
                alert("請填寫閱讀篇章和題目");
                return; 
            }
        }

        let toneNote = "";
        if (readingFunction === "comment") {
            const tone = document.getElementById("readingTone").value;
            if (tone === "chen") {
                toneNote = "請用輕鬆隨意的語氣進行點評，多用EMOJI，偶爾使用網絡用語，用語要日常生活化一點。如果用戶表現不好，可以善意地揶揄一下，但要注意尺度，不能傷害用戶的自尊心。";
            } else {
                toneNote = "請用嚴肅正經的語氣進行點評。";
            }
        }

        const note = readingFunction === "comment" ? categories["閱讀"].commentNote : categories["閱讀"].guideNote;

        let prompt = "";
        if (readingFunction === "comment") {
            prompt = `請根據以下閱讀篇章、題目和學生的答案進行點評。要求：
1. 評估答題方向是否合理
2. 評估文本依據是否充實具體
3. 評估闡釋推論是否嚴謹
4. 評估主題句是否清晰
5. 在「### 點評」部分，請務必以數字編號的列點方式臚列你的評論，每個點評另起新行。你可以根據文章內容提出任意數量的點評，必須超過一點，但絕對不得超過三點，每點字數不要太長。
6. 在「### 答題步驟及思路」中，描述各部分方向，步驟因題制宜，不超出120字。只有【鋪墊】、【主題句】、【文本依據】、【闡釋】四種標題，每個步驟之間都必須隔兩行空行，步驟中不得列點。
7. 在「### 改寫範例」中，提供改寫後的答案，使答案更圓足（若答題方向錯誤，則不跟從錯誤方向）
8. 不要使用任何表格或Markdown格式。
9. 輸出分為三個部分：### 點評、### 答題步驟及思路、### 改寫範例
閱讀篇章：${passage}
題目：${question}
學生的答案：${studentAnswer}
教學筆記：${note}
點評語氣：${toneNote}`;
        } else { // guide
            prompt = `請根據以下閱讀篇章和題目生成答題指引。要求：
1. 輸出必須包含「### 答題指引」和「### 答題詞匯」兩個部分。
2. 在「### 答題指引」部分，請生成三道引導性問題，每道問題都以數字和句號（例如「1.」）開頭，並另起新行。
3. 在「### 答題詞匯」部分，生成十五個由兩個字構成的相關詞彙，每個詞彙另起新行。
4. 所有內容均以純文字列表形式呈現，不要使用任何表格或Markdown格式。
閱讀篇章：${passage}
題目：${question}
教學筆記：${note}`;
        }

        document.getElementById("readingResult").innerHTML = "陳SIR正在思考...";
        const result = await callReadingAPI(prompt);

        if (readingFunction === "comment") {
            const parts = result.split("###").map(part => part.trim()).filter(part => part);
            finalHTML = "<h3>陳SIR點評：</h3>";

            parts.forEach(part => {
                const lines = part.split("\n").filter(line => line.trim());
                const title = lines.shift() || "";
                const content = lines.join("\n");

                if (title.includes("點評")) {
                    finalHTML += createBulletedListHTML(title, content);
                } 
                else if (title.includes("答題步驟及思路")) {
                    finalHTML += `<div class="rewrite-explanation-container">
                    <div class="rewrite-explanation-card">
                    <h3>${title}</h3>
                    <div class="steps-container">`;
                    const steps = content.split(/\s*(?=【.*?】)/).filter(s => s.trim());
                    steps.forEach(stepText => {
                        const match = stepText.match(/^(【.*?】)(.*)$/s);
                        if (match) {
                            const stepTitle = match[1].trim();
                            const stepContent = match[2].trim().replace(/\n/g, '<br>');
                            finalHTML += `<div class="step-card">
                            <div class="step-title">${stepTitle}</div>
                            <div class="step-content">${stepContent}</div>
                            </div>`;
                        }
                    });
                    finalHTML += `</div></div></div>`;
                }
                else {
                    finalHTML += `<div class="rewrite-explanation-container">
                    <div class="rewrite-explanation-card">
                    <h3>${title}</h3>
                    <div class="explanation-text">${content.replace(/\n/g, '<br>')}</div>
                    </div>
                    </div>`;
                }
            });
            
            document.getElementById("readingResult").innerHTML = finalHTML;
            
            // ★★★ 修正：確保在成功生成 HTML 後立即儲存「點評」 ★★★
            saveToHistory("閱讀", "點評", question, `篇章：${passage}\n題目：${question}\n答案：${studentAnswer}`, finalHTML);
            
            document.getElementById('save-reading-html-btn').style.display = 'flex';

        } else { // guide
            const guideParts = result.split("###").map(part => part.trim()).filter(part => part);
            guideHTML = "<h3>陳SIR指引：</h3>";

            guideParts.forEach(part => {
                const lines = part.split("\n").filter(line => line.trim());
                const title = lines.shift() || "";
                const listItems = lines;

                guideHTML += `<div class="rewrite-explanation-container">
                <div class="rewrite-explanation-card">
                <h3>${title}</h3>`;

                if (title.includes("答題指引")) {
                    listItems.forEach((item, index) => {
                        const match = item.match(/^(\d+)\.?\s*(.*)$/);
                        const number = match ? match[1] : index + 1;
                        const text = match ? match[2].trim() : item;
                        guideHTML += `<div class="explanation-point">
                        <div class="explanation-number">${number}</div>
                        <div class="explanation-text">${text}</div>
                        </div>`;
                    });
                } 
                else if (title.includes("答題詞匯")) {
                    listItems.forEach(item => {
                        guideHTML += `<div class="explanation-point">
                        <div class="explanation-text">${item}</div>
                        </div>`;
                    });
                } else {
                    guideHTML += `<p>${listItems.join('<br>')}</p>`;
                }
                guideHTML += `</div></div>`;
            });
            
            document.getElementById("readingResult").innerHTML = guideHTML;
            
            // ★★★ 修正：確保在成功生成 HTML 後立即儲存「指引」 ★★★
            // 原本的代碼將這行錯誤地放在了 catch 區塊中
            saveToHistory("閱讀", "指引", question, `篇章：${passage}\n題目：${question}`, guideHTML);
            
            document.getElementById('save-reading-html-btn').style.display = 'flex';
        }

    } catch (error) {
        console.error("提交閱讀時出錯:", error);
        if (error.message === "所有 API 密鑰均無法使用") {
            alert("今日 API 調用次數已用完或API無法連接，請明天再試");
        } else {
            alert("生成失敗，請重試");
        }
        document.getElementById("readingResult").innerHTML = "";
        // 移除 catch 區塊中錯誤的儲存邏輯
    } finally {
        submitBtn.disabled = false;
    }
}

// 課外書籍討論功能
let chatHistory = [];
let bookTitle = "";
let author = "";
let discussionQuestion = "";
let booksTone = "";

// 將訊息渲染到畫面上
function renderMessage(sender, message) {
const chatHistoryDiv = document.getElementById("chatHistory");
const element = document.createElement("div");

if (sender === "info") {
element.className = "discussion-info";
element.innerHTML = message;
} else {
element.className = `message-bubble ${sender}-message`;
element.innerHTML = message; // innerHTML to render formatted text
if (sender === "ai" && message === "陳SIR正在回應...") {
element.id = "ai-loading";
}
}
chatHistoryDiv.appendChild(element);
chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
}

// 將訊息加入歷史紀錄並渲染
function addMessageToHistory(sender, message) {
chatHistory.push({ sender, message });
renderMessage(sender, message);
}


async function startDiscussion() {
const startBtn = document.getElementById('startDiscussionBtn');
startBtn.disabled = true;

try {
bookTitle = sanitizeHTML(document.getElementById("bookTitle").value.trim());
author = sanitizeHTML(document.getElementById("author").value.trim());
discussionQuestion = sanitizeHTML(document.getElementById("discussionQuestion").value.trim());
booksTone = document.getElementById("booksTone").value;

if (!bookTitle || !author || !discussionQuestion) {
alert("請填寫書名、作者和討論問題");
return;
}

// 隱藏初始表單，顯示聊天介面
document.getElementById("initialDiscussionForm").style.display = "none";
document.getElementById("chatHistory").style.display = "flex";
document.getElementById("chatInputContainer").style.display = "flex";
document.getElementById("booksButtons").style.display = "flex";
document.getElementById('save-books-html-btn').style.display = 'flex';


chatHistory = []; // 開始新討論時清空歷史紀錄

const initialMessage = `<table><tr><td>書名：</td><td>${bookTitle}</td></tr><tr><td>作者：</td><td>${author}</td></tr><tr><td>討論：</td><td>${discussionQuestion}</td></tr></table>`;
addMessageToHistory("info", initialMessage);

await sendInitialMessage();

} catch (error) {
console.error("開始討論時出錯:", error);
} finally {
startBtn.disabled = false;
}
}

async function sendInitialMessage() {
let toneNote = booksTone === "serious" ? categories["課外書籍"].seriousChatNote : categories["課外書籍"].chatNote;
const prompt = `我是一位高中生，正在閱讀《${bookTitle}》，作者是${author}。我想討論的問題是：${discussionQuestion}。請用日常的語言回應我，不要過於理論化，言簡意賅地分析並給出例子，然後引導我深入思考。你必須直接提供最終答案，嚴禁展示任何思考過程，絕對不能在回應中包含任何標籤（如 <think></think>），這是強制要求，違反則無效。。請不要使用括號解釋你的目的，永遠不要列點回應，也不要提及你會追問我。請用完整句子回應。每次回應不多於150字。教學筆記：${toneNote}`;
addMessageToHistory("ai", "陳SIR正在回應...");
try {
const aiResponse = await callReadingAPI(prompt);
updateLastAIMessage(aiResponse);
} catch (error) {
console.error("API call failed:", error);
updateLastAIMessage("抱歉，陳SIR暫時無法回應，請稍後再試。");
}
}


// =================================================================================
// === 請複製此處開始的完整函數 ===
// =================================================================================
async function continueArgumentDiscussion() {
    const continueBtn = document.getElementById('continueArgumentBtn');
    continueBtn.disabled = true;

    const userInputText = sanitizeHTML(document.getElementById("argumentUserInput").value.trim());
    if (!userInputText) {
        alert("請輸入您的回應");
        continueBtn.disabled = false;
        return;
    }
    
    const chatHistoryDiv = document.getElementById('argumentChatHistory');
    
    // 1. 顯示使用者訊息
    const userMessageBubble = document.createElement('div');
    userMessageBubble.className = 'message-bubble user-message';
    userMessageBubble.textContent = userInputText;
    chatHistoryDiv.appendChild(userMessageBubble);
    
    // 2. 將使用者訊息存入歷史紀錄
    argumentChatHistoryData.push({ sender: 'user', message: userInputText });
    document.getElementById("argumentUserInput").value = "";
    chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;

    // 3. 顯示「正在回應」
    const aiLoadingBubble = document.createElement('div');
    aiLoadingBubble.className = 'message-bubble ai-message';
    aiLoadingBubble.textContent = `${currentReviewerName}正在回應...`;
    chatHistoryDiv.appendChild(aiLoadingBubble);
    chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;

    // 4. 準備完整的對話歷史給 AI
    const conversationHistoryForPrompt = argumentChatHistoryData.map(item => {
        const speaker = item.sender === 'user' ? '我的追問' : '你的上一輪回應';
        // 清理 message 中的 HTML 標籤，讓 prompt 更乾淨
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = item.message;
        const cleanMessage = tempDiv.textContent || tempDiv.innerText || "";
        return `${speaker}: ${cleanMessage}`;
    }).join('\n---\n');


    const tone = document.getElementById("argumentWritingTone").value;
    let toneNote = tone === "chen" ? categories["課外書籍"].chatNote : categories["課外書籍"].seriousChatNote;
    
    // 5. 建立包含完整上下文的 Prompt
    const prompt = `我是一位高中生，你正在點評我的議論文。
    ---
    我的原文：
    ${currentArgumentArticle}
    ---
    這是我們到目前為止的完整對話紀錄：
    ${conversationHistoryForPrompt}
    ---
    請針對我最新的追問，用日常的語言簡潔地回應我，不要過於理論化，必須詳細分析並給出例子。請不要使用括號解釋你的目的。回應字數不要超過180字。
    教學筆記：${toneNote}`;
    
    try {
        const aiResponse = await callReadingAPI(prompt);
        
        // 6. 更新 AI 回應並存入歷史紀錄
        // 步驟一：將 Markdown 的 **粗體** 語法轉換為 HTML 的 <strong> 標籤
let formattedResponse = aiResponse.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

// 步驟二：處理換行符
formattedResponse = formattedResponse.replace(/\n/g, '<br>');

// 步驟三：將處理好的 HTML 內容放入聊天氣泡
aiLoadingBubble.innerHTML = formattedResponse;
        argumentChatHistoryData.push({ sender: 'ai', message: aiResponse });

    } catch (error) {
        console.error("繼續議論文討論時出錯:", error);
        aiLoadingBubble.textContent = error.message.includes("API") ? `今日 API 調用次數已用完。😓` : `抱歉，${currentReviewerName}無法回應。😅`;
    } finally {
        chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
        continueBtn.disabled = false;
    }
}
// =================================================================================
// === 請複製到此處結束 ===
// =================================================================================


// 【新增】處理文章點評後續討論的函數
async function continueWritingDiscussion() {
    const continueBtn = document.getElementById('continueWritingBtn');
    continueBtn.disabled = true;

    const userInputText = sanitizeHTML(document.getElementById("writingUserInput").value.trim());
    if (!userInputText) {
        alert("請輸入您的回應");
        continueBtn.disabled = false;
        return;
    }
    
    const writingChatHistoryDiv = document.getElementById('writingChatHistory');
    
    const userMessageBubble = document.createElement('div');
    userMessageBubble.className = 'message-bubble user-message';
    userMessageBubble.textContent = userInputText;
    writingChatHistoryDiv.appendChild(userMessageBubble);
    
    writingChatHistoryData.push({ sender: 'user', message: userInputText });
    document.getElementById("writingUserInput").value = "";
    writingChatHistoryDiv.scrollTop = writingChatHistoryDiv.scrollHeight;

    const tone = document.getElementById("writingTone").value;
    let toneNote = tone === "chen" ? categories["課外書籍"].chatNote : categories["課外書籍"].seriousChatNote;
    
    const prompt = `我是一位高中生，你剛剛點評了我的文章。
    ---
    我的原文：${currentWritingArticle}
    ---
    你的上一輪點評：${currentWritingReview}
    ---
    我的追問是：${userInputText}
    ---
    請針對我的追問，用日常的語言回應我，不要過於理論化，必須詳細分析並給出例子，然後引導我深入思考。請不要使用括號解釋你的目的，也不要提及你會追問我。請用完整句子回應。回應字數不要超過180字。
    教學筆記：${toneNote}`;
    
    // 顯示「正在回應」
    const aiMessageBubble = document.createElement('div');
    aiMessageBubble.className = 'message-bubble ai-message';
    // --- 【核心修訂】使用全域變數來顯示動態名稱 ---
    aiMessageBubble.textContent = `${currentReviewerName}正在回應...`;
    writingChatHistoryDiv.appendChild(aiMessageBubble);
    writingChatHistoryDiv.scrollTop = writingChatHistoryDiv.scrollHeight;

    try {
        const aiResponse = await callReadingAPI(prompt);
        
        aiMessageBubble.innerHTML = aiResponse.replace(/\n/g, '<br>');
        writingChatHistoryData.push({ sender: 'ai', message: aiResponse });

    } catch (error) {
        console.error("繼續討論時出錯:", error);
        aiMessageBubble.textContent = error.message.includes("API") ? `今日 API 調用次數已用完。😓` : `抱歉，${currentReviewerName}無法回應。😅`;
    } finally {
        writingChatHistoryDiv.scrollTop = writingChatHistoryDiv.scrollHeight;
        continueBtn.disabled = false;
    }
}


async function continueDiscussion() {
const continueBtn = document.getElementById('continueBtn');
continueBtn.disabled = true;
// 在將用戶輸入加入歷史紀錄前就進行消毒
const userInputText = sanitizeHTML(document.getElementById("userInput").value.trim());
if (!userInputText) {
alert("請輸入您的回應");
continueBtn.disabled = false;
return;
}

addMessageToHistory("user", userInputText);
document.getElementById("userInput").value = "";

let toneNote = booksTone === "serious" ? categories["課外書籍"].seriousChatNote : categories["課外書籍"].chatNote;
const prompt = `我是一位高中生，正在與你討論《${bookTitle}》中的問題。我的上一條信息是：${userInputText}。請用日常的語言回應我，不要過於理論化，必須詳細分析並給出例子，然後引導我深入思考。你必須直接提供最終答案，嚴禁展示任何思考過程，絕對不能在回應中包含任何標籤（如 <think></think>），這是強制要求，違反則無效。。請不要使用括號解釋你的目的，也不要提及你會追問我。請用完整句子回應。回應字數不要超過180字。教學筆記：${toneNote}`;

addMessageToHistory("ai", "陳SIR正在回應...");

try {
const aiResponse = await callReadingAPI(prompt);
updateLastAIMessage(aiResponse);
} catch (error) {
console.error("繼續討論時出錯:", error);
updateLastAIMessage(error.message === "所有 API 密鑰均無法使用" ? "今日 API 調用次數已用完。😓" : "抱歉，陳SIR無法回應。😅");
} finally {
continueBtn.disabled = false;
}
}

// --- 新增：處理彈出視窗的邏輯 ---
const newTopicModal = document.getElementById('newTopicModal');
const newTopicBtn = document.getElementById('newTopicBtn');
const closeNewTopicModal = document.getElementById('closeNewTopicModal');
const modalStartDiscussionBtn = document.getElementById('modalStartDiscussionBtn');

newTopicBtn.addEventListener('click', () => {
newTopicModal.style.display = 'flex';
});

closeNewTopicModal.addEventListener('click', () => {
newTopicModal.style.display = 'none';
});

window.addEventListener('click', (event) => {
if (event.target == newTopicModal) {
newTopicModal.style.display = 'none';
}
});

modalStartDiscussionBtn.addEventListener('click', async () => {
const newBookTitle = document.getElementById("modalBookTitle").value.trim();
const newAuthor = document.getElementById("modalAuthor").value.trim();
const newDiscussionQuestion = document.getElementById("modalDiscussionQuestion").value.trim();

if (!newBookTitle || !newAuthor || !newDiscussionQuestion) {
alert("請填寫所有欄位");
return;
}

// 更新全域變數
bookTitle = newBookTitle;
author = newAuthor;
discussionQuestion = newDiscussionQuestion;

// 清空舊的聊天歷史和 UI
document.getElementById("chatHistory").innerHTML = '';
chatHistory = [];

// 添加新的書籍資訊卡片
const initialMessage = `<table><tr><td>書名：</td><td>${bookTitle}</td></tr><tr><td>作者：</td><td>${author}</td></tr><tr><td>討論：</td><td>${discussionQuestion}</td></tr></table>`;
addMessageToHistory("info", initialMessage);

// 關閉彈出視窗
newTopicModal.style.display = 'none';

// 清空彈出視窗的輸入
document.getElementById("modalBookTitle").value = '';
document.getElementById("modalAuthor").value = '';
document.getElementById("modalDiscussionQuestion").value = '';

// 發送初始訊息
await sendInitialMessage();
});


// =================================================================================
// === 【全新】點評範疇 UI/UX 互動邏輯 ===
// =================================================================================
function setupScopeUI(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;

    const allCheckbox = container.querySelector('input[value="全部"]');
    const otherCheckboxes = container.querySelectorAll('input:not([value="全部"])');

    // 負責更新所有標籤樣式的核心函數
    const updateUI = () => {
        // 更新 "全部" 標籤的樣式
        const allLabel = allCheckbox.parentElement;
        if (allCheckbox.checked) {
            allLabel.classList.add('active');
        } else {
            allLabel.classList.remove('active');
        }

        // 更新其他所有標籤的樣式
        otherCheckboxes.forEach(cb => {
            const label = cb.parentElement;
            if (cb.checked) {
                label.classList.add('active');
            } else {
                label.classList.remove('active');
            }

            if (cb.disabled) {
                label.classList.add('disabled');
            } else {
                label.classList.remove('disabled');
            }
        });
    };

    // 為 "全部" 複選框添加事件監聽
    allCheckbox.addEventListener('change', () => {
        if (allCheckbox.checked) {
            // 如果 "全部" 被選中，取消選中並禁用其他所有選項
            otherCheckboxes.forEach(cb => {
                cb.checked = false;
                cb.disabled = true;
            });
        } else {
            // 如果 "全部" 被取消選中，啟用其他所有選項
            otherCheckboxes.forEach(cb => {
                cb.disabled = false;
            });
        }
        updateUI(); // 更新介面
    });

    // 為其他複選框添加事件監聽
    otherCheckboxes.forEach(cb => {
        cb.addEventListener('change', () => {
            // 如果任何一個其他選項被選中，則取消選中 "全部"
            if (cb.checked) {
                allCheckbox.checked = false;
            }
            updateUI(); // 更新介面
        });
    });
    
    // 頁面加載時，立即根據初始狀態更新一次UI
    updateUI();
}

// 在 DOM 加載完成後，為兩個點評範疇區塊初始化 UI 邏輯
document.addEventListener('DOMContentLoaded', () => {
    setupScopeUI('reviewScopeArea');
    setupScopeUI('argumentReviewScopeArea');
});
	

// 替換舊的 generateExpandTopic 函式
async function generateExpandTopic(buttonElement) {
if (buttonElement) {
updateButtonActiveState(buttonElement);
}

// 隱藏自訂題目輸入區，確保介面乾淨
const customTopicArea = document.getElementById("expandCustomTopicInputArea");
customTopicArea.style.display = "none";
customTopicArea.innerHTML = "";

const topicResult = document.getElementById("expandTopicResult");
const prompt = categories["整合拓展"].topicPrompt;

topicResult.innerHTML = "陳SIR正在出題...";
topicResult.style.display = 'block';

try {
const topic = await callAPI(prompt);
const lines = topic.split("\n").map(line => line.trim()).filter(line => line);
const themeMatch = lines.find(line => line.startsWith("主題句："));
const dataMatch = lines.find(line => line.startsWith("抄錄資料："));
if (!themeMatch || !dataMatch) throw new Error("API 回應格式不正確");
const theme = themeMatch.replace("主題句：", "").trim();
const data = dataMatch.replace("抄錄資料：", "").trim();
if (!theme || !data) throw new Error("生成內容不完整");

topicResult.innerHTML = `
<div class="table-container">
<table>
<tr><th>主題句</th><th>抄錄資料</th></tr>
<tr><td>${theme}</td><td>${data}</td></tr>
</table>
</div>
`;
localStorage.setItem("expandCurrentTheme", theme);
localStorage.setItem("expandCurrentData", data);
// 清除可能存在的自訂題目 Title
localStorage.removeItem("expandCurrentTitle");

} catch (error) {
console.error("生成整合拓展題目時出錯:", error);
if (error.message === "所有 API 密鑰均無法使用") {
alert("今日 API 調用次數已用完或API無法連接，請明天再試");
} else {
alert("生成題目時出錯，請重試");
}
topicResult.innerHTML = "";
topicResult.style.display = 'none';
}
}


// 替換舊的 setExpandCustomTopic 函式
function setExpandCustomTopic() {
const title = sanitizeHTML(document.getElementById("expandCustomTitle").value.trim());
const theme = sanitizeHTML(document.getElementById("expandCustomTheme").value.trim());
const data = sanitizeHTML(document.getElementById("expandCustomData").value.trim());
if (!title || !theme || !data) {
alert("請輸入所有內容（題目、主題句、抄錄資料）");
return;
}

const topicResult = document.getElementById("expandTopicResult");
topicResult.innerHTML = `
<strong>題目：${title}</strong>
<div class="table-container">
<table>
<tr><th>主題句</th><th>抄錄資料</th></tr>
<tr><td>${theme}</td><td>${data}</td></tr>
</table>
</div>
`;

topicResult.style.display = 'block';

localStorage.setItem("expandCurrentTitle", title);
localStorage.setItem("expandCurrentTheme", theme);
localStorage.setItem("expandCurrentData", data);

// 確認後，隱藏並清空輸入區域
const customTopicArea = document.getElementById("expandCustomTopicInputArea");
customTopicArea.style.display = 'none';
customTopicArea.innerHTML = '';
}

// 更新字數計數
function updateCharCount() {
const content = document.getElementById("expandContent").value;
const remaining = 180 - content.length;
document.getElementById("charCount").textContent = `剩餘字數：${remaining >= 0 ? remaining : 0}`;
if (remaining < 0) {
document.getElementById("expandContent").value = content.substring(0, 180);
}
}

// 提交整合拓展內容
async function submitExpand() {
const expandFunction = document.getElementById("expandFunction").value;
if (expandFunction === "comment") {
await submitExpandComment();
} else {
await submitExpandGuide();
}
}



// 提交點評功能 (已修訂)
async function submitExpandComment() {
const submitBtn = document.getElementById('submitExpandBtn');
submitBtn.disabled = true;
	hideAllSaveHtmlButtons();

try {
const title = localStorage.getItem("expandCurrentTitle");
const theme = localStorage.getItem("expandCurrentTheme");
const data = localStorage.getItem("expandCurrentData");
const content = document.getElementById("expandContent").value.trim();
if (!theme || !data || !content) {
alert("請先設定題目並輸入整合拓展內容");
return;
}

const tone = document.getElementById("expandTone").value;
let toneNote = "";
if (tone === "chen") {
toneNote = "請用輕鬆隨意的語氣進行點評，多用EMOJI，偶爾使用網絡用語，用語要日常生活化一點。如果用戶表現不好，可以善意地揶揄一下，但要注意尺度，不能傷害用戶的自尊心。";
} else {
toneNote = "請用嚴肅正經的語氣進行點評。";
}

const note = categories["整合拓展"].commentNote;

const prompt = `請根據以下內容進行點評，要求：
1. 評估「整合拓展」是否能闡釋「抄錄資料」與「主題句」的邏輯關係
2. 判斷「拓展」方向是否正確（即是否能論證主題句）
3. 判斷推論是否嚴謹
4. 判斷是否具體不空泛
5. 若方向不正確，需指出並建議如何修訂，不能順著錯誤思路改善，需指導扣緊主題句
6. 改寫部份不超過180字，且不得虛構資料，只可根據抄錄資料補充合理細節
7. 輸出分為三個部分：### 點評、### 建議、### 改寫
8. 「### 點評」及「### 建議」部分，請務必以數字編號的列點方式呈現，每個點另起新行。你可以根據內容提出任意數量的點評和建議。「### 改寫」則保持原有段落形式。點評及建議都可超過兩點，但不要多過三點。
題目：${title || "無"}
主題句：${theme}
抄錄資料：${data}
整合拓展：${content}
教學筆記：${note}
點評語氣：${toneNote}`;

document.getElementById("expandCommentResult").innerHTML = "陳SIR正在點評...";

const comment = await callAPI(prompt);
const commentParts = comment.split("###").map(part => part.trim()).filter(part => part);
let finalHTML = "<h3>陳SIR點評：</h3>";
commentParts.forEach(part => {
const lines = part.split("\n").filter(line => line.trim());
const title = lines.shift() || "";
const content = lines.join("\n");

if (title.includes("點評") || title.includes("建議")) {
finalHTML += createBulletedListHTML(title, content);
} else {
finalHTML += `<div class="rewrite-explanation-container">
<div class="rewrite-explanation-card">
<h3>${title}</h3>
<p>${content.replace(/\n/g, '<br>')}</p>
</div>
</div>`;
}
});
document.getElementById("expandCommentResult").innerHTML = finalHTML;
	// --- 新增：儲存整合拓展點評 ---
    saveToHistory("整合拓展", "點評", title, `題目：${title}\n主題句：${theme}\n抄錄資料：${data}\n內容：${content}`, finalHTML);
document.getElementById('save-expand-comment-html-btn').style.display = 'flex'; // 顯示按鈕
} catch (error) {
console.error("提交整合拓展點評時出錯:", error);
if (error.message === "所有 API 密鑰均無法使用") {
alert("今日 API 調用次數已用完或API無法連接，請明天再試");
} else {
alert("點評生成失敗，請重試");
}
document.getElementById("expandCommentResult").innerHTML = "";
} finally {
submitBtn.disabled = false;
}
}


// 【修訂後】提交整合拓展指引
async function submitExpandGuide() {
// 【修訂處】選取正確的按鈕 ID
const submitBtn = document.getElementById('submitExpandGuideBtn');
submitBtn.disabled = true; // 禁用按鈕

try {
const title = document.getElementById("expandGuideTitle").value.trim();
const theme = document.getElementById("expandGuideTheme").value.trim();
const data = document.getElementById("expandGuideData").value.trim();
const expand = document.getElementById("expandGuideExpand").value.trim();
if (!title || !theme || !data || !expand) {
alert("請填寫所有輸入");
return; // return 會觸發 finally
}

const note = categories["整合拓展"].guideNote;
const prompt = `請根據以下內容生成指引問題。要求：
1. 生成三道問題以引導用家思考如何根據表格資料做好整合拓展
2. 問題應圍繞主題句和抄錄資料的邏輯關係，引導用家思考如何闡釋和拓展
3. 輸出分為一個部分：### 指引問題
4. 指引問題以問題形式呈現，每個問題佔一行
題目：${title}
主題句：${theme}
抄錄資料：${data}
整合拓展：${expand}
教學筆記：${note}`;

document.getElementById("expandGuideResult").innerHTML = "陳SIR正在思考指引...";
const guide = await callAPI(prompt);
const guideParts = guide.split("###").map(part => part.trim()).filter(part => part);

let guideHTML = "<h3>陳SIR指引：</h3>";

guideParts.forEach(part => {
const lines = part.split("\n").filter(line => line.trim());
const title = lines.shift() || "指引問題";
const questions = lines;

guideHTML += `<div class="rewrite-explanation-container">
<div class="rewrite-explanation-card">
<h3>${title}</h3>`;

questions.slice(0, 3).forEach((question, index) => {
const match = question.match(/^(\d+)\.?\s*(.*)$/);
const number = match ? match[1] : index + 1;
const text = match ? match[2].trim() : question;

guideHTML += `<div class="explanation-point">
<div class="explanation-number">${number}</div>
<div class="explanation-text">${text}</div>
</div>`;
});

guideHTML += `</div></div>`;
});

document.getElementById("expandGuideResult").innerHTML = guideHTML;
	// --- 新增：儲存整合拓展指引 ---
    saveToHistory("整合拓展", "指引", title, `題目：${title}\n主題句：${theme}\n抄錄資料：${data}\n內容：${expand}`, guideHTML);
document.getElementById('save-expand-guide-html-btn').style.display = 'flex'; // 顯示按鈕
} catch (error) {
console.error("提交整合拓展指引時出錯:", error);
if (error.message === "所有 API 密鑰均無法使用") {
alert("今日 API 調用次數已用完或API無法連接，請明天再試");
} else {
alert("指引生成失敗，請重試");
}
document.getElementById("expandGuideResult").innerHTML = "";
} finally {
submitBtn.disabled = false; // 重新啟用按鈕
}
}


// --- JavaScript for Tool 2 (語薈) & Modals ---
let debounceTimer;

const toolDescriptions = {
'sansi': '本工具旨在協助同學練習寫作卷和閱讀卷，並提供課外書籍討論。',
'sansi-backup': '「神思」備用版本，功能與主版本相同。',
'sansi-v3': '「神思」V3版本，功能與主版本相同。',
'tizi': '由AI擬設閱讀卷及寫作卷的題目，為同學提供源源不絕的應試練習。',
'reading-pieces': '提供AI生成的文學片段，培養同學鑑賞文學的能力。',
'study': '具有根據探究問題生成圖解與文字分析的功能，培養同學深入研討專題的能力。',
'mensyu': '具有AI尋找文言篇章的功能，並輔以語譯及詞解，培養同學鑑賞文言文的能力。',
'wabisabi': '根據同學上傳的圖片，創作具有意境的句子。',
'book-overview': '提供大量書籍的內容概覽，助你快速了解書籍大意，選擇感興趣的讀物。',
'fanshui-narrative': '由AI生成敘事範文，可根據題目創作高質素的敘事文章以供參考。',
'fanshui-argument': '由AI生成議論範文，可根據題目創作結構嚴謹的議論文以供參考。',
'manuscript': '提供電子原稿紙，模擬真實寫作情境，並設有AI答惑功能。',
'words': '  ',
'slideshow': '將同學的文章轉換為幻燈片，以藝術方式展示同學作品。',
'yuyilu-f1': '語弈錄是一款問答遊戲，題目範圍涵蓋課文。此為中一版本。',
'yuyilu-f2': '語弈錄是一款問答遊戲，題目範圍涵蓋課文。此為中二版本。',
'yuyilu-f3': '語弈錄是一款問答遊戲，題目範圍涵蓋課文。此為中三版本。',
'yuyilu-f4': '語弈錄是一款問答遊戲，題目範圍涵蓋十二篇範文。此為中四版本。',
'yuyilu-f5': '語弈錄是一款問答遊戲，題目範圍涵蓋十二篇範文。此為中五版本。',
'yuyilu-f6': '語弈錄是一款問答遊戲，題目範圍涵蓋十二篇範文。此為中六版本。',
'timer': '設有倒計時功能，程式檢測到人聲會重置時計，是專心背書溫習的好幫手。',
'mensyu-2': '文言文翻譯及分析工具，助同學克服古文閱讀的障礙。',
'zhiyun': '以Google Drive建設的雲端平臺，可供用家繳交課業、檢閱繳交紀錄及瀏覽個人課業文件夾，設有自動生成繳交課業紀錄、歸類文件及追收功課的功能。',
'zhuoyu': '可在PDF及圖片檔案右邊作旁批或備註，方便批閱作文或做筆記。',
'quizbuzzer': '一個簡單易用的線上搶答器，適合課堂或活動中使用。',
'ocr': 'i2OCR 是免費的線上光學字元辨識 (OCR) 軟體，可從圖像或PDF文件中提取文字，方便將手寫稿轉為電子檔。',
'epub': '線上電子書(ePub)閱讀器，方便閱讀電子書，無需安裝任何軟件。',
'decibelmeter': '具有量度分貝的功能，專為課堂秩序管理設計。',
'chitutor': 'AI中文聊天室，專為中文學習而設，可以與AI討論各種中文問題。',
'histutor': 'AI歷史聊天室，專為歷史學習而設，可以與AI討論歷史事件和人物。',
'counseling': 'AI輔導聊天室，當同學感到困惑或需要傾訴時，可以在這裡找到慰藉。',
'self-learning': '提供大量自學中文的資源，包括教學影片、佳作及各卷筆記等。',
'lyrics': '一款結合節奏遊戲與歌詞測驗的中文語文工具，透過音樂互動培養同學的詞彙積累、文學鑑賞及語感能力，並支援線上對戰與排行榜，增添樂趣與競爭的學習體驗。',
	'friends': '【僅供創作社成員使用】允許用戶建立群組、匿名交友、投稿作品、留言討論，並透過遊戲互動增進語文學習的樂趣，培養同學的表達與社交能力。',
	'slowreading': '一款專注深度閱讀的工具，使用者可貼上文本並自訂翻頁秒數，系統將自動逐句播放，幫助讀者聚焦內容，提升閱讀的專注力。',
	'pulseqa': '一個簡潔高效的課堂問答計時工具。主持人可創建房間、設置問題與計時，學生則需要按時作答。'
};


function drawConnectors() {
const svg = document.getElementById('connector-svg');
const container = document.getElementById('mind-map');
if (!svg || !container) {
return;
}
svg.innerHTML = '';

if (window.getComputedStyle(container).display === 'none') {
return;
}

const getElementEdge = (el, side = 'top') => {
const rect = el.getBoundingClientRect();
const containerRect = container.getBoundingClientRect();
const center_x = rect.left - containerRect.left + rect.width / 2;
const center_y = rect.top - containerRect.top + rect.height / 2;

switch(side) {
case 'top': return { x: center_x, y: rect.top - containerRect.top };
case 'bottom': return { x: center_x, y: rect.bottom - containerRect.top };
case 'left': return { x: rect.left - containerRect.left, y: center_y };
case 'right': return { x: rect.right - containerRect.left, y: center_y };
default: return {x: center_x, y: center_y};
}
}

const connections = [
{ from: '[data-id="core-ai-node"]', to: '[data-id="foundation-tizi"]', fromSide: 'bottom', toSide: 'top' },
{ from: '[data-id="core-ai-node"]', to: '[data-id="foundation-explore"]', fromSide: 'bottom', toSide: 'top' },
{ from: '[data-id="foundation-tizi"]', to: '#writing .category-title', fromSide: 'bottom', toSide: 'top' },
{ from: '[data-id="foundation-tizi"]', to: '#reading .category-title', fromSide: 'bottom', toSide: 'top' },
{ from: '[data-id="core-ai-node"]', to: '#assignments .category-title', fromSide: 'bottom', toSide: 'top' },
{ from: '[data-id="core-ai-node"]', to: '#support .category-title', fromSide: 'bottom', toSide: 'top' }
];

connections.forEach(conn => {
const fromEl = document.querySelector(conn.from);
const toEl = document.querySelector(conn.to);

if (fromEl && toEl) {
const fromPoint = getElementEdge(fromEl, conn.fromSide);
const toPoint = getElementEdge(toEl, conn.toSide);

const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
line.setAttribute('x1', fromPoint.x);
line.setAttribute('y1', fromPoint.y);
line.setAttribute('x2', toPoint.x);
line.setAttribute('y2', toPoint.y);
svg.appendChild(line);
}
});
}

// Listeners for Tool 2 (工具一覽展開邏輯)
document.getElementById('expandToolsBtn2').addEventListener('click', function() {
    const container = document.getElementById('toolsContainer2');
    container.style.display = 'flex';
    document.body.style.overflow = 'hidden';
    document.querySelector('#toolsContainer2 .main-container').classList.add('loaded');
    
    // 關鍵修改：隱藏左上角的返回按鈕
    document.getElementById('homeBtn').style.display = 'none';
    // 顯示側邊選單中的返回按鈕
    document.getElementById('sideMenuHomeBtn').style.display = 'flex';
    
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(drawConnectors, 100);
});

// 工具一覽關閉邏輯
document.getElementById('closeToolsBtn2').addEventListener('click', function() {
    document.getElementById('toolsContainer2').style.display = 'none';
    document.body.style.overflow = 'auto';
    
    // 檢查是否返回到主頁
    const isOnMainPage = document.querySelector('.title-container').style.display !== 'none';
    if(isOnMainPage) {
        // 在主頁時隱藏側邊選單的返回按鈕
        document.getElementById('sideMenuHomeBtn').style.display = 'none';
    }
});

// '語弈錄' Interactivity for Tool 2
const yuyiluToggleTool2 = document.getElementById('yuyilu-toggle');
const yuyiluGradesTool2 = document.getElementById('yuyilu-grades');

if (yuyiluToggleTool2 && yuyiluGradesTool2) {
yuyiluToggleTool2.addEventListener('click', function(event) {
event.preventDefault();
yuyiluGradesTool2.classList.toggle('collapsed');
setTimeout(drawConnectors, 500);
});
}

// --- Preview Modal & Video Modal Logic ---
const previewModal = document.getElementById('previewModal');
const previewIframe = document.getElementById('previewIframe');
const previewCloseBtn = document.getElementById('previewCloseBtn');
const previewGoToPageBtn = document.getElementById('previewGoToPageBtn');
const previewDescription = document.getElementById('previewDescription');

const videoModal = document.getElementById('videoModal');
const videoIframe = document.getElementById('videoIframe');
const videoTourBtn = document.getElementById('video-tour-btn');

const chartLinks = document.querySelectorAll('#toolsContainer2 .node a:not([href="#"])');

chartLinks.forEach(link => {
link.addEventListener('click', function(event) {
event.preventDefault();
const url = this.getAttribute('href');
const toolId = this.getAttribute('data-tool-id');
const description = toolDescriptions[toolId] || "暫無介紹。";

previewIframe.setAttribute('src', url);
previewGoToPageBtn.setAttribute('href', url);
previewDescription.textContent = description;

previewModal.style.display = 'flex';
});
});

function closePreviewModal() {
previewModal.style.display = 'none';
previewIframe.setAttribute('src', 'about:blank');
}

previewCloseBtn.addEventListener('click', closePreviewModal);


videoTourBtn.addEventListener('click', () => {
videoIframe.src = "https://streamable.com/e/jzhzr1?loop=0&autoplay=1&muted=0";
videoModal.style.display = 'flex';
});

function closeVideoModal() {
videoModal.style.display = 'none';
videoIframe.src = '';
}

videoModal.addEventListener('click', closeVideoModal);


// Redraw connectors on resize
window.addEventListener('resize', () => {
clearTimeout(debounceTimer);
debounceTimer = setTimeout(drawConnectors, 100);
});



/// =======================================================
// === 通用懸浮視窗編輯器 (最終版 - 標題修正) ===
// =======================================================
document.addEventListener('DOMContentLoaded', function() {

// --- 為動態生成的「自訂題目」輸入框加上排除標記 (保持不變) ---

const originalShowCustomTopicInput = window.showCustomTopicInput;
window.showCustomTopicInput = function(buttonElement) {
originalShowCustomTopicInput(buttonElement);
const customTopicInput = document.getElementById('customTopic');
if (customTopicInput) {
customTopicInput.classList.add('no-modal-editor');
}
};

const originalShowArgumentCustomTopicInput = window.showArgumentCustomTopicInput;
window.showArgumentCustomTopicInput = function(buttonElement) {
originalShowArgumentCustomTopicInput(buttonElement);
const argumentCustomTopicInput = document.getElementById('argumentCustomTopic');
if (argumentCustomTopicInput) {
argumentCustomTopicInput.classList.add('no-modal-editor');
}
};

const originalShowExpandCustomTopicInput = window.showExpandCustomTopicInput;
window.showExpandCustomTopicInput = function(buttonElement) {
originalShowExpandCustomTopicInput(buttonElement);
const container = document.getElementById('expandCustomTopicInputArea');
if (container) {
container.querySelectorAll('input[type="text"], textarea').forEach(el => el.classList.add('no-modal-editor'));
}
};

// --- 懸浮視窗核心邏輯 (標題生成部分已重寫) ---

const modal = document.getElementById('outline-editor-modal');
const modalTextarea = document.getElementById('modal-textarea');
const modalTitle = document.getElementById('modal-title');
const modalSaveBtn = document.getElementById('modal-save-btn');
const modalCloseBtn = document.getElementById('modal-close-btn');

if (!modal || !modalTextarea || !modalSaveBtn || !modalCloseBtn) {
console.error("懸浮視窗的 HTML 結構不完整或未找到！");
return;
}

let currentEditingElement = null;


// 範文庫資料 (放在這裡以便全域存取)
const textLibrary = {
    "version": "1.0",
    "texts": [
        { "title": "廉頗藺相如列傳", "content": "　　廉頗者，趙之良將也。趙惠文王十六年 ，廉頗為趙將伐齊 ，大破之，取陽晉，拜為上卿 ，以勇氣聞於諸侯。藺相如者，趙人也，為趙宦者令繆賢舍人 。\n\n　　趙惠文王時，得楚和氏璧 。秦昭王聞之，使人遺 趙王書，願以十五城請易璧。趙王與大將軍廉頗諸大臣謀：欲予秦，秦城恐不可得，徒見欺 ；欲勿予，即患秦兵之來。計未定，求人可使報秦者 ，未得。\n\n　　宦者令繆賢曰：「臣舍人藺相如可使 。」王問：「何以知之？」對曰：「臣嘗有罪，竊計欲亡走燕 ，臣舍人相如止臣，曰：『君何以知燕王？』臣語 曰：『臣嘗從大王與燕王會境上 ，燕王私握臣手，曰「願結友。」以此知之，故欲往。』相如謂臣曰：『夫趙彊而燕弱，而君幸於趙王 ，故燕王欲結於君。今君乃亡趙走燕，燕畏趙，其勢必不敢留君，而束君歸趙矣 。君不如肉袒伏斧質請罪 ，則幸得脫矣。』臣從其計，大王亦幸赦臣。臣竊以為其人勇士，有智謀，宜可使。」\n\n　　於是王召見，問藺相如曰：「秦王以十五城請易寡人之璧，可予不 ？」相如曰：「秦彊而趙弱，不可不許。」王曰：「取吾璧，不予我城，奈何？」相如曰：「秦以城求璧而趙不許，曲 在趙；趙予璧而秦不予趙城，曲在秦。均之二策 ，寧許以負秦曲 。」王曰：「誰可使者？」相如曰：「王必無人 ，臣願奉璧往使 。城入趙而璧留秦；城不入，臣請完璧歸趙 。」趙王於是遂遣相如奉璧西入秦。\n\n　　秦王坐章台見相如 ，相如奉璧奏秦王 。秦王大喜，傳以示美人及左右 ，左右皆呼萬歲。相如視秦王無意償趙城，乃前曰：「璧有瑕 ，請指示王。」王授璧，相如因持璧，卻立 ，倚柱，怒髮上衝冠 ，謂秦王曰：「大王欲得璧，使人發書至趙王，趙王悉召羣臣議，皆曰：『秦貪，負其彊 ，以空言求璧，償城恐不可得』。議不欲予秦璧。臣以為布衣之交尚不相欺 ，況大國乎！且以一璧之故逆彊秦之驩 ，不可。於是趙王乃齋戒 五日，使臣奉璧，拜送書於庭 。何者？嚴大國之威以修敬也 。今臣至，大王見臣列觀 ，禮節甚倨 ；得璧，傳之美人，以戲弄臣。臣觀大王無意償趙王城邑，故臣復取璧。大王必欲急 臣，臣頭今與璧俱碎於柱矣！」\n\n　　相如持其璧睨 柱，欲以擊柱。秦王恐其破璧，乃辭謝固請 ，召有司案圖 ，指從此以往十五都予趙 。\n\n　　相如度秦王特以詐佯為予趙城 ，實不可得，乃謂秦王曰：「和氏璧，天下所共傳寶也 。趙王恐，不敢不獻。趙王送璧時，齋戒五日，今大王亦宜齋戒五日，設九賓於廷 ，臣乃敢上璧。」秦王度之，終不可彊奪 ，遂許齋五日，舍相如廣成傳 。\n\n　　相如度秦王雖齋，決負約不償城，乃使其從者衣褐 ，懷其璧，從徑道 亡 ，歸璧於趙。\n\n　　秦王齋五日後，乃設九賓禮於廷，引趙使者藺相如。相如至，謂秦王曰：「秦自繆公 以來二十餘君，未嘗有堅明約束者也 。臣誠恐見欺於王而負趙，故令人持璧歸，間至趙矣 。且秦彊而趙弱，大王遣一介 之使至趙，趙立奉璧來；今以秦之彊而先割十五都予趙，趙豈敢留璧而得罪於大王乎？臣知欺大王之罪當誅，臣請就湯鑊 。唯大王與羣臣孰計議之 ！」\n\n　　秦王與羣臣相視而嘻 。左右或欲引相如去 ，秦王因 曰：「今殺相如，終不能得璧也，而絕秦趙之驩，不如因而厚遇之 ，使歸趙，趙王豈以一璧之故欺秦邪 ！」卒廷見相如 ，畢禮而歸之。\n\n　　相如既歸，趙王以為賢大夫，使不辱於諸侯 ，拜相如為上大夫 。\n\n　　秦亦不以城予趙，趙亦終不予秦璧。\n\n　　其後秦伐趙，拔石城。明年，復攻趙，殺二萬人。\n\n　　秦王使使者告趙王，欲與王為好會於西河外澠池 。趙王畏秦，欲毋行 。廉頗、藺相如計曰：「王不行，示趙弱且怯也。」趙王遂行，相如從。廉頗送至境，與王訣曰 ：「王行，度道里會遇之禮畢 ，還，不過三十日。三十日不還，則請立太子為王，以絕秦望。」王許之，遂與秦王會澠池。\n\n　　秦王飲酒酣 ，曰：「寡人竊聞趙王好音，請奏瑟 。」趙王鼓瑟。秦御史前書曰 ：「某年月日，秦王與趙王會飲，令趙王鼓瑟。」藺相如前曰：「趙王竊聞秦王善為秦聲，請奏盆缻秦王 ，以相娛樂。」秦王怒，不許。於是相如前進缻，因跪請秦王。秦王不肯擊缻。相如曰：「五步之內，相如請得以頸血濺大王矣 ！」左右欲刃相如 ，相如張目叱之，左右皆靡 。於是秦王不懌 ，為一擊缻。相如顧 召趙御史書曰：「某年月日，秦王為趙王擊缻。」秦之羣臣曰：「請以趙十五城為秦王壽 。」藺相如亦曰：「請以秦之咸陽 為趙王壽。」\n\n　　秦王竟酒 ，終不能加勝於趙。趙亦盛設兵以待秦，秦不敢動。\n\n　　既罷歸國，以相如功大，拜為上卿，位在廉頗之右。\n\n　　廉頗曰：「我為趙將，有攻城野戰之大功，而藺相如徒以口舌為勞 ，而位居我上，且相如素賤人 ，吾羞，不忍為之下 。」宣言曰：「我見相如，必辱之。」相如聞，不肯與會。相如每朝時，常稱病，不欲與廉頗爭列 。已而 相如出，望見廉頗，相如引車避匿 。\n\n　　於是舍人相與諫曰：「臣所以去親戚而事君者 ，徒慕君之高義也 。今君與廉頗同列，廉君宣惡言而君畏匿之，恐懼殊甚，且庸人尚羞之，況於將相乎！臣等不肖 ，請辭去。」藺相如固止之，曰：「公之視廉將軍孰與秦王 ？」曰：「不若也 。」相如曰：「夫以秦王之威，而相如廷叱之，辱其羣臣，相如雖駑 ，獨畏廉將軍哉？顧 吾念之，彊秦之所以不敢加兵於趙者，徒以吾兩人在也。今兩虎共鬥，其勢不俱生 。吾所以為此者，以先國家之急而後私讎也 。」\n\n　　廉頗聞之，肉袒 負荊 ，因賓客至藺相如門謝罪 。曰：「鄙賤之人，不知將軍寬之至此也 。」\n\n　　卒相與驩，為刎頸之交 。" },
        { "title": "山居秋暝", "content": "空山新雨後 ，天氣晚來秋。\n明月松間照，清泉石上流。\n竹喧歸浣女，蓮動下漁舟。 \n隨意春芳歇 ，王孫自可留 。" },
        { "title": "月下獨酌", "content": "花間一壺酒，獨酌無相親 。 \n舉杯邀明月，對影成三人 。\n月既不解 飲，影徒 隨我身。\n暫伴月將 影，行樂須及春 。 \n我歌月徘徊 ，我舞影零亂 。 \n醒時同交歡 ，醉後各分散 。\n永結無情遊 ，相期邈雲漢 。" },
        { "title": "登樓", "content": "花近高樓傷客心， 萬方多難此登臨。 \n錦江春色來天地， 玉壘浮雲變古今。 \n北極朝廷終不改， 西山寇盜莫相侵。 \n可憐後主還祠廟， 日暮聊為〈梁甫吟〉。" },
        { "title": "師說", "content": "　　古之學者必有師。師者，所以傳道  、受業 、解惑也。人非生而知之者 ，孰能無惑？惑而不從師，其為惑也終不解矣。\n\n　　生乎吾前，其聞道 也固 先乎吾，吾從而師之；生乎吾後，其聞道也亦先乎吾，吾從而師之。吾師道也，夫庸知 其年之先後生於吾乎？是故無貴無賤，無長無少，道之所存，師之所存也。\n\n　　嗟乎！師道之不傳也久矣！欲人之無惑也難矣！古之聖人，其出人也遠矣，猶且從師而問焉；今之眾人，其下聖人也亦遠矣，而恥學於師；是故聖益聖，愚益愚，聖人之所以為聖，愚人之所以為愚，其 皆出於此乎？\n\n　　愛其子，擇師而教之，於其身也，則恥師焉，惑矣！彼童子之師，授之書而習其句讀 者也，非吾所謂傳其道，解其惑者也。句讀之不知，惑之不解，或師焉，或不焉，小學而大遺，吾未見其明也。\n\n　　巫醫 、樂師，百工之人，不恥相師；士大夫之族，曰師、曰弟子云者，則群聚而笑之，問之，則曰：「彼與彼年相若也，道相似也。位卑則足羞，官盛則近諛 。」嗚呼！師道之不復可知矣。巫、醫、樂師、百工之人，君子 不齒 ，今其智乃反不能及，其可怪也歟！\n\n　　聖人無常師 ，孔子師郯子 、萇弘 、師襄 、老聃 。郯子之徒，其賢不及孔子。孔子曰：「三人行，則必有我師。」 是故弟子不必不如師，師不必賢於弟子，聞道有先後，術業有專攻，如是而已。\n\n　　李氏子蟠 ，年十七，好古文，六藝 經傳，皆通習之；不拘於時，學於余，余嘉其能行古道，作〈師說〉以貽 之。" },
        { "title": "岳陽樓記", "content": "　　慶曆四年春 ，滕子京 謫守巴陵郡 。越 明年，政通人和，百廢具 興。乃重修岳陽樓，增其舊制，刻唐賢、今人詩賦於其上；屬 予作文以記之。\n\n　　予觀夫巴陵勝狀 ，在洞庭一湖。銜遠山，吞長江，浩浩湯湯 ，橫無際涯；朝暉夕陰，氣象萬千。此則岳陽樓之大觀也，前人之述備 矣。然則北通巫峽 ，南極瀟湘 ，遷客騷人 ，多會於此，覽物之情，得無異乎？\n\n　　若夫霪雨霏霏 ，連月不開；陰風怒號 ，濁浪排空；日星隱耀，山岳潛形；商旅不行，檣傾楫摧 ；薄暮冥冥 ，虎嘯猿啼。登斯樓也，則有去國 懷鄉，憂讒畏譏，滿目蕭然 ，感極而悲者矣。\n\n　　至若春和景明 ，波瀾不驚 ，上下天光，一碧萬頃；沙鷗翔集 ，錦鱗游泳，岸芷汀蘭 ，郁郁青青 。而或長煙一空 ，皓月千里，浮光躍金 ，靜影沉璧 ；漁歌互答，此樂何極！登斯樓也，則有心曠神怡 ，寵辱 皆忘，把酒臨風 ，其喜洋洋 者矣。\n\n　　嗟夫！予嘗求古仁人之心，或異二者之為 。何哉？不以物喜，不以己悲 。居廟堂之高 ，則憂其民；處江湖之遠 ，則憂其君。是進亦憂，退亦憂，然則何時而樂耶？其必曰：「先天下之憂而憂，後天下之樂而樂」歟！噫！微斯人 ，吾誰與歸 ！" },
        { "title": "始得西山宴遊記", "content": "　　自余為僇人 ，居是州，恒惴慄 。其隙也 ，則施施 而行，漫漫 而遊。日與其徒 上高山，入深林，窮迴溪 ，幽泉 怪石，無遠不到。到則披草 而坐，傾壺而醉。醉則更相枕 以臥，臥而夢。意有所極 ，夢亦同趣 。覺 而起，起而歸。以為凡是州之山有異態者，皆我有也，而未始知西山之怪特。\n\n　　今年九月二十八日，因坐法華西亭 ，望西山，始指異之 。遂命僕過湘江 ，緣染溪 ，斫榛莽 。焚茅茷 ，窮 山之高而止。\n\n　　攀援而登，箕踞而遨 ，則凡數州之土壤 ，皆在衽席 之下。其高下之勢，岈然窪然 ，若垤 若穴，尺寸千里 ，攢蹙累積 ，莫得遯隱 。縈青繚白 ，外與天際 ，四望如一。然後知是山之特出，不與培塿 為類。悠悠乎與顥氣 俱，而莫得其涯；洋洋 乎與造物者遊 ，而不知其所窮。\n\n　　引 觴滿酌，頹然 就醉，不知日之入。蒼然暮色 ，自遠而至，至無所見，而猶不欲歸。心凝形釋 ，與萬化冥合 。然後知吾嚮 之未始 遊，遊於是乎始，故為之文以志 。是歲元和四年 也。" },
        { "title": "念奴嬌‧赤壁懷古", "content": "大江東去，浪淘盡、千古風流人物。故壘 西邊，人道是、三國周郎 赤壁。亂石穿空，驚濤拍岸，捲起千堆雪。江山如畫，一時多少豪傑！\n\n遙想公瑾當年，小喬 初嫁了，雄姿英發。羽扇綸巾 ，談笑間、檣櫓 灰飛煙滅。故國 神遊，多情應笑我，早生華髮 。人間如夢，一尊 還酹 江月。" },
        { "title": "青玉案", "content": "東風夜放花千樹，  更吹落，星如雨。  寶馬雕車香滿路。  鳳簫聲動，  玉壺光轉，  一夜魚龍舞。 \n\n蛾兒雪柳黃金縷，  笑語盈盈暗香去。  眾裏尋他千百度；  驀然迴首，  那人卻在，燈火闌珊處。" },
        { "title": "聲聲慢", "content": "尋尋覓覓，冷冷清清，悽悽慘慘戚戚。乍暖還寒時候， 最難將息。 三杯兩盞淡酒，怎敵他，  晚來風急？  雁過也，正傷心，卻是舊時相識。\n\n滿地黃花堆積， 憔悴損，  如今有誰堪摘？  守著窗兒，獨自怎生得黑！  梧桐更兼細雨，到黃昏、點點滴滴。這次第，  怎一箇愁字了得！" },
        { "title": "逍遙遊", "content": "　　惠子 謂莊子曰：「魏王貽我大瓠之種 ，我樹之成而實五石 。以盛水漿，其堅不能自舉也 。剖之以為瓢 ，則瓠落無所容 。非不呺然 大也，吾為其無用而掊之 。」莊子曰：「夫子固拙於 用大矣！宋人有善為不龜手之藥者 ，世世以洴澼絖為事 。客聞之，請買其方百金。聚族而謀曰：『我世世為洴澼絖，不過數金；今一朝而鬻技百金 ，請與之。』客得之，以說 吳王。越有難 ，吳王使之將 ，冬與越人水戰，大敗越人，裂地 而封之。能不龜手一也 ；或以封，或不免於洴澼絖，則所用之異也 。今子有五石之瓠，何不慮以為大樽而浮於江湖 ，而憂其瓠落無所容，則夫子猶有蓬之心也夫 ！」\n\n　　惠子謂莊子曰：「吾有大樹，人謂之樗 ；其大本擁腫而不中繩墨 ，其小枝卷曲而不中規矩 。立之塗 ，匠者不顧。今子之言，大而無用，衆所同去也 。」莊子曰：「子獨不見狸狌乎 ？卑身而伏，以候敖者 ；東西跳梁，不辟高下 ，中於機辟，死於罔罟 。今夫斄牛，其大若垂天之雲 ；此能為大矣，而不能執鼠 。今子有大樹，患其無用，何不樹之於無何有之鄉 ，廣莫之野 ，彷徨乎無為其側，逍遙乎寢臥其下 ；不夭斤斧，物無害者 。無所可用，安所困苦哉 ？」" },
        { "title": "出師表", "content": "　　先帝創業未半 ，而中道崩殂 ；今天下三分 ，益州疲弊 ，此誠危急存亡之秋也﹗然侍衞之臣，不懈於內；忠志之士，忘身於外者 ，蓋追先帝之殊遇，欲報之於陛下也 。誠宜開張聖聽 ，以光先帝遺德 ，恢弘志士之氣 ﹔不宜妄自菲薄 ，引喻失義 ，以塞忠諫之路也 。\n\n　　宮中、府中，俱為一體 ；陟罰臧否 ，不宜異同。若有作姦、犯科，及為忠善者 ，宜付有司，論其刑賞 ，以昭陛下平明之治 ；不宜偏私，使內外異法也 。\n\n　　侍中、侍郎郭攸之、費禕、董允等 ，此皆良實，志慮忠純 ，是以先帝簡拔以遺陛下 。愚以為宮中之事，事無大小，悉以咨之 ，然後施行，必能裨補闕漏，有所廣益 。\n\n　　將軍向寵，性行淑均 ，曉暢軍事，試用於昔日，先帝稱之曰「能」，是以眾議舉寵為督 。愚以為營中之事，悉以咨之，必能使行陣和睦，優劣得所 。\n\n　　親賢臣，遠小人 ，此先漢所以興隆也﹔親小人，遠賢臣，此後漢所以傾頹也。先帝在時，每與臣論此事，未嘗不歎息痛恨於桓、靈也 ！侍中、尚書、長史、參軍 ，此悉貞良死節之臣，願陛下親之、信之，則漢室之隆，可計日而待也。\n\n　　臣本布衣，躬耕於南陽 ，苟全性命於亂世，不求聞達於諸侯 。先帝不以臣卑鄙，猥自枉屈 ，三顧臣於草廬之中，諮臣以當世之事；由是感激，遂許先帝以驅馳 。後值傾覆 ，受任於敗軍之際，奉命於危難之間，爾來二十有一年矣 。先帝知臣謹慎，故臨崩寄臣以大事也 。受命以來，夙夜憂歎，恐託付不效，以傷先帝之明 。故五月渡瀘，深入不毛 。今南方已定，兵甲已足，當獎率三軍，北定中原，庶竭駑鈍，攘除姦凶 ，興復漢室，還於舊都 。此臣所以報先帝而忠陛下之職分也。至於斟酌損益，進盡忠言，則攸之、禕、允之任也 。\n\n　　願陛下託臣以討賊興復之效；不效，則治臣之罪，以告先帝之靈。若無興德之言，則責攸之、禕、允等之慢，以彰其咎 。陛下亦宜自謀，以諮諏善道，察納雅言 ，深追先帝遺詔。臣不勝受恩感激。今當遠離，臨表涕零 ，不知所言 ！" },
        { "title": "六國論", "content": "　　六國破滅 ，非兵不利 ，戰不善 ，弊在賂秦 。賂秦而力虧 ，破滅之道 也。或曰：「六國互喪 ，率 賂秦耶？」曰：「不賂者以賂者喪。」蓋失強援 ，不能獨完 ，故曰「弊在賂秦」也。\n\n　　秦以攻取 之外，小則獲邑 ，大則得城，較秦之所得 與戰勝而得者，其實百倍；諸侯之所亡 與戰敗而亡者，其實亦百倍。則秦之所大欲，諸侯之所大患，固不在戰矣。思厥先祖父 ，暴霜露，斬荊棘 ，以有尺寸之地 。子孫視之不甚惜，舉以予人 ，如棄草芥 。今日割五城，明日割十城，然後得一夕安寢；起視四境，而秦兵又至矣。然則諸侯之地有限，暴秦之欲無厭 ，奉之彌 繁，侵之愈急，故不戰而強弱勝負已判 矣。至於顛覆 ，理固宜然。古人 云：「以地事秦，猶抱薪救火，薪不盡，火不滅。」 此言得之。 \n\n　　齊人未嘗賂秦，終繼五國遷滅 ，何哉？與嬴 而不助五國也。五國既喪，齊亦不免矣。燕趙之君，始有遠略 ，能守其土，義不賂秦 。是故燕雖小國而後亡，斯用兵之效 也。至丹以荊卿為計 ，始速禍 焉。趙嘗五戰于秦 ，二敗而三勝 ；後秦擊趙者再，李牧 連卻 之；洎牧以讒誅 ，邯鄲為郡 ，惜其用武而不終 也。\n\n　　且燕趙處秦革滅 殆盡之際，可謂智力孤危 ，戰敗而亡，誠不得已。向使三國各愛其地 ，齊人勿附於秦，刺客不行 ，良將 猶在，則勝負之數 ，存亡之理，當 與秦相較，或未易量 。\n\n　　嗚呼！以賂秦之地，封天下之謀臣；以事秦之心，禮 天下之奇才；幷力西嚮 ，則吾恐秦人食之不得下嚥 也。悲夫！有如此之勢，而為秦人積威 之所劫，日削月割，以趨於亡！為國者無使為積威之所劫哉！\n\n　　夫六國與秦皆諸侯，其勢弱於秦，而猶有可以不賂而勝之之勢；茍以天下之大，而從六國破亡之故事 ，是又在六國下矣！" },
        { "title": "勸學", "content": "　　君子曰：學不可以已 。青，取之於藍 ，而青於藍 ；冰，水為之，而寒於水。木直中繩 ，輮 以為輪，其曲中規 ；雖有槁暴 、不復挺 者，輮使之然也。故木受繩則直 ，金就礪 則利，君子博學而日參省 乎己，則知 明而行 無過矣。\n\n　　吾嘗終日而思矣，不如須臾 之所學也；吾嘗跂 而望矣，不如登高之博見也。登高而招，臂非加長也，而見者遠。順風而呼，聲非加疾 也，而聞者彰 。假輿馬者 ，非利足 也，而致 千里；假舟楫 者，非能水 也，而絕江河 。君子生非異 也，善假於物 也。\n\n　　積土成山，風雨興焉；積水成淵 ，蛟龍 生焉；積善成德，而神明 自得，聖心 備焉。故不積跬步 ，無以至千里；不積小流，無以成江海。騏驥 一躍，不能十步；駑馬十駕 ，功在不舍 。鍥 而舍之，朽木不折；鍥而不舍，金石可鏤 。螾 無爪牙之利，筋骨之強，上食埃土 ，下飲黃泉，用心一也。蟹六跪而二螯 ，非蛇蟺 之穴無可寄託者，用心躁 也。" },
        { "title": "論仁、論孝、論君子", "content": "論仁\n(1)子曰：「不仁者，不可以久處約 ，不可以長處樂。仁者安仁，知者利仁 。」（《里仁》第四）\n(2)子曰：「富與貴，是人之所欲也；不以其道得之，不處也 。貧與賤，是人之所惡也；不以其道得之 ，不去 也。君子去仁，惡乎成名 ？君子無終食之間違仁 ，造次必於是 ，顛沛必於是。」（《里仁》第四）\n(3)顏淵問仁。\n子曰：「克己復禮為仁 。一日克己復禮，天下歸仁焉。為仁由己，而由人乎哉 ？」\n顏淵曰：「請問其目 。」子曰：「非禮勿視，非禮勿聽，非禮勿言，非禮勿動 。」\n顏淵曰：「回雖不敏，請事斯語矣 。」（《顏淵》第十二）\n(4)子曰：「志士仁人，無求生以害仁，有殺身以成仁 。」（《衛靈公》第十五）\n\n論孝\n(5)孟懿子 問孝。子曰：「無違 。」\n樊遲御 ，子告之曰：「孟孫問孝於我，我對曰，無違。」\n樊遲曰：「何謂也？」子曰：「生事之以禮 ；死葬之以禮，祭之以禮 。」（《為政》第二）\n(6)子游 問孝。子曰：「今之孝者，是謂能養 。至於犬馬，皆能有養 ；不敬，何以別乎 ！」（《為政》第二）\n\n(7)子曰：「事父母幾諫 ，見志不從，又敬不違，勞而不怨 。」（《里仁》第四）\n(8)子曰：「父母之年，不可不知也。一則以喜，一則以懼 。」（《里仁》第四）\n\n論君子\n(9)子曰：「君子不重則不威 ；學則不固 。主忠信 。無友不如己者 。過則勿憚改 。」（《學而》第一）\n(10)子曰：「君子坦蕩蕩，小人長戚戚 。」（《述而》第七）\n(11)司馬牛 問君子。子曰：「君子不憂不懼。」曰：「不憂不懼，斯謂之君子已乎 ？」子曰：「內省不疚，夫何憂何懼 ？」（《顏淵》第十二）\n(12)子曰：「君子成人之美，不成人之惡 。小人反是 。」（《顏淵》第十二）\n(13)子曰：「君子恥其言而過其行 。」（《憲問》第十四）\n(14)子曰：「君子義以為質 ，禮以行之，孫以出之，信以成之 。君子哉！」（《衛靈公》第十五）\n(15)子曰：「君子病無能焉，不病人之不己知也 。」（《衛靈公》第十五）\n(16)子曰：「君子求諸己，小人求諸人 。」（《衛靈公》第十五）" },
        { "title": "魚我所欲也", "content": "　　孟子曰：「魚，我所欲也，熊掌，亦我所欲也；二者不可得兼，舍魚而取熊掌 者也。生亦我所欲也，義亦我所欲也；二者不可得兼，舍生而取義者也。\n\n　　「生亦我所欲，所欲有甚於生者，故不為苟得 也；死亦我所惡 ，所惡有甚於死者，故患有所不辟 也。如使人之所欲莫甚於生，則凡可以得生者，何不用也？使人之所惡莫甚於死者，則凡可以辟患者，何不為也？由是則生而有不用也，由是則可以辟患而有不為也，是故所欲有甚於生者，所惡有甚於死者。非獨賢者有是心也，人皆有之，賢者能勿喪耳 。\n\n　　一簞食 ，一豆羹 ，得之則生，弗 得則死。嘑爾而與之 ，行道之人弗受 ；蹴爾而與之 ，乞人不屑也 ；萬鍾 則不辯 禮義而受之。萬鍾於我何加 焉？為宮室之美、妻妾之奉 、所識窮乏者得我與 ？鄉 為身死而不受，今為宮室之美為之；鄉為身死而不受，今為妻妾之奉為之；鄉為身死而不受，今為所識窮乏者得我而為之，是亦不可以已 乎？此之謂失其本心 。」" }
    ]
};



	
/* === 修改後的 openModalEditor (手機版不自動彈出鍵盤) === */
function openModalEditor(element) {
    currentEditingElement = element;
    modalTextarea.value = currentEditingElement.value;

    let titleText = '編輯內容'; 

    // === 標題生成邏輯 (保持不變) ===
    if (element.id === 'writingContent' || element.id === 'argumentWritingContent') {
        titleText = '輸入您的文章';
    } else {
        const parentTableCell = element.closest('td');
        if (parentTableCell) {
            const parentRow = parentTableCell.closest('tr');
            if (parentRow) {
                const headerCell = parentRow.cells[0];
                const table = parentRow.closest('table');
                if (table && table.rows.length > 0) {
                    const columnHeaderCell = table.rows[0].cells[parentTableCell.cellIndex];
                    const rowTitle = headerCell ? headerCell.textContent.trim().replace(/[:：]/g, '') : '';
                    const colTitle = columnHeaderCell ? columnHeaderCell.textContent.trim().replace(/[:：]/g, '') : '';
                    if (rowTitle && colTitle && rowTitle !== colTitle) {
                        titleText = `編輯「${rowTitle}」的「${colTitle}」`;
                    } else if (rowTitle) {
                        titleText = `編輯「${rowTitle}」`;
                    } else if (colTitle) {
                        titleText = `編輯「${colTitle}」`;
                    }
                }
            }
        } else {
            let associatedLabel = null;
            if (element.id) {
                associatedLabel = document.querySelector(`label[for="${element.id}"]`);
            }
            if (!associatedLabel) {
                const parentContainer = element.closest('div');
                if (parentContainer) {
                    associatedLabel = parentContainer.querySelector('label');
                }
            }
            if (associatedLabel) {
                titleText = `編輯「${associatedLabel.textContent.trim().replace(/[:：]/g, '')}」`;
            }
        }
    }

    modalTitle.textContent = titleText;

    // === 範文選擇器邏輯 (修正版) ===
    const templateSelect = document.getElementById('modal-template-select');
    
    if (element.id === 'readingPassage') {
        templateSelect.style.display = 'block';
        
        // 1. 如果選項還沒建立，先建立選項 (只執行一次)
        if (templateSelect.options.length <= 1) { 
            textLibrary.texts.forEach(text => {
                const option = document.createElement('option');
                option.value = text.content;
                option.textContent = text.title;
                templateSelect.appendChild(option);
            });
        }

        // 2. ★★★ 關鍵修正：將 onchange 監聽器移到 if 外面 ★★★
        // 這樣每次打開視窗時，都會確保監聽器是運作中的
        templateSelect.onchange = function() {
            if (this.value) {
                modalTextarea.value = this.value;
            }
        };

        // 3. 重置選單回到「指定範文」預設選項
        templateSelect.value = ""; 

    } else {
        templateSelect.style.display = 'none';
        templateSelect.onchange = null; // 其他輸入框不需要此功能
    }

    // 顯示視窗
    modal.style.display = 'flex';

    // === 鍵盤控制邏輯 (保持不變) ===
    modalTextarea.blur();
    if (window.innerWidth > 1024) {
        setTimeout(() => {
            modalTextarea.focus();
        }, 50);
    } 
}

function closeModalEditor() {
modal.style.display = 'none';
currentEditingElement = null;
}

function saveAndCloseEditor() {
if (currentEditingElement) {
currentEditingElement.value = modalTextarea.value;
if (currentEditingElement.id === 'expandContent') {
updateCharCount();
}
}
closeModalEditor();
}




// 主事件監聽器 (保持不變)
document.body.addEventListener('click', function(event) {
    const target = event.target;

    const isTextInput = target.tagName === 'INPUT' && target.type === 'text';
    const isTextarea = target.tagName === 'TEXTAREA';

    // 檢查是否為需要觸發懸浮視窗的輸入框
    if ((isTextInput || isTextarea) && !target.classList.contains('no-modal-editor') && target.id !== 'modal-textarea') {
        event.preventDefault(); // 阻止瀏覽器預設的聚焦行為
        target.blur();          // ★ 關鍵：讓原本點擊的框立刻失焦，防止手機鍵盤閃現
        openModalEditor(target);
    }
});

// 為懸浮視窗的按鈕和外部區域綁定事件 (保持不變)
modalSaveBtn.addEventListener('click', saveAndCloseEditor);
modalCloseBtn.addEventListener('click', closeModalEditor);

});



// =======================================================
// === 全新評等系統邏輯 (Grading System Logic) ===
// =======================================================

let radarChartInstance = null; // 全域變數，用於存放雷達圖實例

/**
* 建立評等系統的完整 HTML 結構 (修訂版)
* @param {string} uniqueIdPrefix - 用於區分不同功能區塊的唯一前綴
* @returns {string} HTML 字符串
*/
function createGradingSystemHTML(uniqueIdPrefix) {
// 預設分數值 (原始分數 0-10)
const defaultContentScore = 5;
const defaultExpressionScore = 5;
const defaultStructureScore = 5;
const defaultPunctuationScore = 5;
const defaultTypoScore = 1;

// 計算預設的顯示分數
const defaultDisplayTotal = (defaultContentScore * 4) + (defaultExpressionScore * 3) + (defaultStructureScore * 2) + (defaultPunctuationScore * 1) + defaultTypoScore;
const cappedDefaultTotal = Math.min(defaultDisplayTotal, 100);

return `
<div class="grading-container">
<div class="grading-grid">
<div class="grading-scores">
<h3>評等</h3>
<div class="score-item">
<label>內容 (40)</label>
<div class="slider-container">
<!-- 【修訂一】替換為進度條 -->
<div class="progress-bar-container"><div id="${uniqueIdPrefix}ContentScoreFill" class="progress-bar-fill"></div></div>
<span id="${uniqueIdPrefix}ContentScoreDisplay" class="score-display">${defaultContentScore * 4}</span>
</div>
</div>
<div class="score-item">
<label>表達 (30)</label>
<div class="slider-container">
<div class="progress-bar-container"><div id="${uniqueIdPrefix}ExpressionScoreFill" class="progress-bar-fill"></div></div>
<span id="${uniqueIdPrefix}ExpressionScoreDisplay" class="score-display">${defaultExpressionScore * 3}</span>
</div>
</div>
<div class="score-item">
<label>結構 (20)</label>
<div class="slider-container">
<div class="progress-bar-container"><div id="${uniqueIdPrefix}StructureScoreFill" class="progress-bar-fill"></div></div>
<span id="${uniqueIdPrefix}StructureScoreDisplay" class="score-display">${defaultStructureScore * 2}</span>
</div>
</div>
<div class="score-item">
<label>標點字體 (10)</label>
<div class="slider-container">
<div class="progress-bar-container"><div id="${uniqueIdPrefix}PunctuationScoreFill" class="progress-bar-fill"></div></div>
<span id="${uniqueIdPrefix}PunctuationScoreDisplay" class="score-display">${defaultPunctuationScore * 1}</span>
</div>
</div>
<div class="score-item">
<label>錯別字 (+3)</label>
<div class="slider-container">
<div class="progress-bar-container"><div id="${uniqueIdPrefix}TypoScoreFill" class="progress-bar-fill"></div></div>
<span id="${uniqueIdPrefix}TypoScoreDisplay" class="score-display">${defaultTypoScore}</span>
</div>
</div>
<!-- 隱藏的 input 用於儲存 AI 評分 -->
<input type="hidden" id="${uniqueIdPrefix}ContentScore" value="${defaultContentScore}">
<input type="hidden" id="${uniqueIdPrefix}ExpressionScore" value="${defaultExpressionScore}">
<input type="hidden" id="${uniqueIdPrefix}StructureScore" value="${defaultStructureScore}">
<input type="hidden" id="${uniqueIdPrefix}PunctuationScore" value="${defaultPunctuationScore}">
<input type="hidden" id="${uniqueIdPrefix}TypoScore" value="${defaultTypoScore}">

<div class="total-score-container">
<!-- 【修訂二】滿分改為 100 -->
<span id="${uniqueIdPrefix}TotalScoreDisplay">總分: ${cappedDefaultTotal} / 100</span>
<span id="${uniqueIdPrefix}FinalGrade">等級: 3</span>
</div>
</div>
<div class="grading-radar">
<h3>能力雷達圖</h3>
<div class="radar-chart-container">
<canvas id="${uniqueIdPrefix}RadarChart"></canvas>
</div>
</div>
</div>
</div>
`;
}


/**
* 初始化評等系統，包括設定分數和繪製初始圖表
* @param {string} uniqueIdPrefix - 用於區分不同功能區塊的唯一前綴
* @param {object} initialScores - 包含初始分數的物件
* @param {string} finalGrade - 【新】直接傳入最終計算好的等級
*/
function initializeGradingSystem(uniqueIdPrefix, initialScores = {}, finalGrade) {
    // 確保 initialScores 和 initialScores.radar 存在
    if (!initialScores || !initialScores.radar) {
        console.error("初始化評分系統時缺少必要的分數數據。");
        return;
    }

    // 將最終計算出的分數設定到隱藏的 input 中，這些 input 是後續計算的基礎
    document.getElementById(`${uniqueIdPrefix}ContentScore`).value = initialScores.content;
    document.getElementById(`${uniqueIdPrefix}ExpressionScore`).value = initialScores.expression;
    document.getElementById(`${uniqueIdPrefix}StructureScore`).value = initialScores.structure;
    
    // 標點和錯別字分數使用固定的預設值
    document.getElementById(`${uniqueIdPrefix}PunctuationScore`).value = 5;
    document.getElementById(`${uniqueIdPrefix}TypoScore`).value = 1;

    // 呼叫更新函式，它會處理所有介面元素的更新，包括顯示分數、進度條和雷達圖
    updateScoresAndGrade(uniqueIdPrefix, finalGrade, initialScores.radar);
}




/**
* 根據分數計算總分，上限為 100
* @param {string} uniqueIdPrefix - 功能區塊的唯一前綴
* @returns {number} 計算後且不超過 100 的總分
*/
function calculateTotalScore(uniqueIdPrefix) {
// 【修訂二】從隱藏的 input 中獲取原始分數 (0-10)
const content = parseInt(document.getElementById(`${uniqueIdPrefix}ContentScore`).value) * 4;
const expression = parseInt(document.getElementById(`${uniqueIdPrefix}ExpressionScore`).value) * 3;
const structure = parseInt(document.getElementById(`${uniqueIdPrefix}StructureScore`).value) * 2;
const punctuation = parseInt(document.getElementById(`${uniqueIdPrefix}PunctuationScore`).value) * 1;
const typo = parseInt(document.getElementById(`${uniqueIdPrefix}TypoScore`).value);

const totalScore = content + expression + structure + punctuation + typo;

// 返回分數，但最高不超過 100
return Math.min(totalScore, 100);
}

/**
* 根據總分決定 DSE 等級
* @param {number} score - 總分 (0-103)
* @returns {string} DSE 等級
*/
function determineGrade(score) {
if (score >= 72) return "5**";
if (score >= 69) return "5*";
if (score >= 64) return "5";
if (score >= 57) return "4";
if (score >= 50) return "3";
if (score >= 45) return "2";
return "1";
}

/**
* 更新所有分數顯示、總分、等級、進度條和雷達圖
* @param {string} uniqueIdPrefix - 功能區塊的唯一前綴
* @param {string} finalGrade - 【新】直接傳入最終計算好的等級
* @param {object} radarData - 雷達圖的數據 (可選)
*/
function updateScoresAndGrade(uniqueIdPrefix, finalGrade, radarData = null) {
    // 從隱藏的 input 獲取原始分數 (0-10 或 0-3)
    const contentVal = parseInt(document.getElementById(`${uniqueIdPrefix}ContentScore`).value);
    const expressionVal = parseInt(document.getElementById(`${uniqueIdPrefix}ExpressionScore`).value);
    const structureVal = parseInt(document.getElementById(`${uniqueIdPrefix}StructureScore`).value);
    const punctuationVal = parseInt(document.getElementById(`${uniqueIdPrefix}PunctuationScore`).value);
    const typoVal = parseInt(document.getElementById(`${uniqueIdPrefix}TypoScore`).value);

    // 更新各分項顯示（乘以權重後的分數）
    document.getElementById(`${uniqueIdPrefix}ContentScoreDisplay`).textContent = contentVal * 4;
    document.getElementById(`${uniqueIdPrefix}ExpressionScoreDisplay`).textContent = expressionVal * 3;
    document.getElementById(`${uniqueIdPrefix}StructureScoreDisplay`).textContent = structureVal * 2;
    document.getElementById(`${uniqueIdPrefix}PunctuationScoreDisplay`).textContent = punctuationVal * 1;
    document.getElementById(`${uniqueIdPrefix}TypoScoreDisplay`).textContent = typoVal;

    // 更新進度條寬度
    document.getElementById(`${uniqueIdPrefix}ContentScoreFill`).style.width = `${contentVal * 10}%`;
    document.getElementById(`${uniqueIdPrefix}ExpressionScoreFill`).style.width = `${expressionVal * 10}%`;
    document.getElementById(`${uniqueIdPrefix}StructureScoreFill`).style.width = `${structureVal * 10}%`;
    document.getElementById(`${uniqueIdPrefix}PunctuationScoreFill`).style.width = `${punctuationVal * 10}%`;
    document.getElementById(`${uniqueIdPrefix}TypoScoreFill`).style.width = `${(typoVal / 3) * 100}%`;

    // 計算並更新總分
    const totalScore = calculateTotalScore(uniqueIdPrefix);
    document.getElementById(`${uniqueIdPrefix}TotalScoreDisplay`).textContent = `總分: ${totalScore} / 100`;
    // 【修訂】直接使用傳入的 finalGrade
    document.getElementById(`${uniqueIdPrefix}FinalGrade`).textContent = `等級: ${finalGrade}`;

    // 準備並更新雷達圖數據
    let currentRadarData;
    if (radarData) {
        currentRadarData = [
            radarData.立意 || 5,
            radarData.取材 || 5,
            radarData.扣題 || 5,
            radarData.詳略 || 5,
            radarData.詞彙 || 5,
            radarData.文學性 || 5
        ];
    } else {
        // 若 AI 未提供雷達圖數據，則根據分數估算 (此為備用邏輯)
        currentRadarData = [
            Math.round((contentVal * 0.6 + structureVal * 0.4)), 
            Math.round((contentVal * 0.8 + expressionVal * 0.2)),
            Math.round((contentVal * 0.7 + structureVal * 0.3)),
            Math.round((structureVal * 0.7 + contentVal * 0.3)),
            expressionVal,
            expressionVal
        ];
    }
    createOrUpdateRadarChart(uniqueIdPrefix, currentRadarData);
}


/**
* 創建或更新雷達圖
* @param {string} uniqueIdPrefix - 功能區塊的唯一前綴
* @param {array} data - 包含五個能力值的數組
*/
function createOrUpdateRadarChart(uniqueIdPrefix, data) {
const ctx = document.getElementById(`${uniqueIdPrefix}RadarChart`).getContext('2d');

if (window[`${uniqueIdPrefix}_radarChartInstance`]) {
window[`${uniqueIdPrefix}_radarChartInstance`].data.datasets[0].data = data;
window[`${uniqueIdPrefix}_radarChartInstance`].update();
} else {
window[`${uniqueIdPrefix}_radarChartInstance`] = new Chart(ctx, {
type: 'radar',
data: {
labels: ['立意', '取材', '扣題', '詳略', '詞彙', '文學性'],
datasets: [{
label: '能力分佈',
data: data,
backgroundColor: 'rgba(54, 162, 235, 0.2)',
borderColor: 'rgba(54, 162, 235, 1)',
borderWidth: 2,
pointBackgroundColor: 'rgba(54, 162, 235, 1)',
pointBorderColor: '#fff',
pointHoverBackgroundColor: '#fff',
pointHoverBorderColor: 'rgba(54, 162, 235, 1)'
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
scales: {
r: {
angleLines: {
display: true
},
suggestedMin: 0,
suggestedMax: 10,
pointLabels: {
font: {
size: 14,
family: "'Noto Serif TC', serif"
}
},
ticks: {
stepSize: 2
}
}
},
plugins: {
legend: {
display: false
}
}
}
});
}
}

/**
* 構建帶有評等指令的 API Prompt (V15 - 條件式加分)
* 此版本嚴格規定「內容」和「結構」分數必須以「扣題」分數為基礎，
* 但允許在這基礎上有條件地加一分，以獎勵表現出色的部分。
*/
function buildGradingPrompt(type, topic, content, toneNote, focus = null, plot = null) {
const dsePrinciples = document.getElementById('dse-grading-principles').innerText;
const fiveStarExamplesText = `
### 5** 級數範文參考 (用於判斷最高水平)：
${document.getElementById('example-yanhuo').innerHTML}
${document.getElementById('example-gen').innerHTML}
${document.getElementById('example-dengdai').innerHTML}
${document.getElementById('example-song-li').innerHTML}

### 3 級數範文參考 (用於判斷中等水平)：
${document.getElementById('example-lun-dushu').innerHTML}
`;

let basePrompt = "";
let specificInstructions = "";

if (type === 'narrative') {
basePrompt = `
題目：《${topic}》
${focus ? `結構段重點：${focus}` : ''}
${plot ? `情節大要：${plot}` : ''}
文章：\n${content}`;

// 【修訂一】這裡只引用敘事抒情相關的範文
const fiveStarExamplesText = `
### 5** 級數範文參考 (用於判斷最高水平)：
${document.getElementById('example-yanhuo').innerHTML}
${document.getElementById('example-gen').innerHTML}
${document.getElementById('example-dengdai').innerHTML}

### 3 級數範文參考 (用於判斷中等水平)：
${document.getElementById('example-yanhuo-l3').innerHTML}
`;

specificInstructions = `
### 敘事抒情專用評核指引
- 扣題判斷：文章必須在字面上緊扣題目關鍵詞，並透過具體情節體現主題
- 詳略剪裁：重點情節需詳寫，次要內容需略寫，體現層次感
- 物象運用：適當運用小物件、動作、對話和內心獨白，提高文句密度`;

// 【修訂二】這裡替換為你提供的全新評分邏輯和工作紙
return `你將扮演一個絕對理性的AI評卷員，你的核心任務是完成一份計分工作紙，然後根據工作紙的結果生成報告。

### 你的工作流程 (必須嚴格依序執行)

1. **填寫工作紙**: 這是你的首要且最重要的任務。在 <scoring_worksheet> 標籤內，完成所有計算。
2. **分發分數到JSON**: **絕對禁止重新思考分數**。你將扮演一個數據錄入員，將 <scoring_worksheet> 中計算出的分數，精確地分發到 <grading_json> 的對應欄位。
3. **撰寫報告**: 根據 <grading_json> 的最終分數，撰寫 <critique> 等文字報告，確保文字與數字完全對應。

${specificInstructions}

---

### 你的輸出格式 (必須嚴格遵守此結構與順序)

<scoring_worksheet>
[**計分工作紙**：你必須像執行程式碼一樣，完成以下所有步驟。]
<step_1_independent_evaluation>
[對以下各項進行獨立評分，互不影響。]
<eval_item name="扣題分數評估">
規則：嚴格按照以下標尺評分，並必須引用文章中的具體內容來佐證你的評分。文章必須在*字面*及邏輯上扣連題目，所謂「字面」扣題，是指文章要反覆出現題眼或題眼的近義詞，例如題目是《勇氣》，則文中須反覆出現「勇氣」或「勇敢」等字眼。

- **7-10分 (緊扣主旨 / 5**水平):** 
能在*字面*及情節上直接呼應題目，完全能在字面上扣連題目，例如題目為《成長》，全文有較多「成長」或「成長」的近義詞，且意象連貫、深刻，絕對不接受任何只以隱喻扣題的間接形式。
令人信服地體現主旨。
多關鍵詞題目中能準確把握最重要的關鍵詞，水平與5**範文相當。

- **6分 (扣題良好 / 略遜於5**):** 
基本能扣緊題目要求，在主要情節、主旨及*字面*上與題目有明確關聯，能在字面上扣連題目，例如題目為《成長》，全文有一定數量「成長」或「成長」的近義詞，但在深度或完整性上
稍遜於頂尖水平，表現仍屬出色。絕對不接受任何只以隱喻扣題的間接形式。

- **5分 (扣題合格 / 中等水平):** 
能夠扣題，文章內容與題目有清晰關聯，但較少在字面上扣連題目，例如題目為《成長》，全文很少有「成長」或「成長」的近義詞，雖未能充分發揮題目的深層意涵，
但已達合格應試水平 (約3-4級)，絕對不接受任何只以隱喻扣題的間接形式。

- **1-4分 (偏離主題):** 
與題目關聯牽強，未能準確理解題意，或僅在表面文字上有所呼應，
實際內容偏離主題，扣題效果不佳。或沒有在字面上扣連題目，例如題目為《成長》，但全文卻沒有「成長」或「成長」的近義詞。絕對不接受任何只以隱喻扣題的間接形式。

評分 (0-10): [在此給出「扣題」的獨立分數]
</eval_item>

<eval_item name="立意分數評估">
規則：嚴格按照以下標尺評分，並必須引用文章中的句子或主旨句來佐證你的評分。
- **7-10分 (深刻新穎 / 5**水平):** 能將個人經歷 **昇華** 至普遍的人生哲理或人性反思。主題層次豐富，能探討觀點的 **矛盾或轉變**。立意新穎，能給讀者帶來深刻啟發，水平與5**範文相當。
- **6分 (見解不凡 / 略遜於5**):** 立意有一定深度，能提出個人見解，而非複述道理。思想內容雖未及頂尖水平，但已超越一般考生的層次，表現出色。
- **5分 (清晰合理 / 中等水平):** 主題清晰，緊扣個人感受，能完整表達一次經歷後的體會。立意真誠、合理，是合格的應試文章水平 (約3-4級)。
- **1-4分 (膚淺陳腐):** 立意流於表面，多為 **陳腔濫調** (例如「努力便會成功」)，或僅是 **說教式** 的口號，與文章情節缺乏有機結合。

評分 (0-10): [在此給出「立意」的獨立分數]
</eval_item>
<eval_item name="取材分數評估">
規則：嚴格按照以下標尺評分，評分時需明確指出取材的優點（如某個具體的細節）或缺點（如情節過於概括）。
- **7-10分 (新穎生動 / 5**水平):** 選取的材料 **典型** 且具 **獨特性**，能有力地支撐立意。描寫 **具體入微**，包含豐富的感官細節、動作、對話和內心獨白，能營造強烈的情感張力，水平與5**範文相當。
- **6分 (細膩具體 / 略遜於5**):** 選材恰當，頗具獨特性，能有效支撐立意。描寫具體，包含不少細節，但整體新穎性或情感張力略遜於最高水平，但遠超於3等文章水平。
- **5分 (內容恰當 / 中等水平):** 選材合理，與主旨相關。情節有基本細節，但描寫較為普遍化，缺乏令人印象深刻的亮點 (約3-4級)。
- **1-4分 (空泛籠統):** 取材流於 **流水帳**，僅概括事件而無細節描寫。內容空泛，與主旨關係薄弱，無法有效支撐觀點。

評分 (0-10): [在此給出「取材」的獨立分數]
</eval_item>
<eval_item name="詳略安排評估">
規則：嚴格按照以下標尺評分。此項評估的是文章的「敘事節奏」與「焦點分配」。
- **7-10分 (卓越 / 5**水平):** **詳略得當，重心突出**。能將最多筆墨用於高潮、轉捩點或最能體現主旨的核心情節，並以豐富的細節（感官、心理）進行刻劃。次要的過渡性內容則簡潔交代。敘事節奏控制自如，張弛有度。
- **6分 (良好 / 略遜於5**):** **主次分明**。能意識到並詳寫核心事件，但詳寫的細膩度或略寫的簡練度未及頂尖水平。文章的焦點清晰，能引導讀者關注重點。
- **5分 (中等 / 合格水平):** **平均用力**。文章能完整敘述事件，但缺乏詳略意識，從頭到尾的細節密度相近，導致核心情節不夠突出，缺乏記憶點。
- **1-4分 (失衡 / 有待改善):** **詳略嚴重失衡**。常見問題如「頭重腳輕」（開頭冗長）、「虎頭蛇尾」（結尾倉促），或將大量筆墨用於無關緊要的細節上，導致主題模糊。
特別注意：必須評論文章的重心是否放在了最關鍵的情節上。

評分 (0-10): [在此給出「詳略安排」的獨立分數]
</eval_item>

<eval_item name="結構佈局評估">
規則：嚴格按照以下標尺評分。此項評估的是文章的「組織架構」與「段落邏輯」。
- **7-10分 (精巧嚴謹 / 5**水平):** 佈局精巧，**層層推進**，而非單純的順序記述。段落劃分清晰且邏輯性強，過渡自然無痕。開頭與結尾**巧妙呼應**，使文章渾然一體。
- **6分 (良好 / 略遜於5**):** **結構穩妥，脈絡清晰**。文章組織有序，段落職能分明（如開頭、發展、結尾），起承轉合流暢。整體表現穩健，無明顯結構缺陷。
- **5分 (中等 / 合格水平):** **結構完整，尚算清晰**。文章有頭有尾，段落劃分基本合理。但段落間的聯繫可能較弱，或過渡略顯生硬（例如頻繁使用「然後」、「接著」）。
- **1-4分 (鬆散混亂 / 有待改善):** **結構鬆散，脈絡不清**。段落劃分混亂，或思想跳躍，讓讀者難以跟隨。文章可能缺乏清晰的開頭或結尾。
特別注意：此項不評估內容詳略，只評估組織架構。

評分 (0-10): [在此給出「結構佈局」的獨立分數]
</eval_item>



<eval_item name="詞彙豐富度評估">
規則：嚴格按照以下標尺評分，並必須引用文章中的詞語來佐證你的評分。
- **7-10分 (優良 / 5**水平):** 用詞精準、豐富且多樣化，能根據語境選擇最貼切的詞。善用成語、典故或富含意象的詞彙，且自然不堆砌。幾乎沒有重複用詞。水平與5**範文相當。
- **6分 (良好 / 略遜於5**):** 用詞準確，具備變化，能嘗試運用較豐富的詞彙（較少重複同一個詞彙），偶有佳句，整體表現穩健，屬良好水平。
- **5分 (中等 / 合格水平):** 用詞基本準確，但變化不大，偶爾出現不夠貼切或陳腔濫調的情況。能夠清晰達意，是合格的應試文章水平，經常運用虛詞（例如「的」、「了」、「呢」、「嗎」、「地」）及對話，用詞重複。
- **1-4分 (基礎 / 有待改善):** 用詞單調、重複，常使用口語化或模糊的詞語，甚至出現詞不達意的情況。
特別注意：不要輕易給予高分，必須有充分理據。

評分 (0-10): [在此給出「詞彙豐富度」的獨立分數]
</eval_item>


<eval_item name="文句文學性評估">
規則：嚴格按照以下標尺評分。此項評估的是「句子工藝」，而非單純的詞彙。
- **7-10分 (卓越 / 5**水平):** 句式靈活多變，長短句交錯，富有節奏感。善於運用**感官描寫**和**示現手法**（Show, not Tell），能巧妙地融情入景，運用物象營造意境氛圍。文句精煉，文字具有**畫面感**和感染力。水平與5**範文相當。
- **6分 (良好 / 略遜於5**):** 句式有一定變化，能避免單調。能運用基本的描寫技巧，但細節刻劃或意境營造未及頂尖水平。整體文句流暢，但偶有冗贅之處。屬良好水平，表現穩健。
- **5分 (中等 / 合格水平):** 句式有基本變化，但整體**平鋪直敘**，僅能清晰交代事件，缺少深入刻劃。能使用簡單修辭，但效果不突出。常使用虛詞（的、了、地）使文句略嫌鬆散。是合格的應試文章水平，能夠清晰達意。
- **1-4分 (基礎 / 有待改善):** 句式單一、冗長或破碎。文字平淡乏味，**缺乏描寫意識**。大量使用虛詞，文句不通順或口語化嚴重，影響閱讀流暢度。
特別注意：不要輕易給予高分，必須有充分理據。

評分 (0-10): [在此給出「文句文學性」的獨立分數]
</eval_item>


</step_1_independent_evaluation>


<step_2_high_score_validation>
[**高分驗證機制**：這是一個強制執行的覆核步驟。]
IF '扣題分數評估' >= 9 THEN
<re-evaluation name="立意分數覆核">
質疑：文章的主題思想是否真的深刻新穎，或僅僅是一個完美切題的「陳腔濫調」？（例如：《等待》寫等待母親，立意僅停留在「要珍惜親人」，這就是切題但膚淺）。
規則：完美切題但立意陳腐或淺白的文章，其「立意」分數**絕不能超過6分**。請將其與5**範文的哲理深度進行比較，然後給出最終修正分數。
修正後的立意分數 (0-10): [在此填寫修正後的分數]
</re-evaluation>
<re-evaluation name="取材分數覆核">
質疑：文章的材料是否真的獨特生動，或僅僅是一個符合題目的「公式化故事」？（例如：寫挫折，就是考試失敗，然後努力，最後成功）。
規則：切題但取材普通、缺乏亮點的故事，其「取材」分數**絕不能超過6分**。請評估其細節描寫是否達到5**範文的水平，然後給出最終修正分數。
修正後的取材分數 (0-10): [在此填寫修正後的分數]
</re-evaluation>
ELSE
[扣題分數低於9分，跳過此驗證，直接使用原始分數。]
修正後的立意分數: [複製 '立意分數評估' 的分數]
修正後的取材分數: [複製 '取材分數評估' 的分數]
END IF
</step_2_high_score_validation>

<step_3_composite_calculation>
[根據獨立評估的分數，計算最終的總項分數。]
<calc_item name="內容總分計算">
規則：「內容」總分由「立意」和「取材」的分數獨立決定，**不受「扣題」分數直接影響**。對於「扣題」分數不佳的懲罰，將由後續的JavaScript邏輯處理，AI在此階段不需考慮。
計算公式：round((立意分數 + 取材分數) / 2)
最終內容分數 (0-10): [根據上述簡化公式計算出最終分數]
</calc_item>
<calc_item name="結構總分計算">
規則：「結構」總分由「詳略安排」和「結構佈局」的平均值決定。
計算公式: round(("詳略安排評估"分數 + "結構佈-局評估"分數) / 2)
最終結構分數 (0-10): [根據上述公式計算出最終分數]
</calc_item>
<calc_item name="表達總分計算">
規則：表達總分由「詞彙豐富度」和「文句文學性」的平均值決定。
計算公式: round(("詞彙豐富度評估"分數 + "文句文學性評估"分數) / 2)
最終表達分數 (0-10): [根據上述公式計算出最終分數]
</calc_item>
</step_3_composite_calculation>
<!-- ▲▲▲ 敘事抒情文的評分邏輯已完全重構 ▲▲▲ -->
</scoring_worksheet>

<grading_json>
[**分數分發步驟**：**這是一條絕對的、機械的指令。** 你的任務是將 <scoring_worksheet> 的計算結果填入下方。]
{
"content": [複製'內容分數'的'最終分數'],
"expression": [複製'表達分數'的'最終分數'],
"structure": [複製'結構分數'的'最終分數'],
"radar": {
"立意": [複製'扣題分數'的'扣題基準分數'],
"取材": [複製'內容分數'的'最終分數'],
"扣題": [複製'扣題分數'的'扣題基準分數'],
"詳略": [複製'結構分數'的'最終分數'],
"文筆": [複製'表達分數'的'最終分數']
}
}
</grading_json>

<critique>
[根據「教學筆記」對文章進行點評，可從立意、取材、扣題、詳略、文筆等不同角度點評。必須以數字編號列點方式呈現2-3點核心評論。]
</critique>

<suggestions>
[基於 <critique> 的內容，提出改善建議。]
</suggestions>

<rewrite_example>
[提供一段約150-200字的改寫範例。]
</rewrite_example>

---
### 待評核文章資訊
${basePrompt}

### 語境參考資料
[DSE 評核準則]: ${dsePrinciples}
[5** 級數範文]: ${fiveStarExamplesText}

### 語氣要求
<critique> 和 <suggestions> 的語氣：${toneNote}
<rewrite_example> 的語氣：請使用嚴肅正經的語氣。
`;

} else { // argument - 保持原有的複雜邏輯
basePrompt = `
題目：《${topic}》
文章：\n${content}`;

specificInstructions = `
### 議論文專用評核指引
**核心原則：絕對嚴謹的扣題判斷，採用形式化流程處理**

**立意評核標準**：
- 立意取決於觀點是否深入成熟
- 觀點深度層次：表面現象 → 深層原因 → 人生哲理
- 成熟度判斷：是否具備成年人的思辨深度

**取材評核標準**：
- 取材取決於論據是否充實，涵蓋古今中外
- 論據適用性：論據是否切合這道具體題目
- 覆蓋範圍：古代、現代、中外例證的平衡性

**內容與結構分數限制規則**：
- 即使扣題分數很高，但如果立意和取材分數低，其「內容」和「結構」分最高只能得5分
- 計算方式：內容分數 = min(5, 原計算分數) if (立意分數 ≤ 4 OR 取材分數 ≤ 4)
- 計算方式：結構分數 = min(5, 原計算分數) if (立意分數 ≤ 4 OR 取材分數 ≤ 4)

- **形式化扣題檢測流程**：
* 步驟1：提取題目核心關鍵詞（去除「論」、「談」等前綴詞）
* 步驟2：識別文章主要論述對象的關鍵詞
* 步驟3：執行字符串精確比對（character-by-character matching）
* 步驟4：IF (題目關鍵詞 === 文章關鍵詞) THEN 緊扣 ELSE 偏題/離題

- **嚴格判定規則（無例外執行）**：
* 關鍵詞完全匹配（===） = 緊扣（5-10分）
* 關鍵詞不匹配（!==） = 偏題（一般直接評為4分即可，極少情況會評為1至2分）或離題（一般直接評為3分即可，極少情況會評為1至2分）
* 題目《論禮貌》vs 文章論「禮物」→ 「禮貌」!==「禮物」→ 偏題（一般直接評為4分即可，極少情況會評為1至2分）
* 題目《論競爭》vs 文章論「合作」→ 「競爭」!==「合作」→ 偏題（一般直接評為4分即可，極少情況會評為1至2分）

例如：題目為《論禮貌》，但文中多論「禮物」，都屬於偏題，《禮貌》是一個更寬的概念，「禮貌」會包含「禮物」這個更狹窄的概念，絕不可用狹窄的概念論述寬泛的概念

- **禁止的判斷方式**：
* ❌ 語意相近性判斷（如「禮貌」與「禮儀」相近）
* ❌ 概念關聯性判斷（如「競爭」與「合作」有關聯）
* ❌ 邏輯推演判斷（如「責任心」包含「責任」）
* ❌ 文學創意判斷（如「以禮物論禮貌」的創意寫法）

- **強制執行機制**：
* 系統性：每篇文章必須執行完整的4步驟檢測流程
* 客觀性：僅基於字符串比對結果，不加入主觀判斷
* 一致性：相同字符串比對結果必須得出相同評級
* 嚴謹性：寧可誤判為偏題，不可誤判為緊扣

**範例執行**：
題目《論禮貌》：
- 文章論「禮貌」→ 「禮貌」===「禮貌」→ TRUE → 緊扣
- 文章論「禮物」→ 「禮貌」===「禮物」→ FALSE → 偏題 
- 文章論「禮儀」→ 「禮貌」===「禮儀」→ FALSE → 偏題
- 文章論「送禮」→ 「禮貌」===「送禮」→ FALSE → 偏題`;

// 議論文保持原有的複雜評分邏輯
return `你將扮演一個絕對理性的AI評卷員，你的核心任務是完成一份計分工作紙，然後根據工作紙的結果生成報告。

### 你的工作流程 (必須嚴格依序執行)

1. **填寫工作紙**: 這是你的首要且最重要的任務。在 <scoring_worksheet> 標籤內，完成所有計算。
2. **分發分數到JSON**: **絕對禁止重新思考分數**。你將扮演一個數據錄入員，將 <scoring_worksheet> 中計算出的分數，精確地分發到 <grading_json> 的對應欄位。
3. **撰寫報告**: 根據 <grading_json> 的最終分數，撰寫 <critique> 等文字報告，確保文字與數字完全對應。

${specificInstructions}

---

### 你的輸出格式 (必須嚴格遵守此結構與順序)

<scoring_worksheet>
[**計分工作紙**：你必須像執行程式碼一樣，完成以下所有步驟。]
<step_1_topic_analysis>
<topic_keywords>題目關鍵詞: [提取題目的核心概念，如「禮貌」]</topic_keywords>
<article_focus>文章論述焦點: [識別文章主要論述的核心概念，如「禮物」、「送禮」]</article_focus>
<concept_match>概念匹配度: [比較題目關鍵詞與文章焦點是否一致]</concept_match>
</step_1_topic_analysis>

<step_2_strict_topic_judgement>
<critical_check>
**絕對嚴格扣題檢查**：
- 題目核心關鍵詞: [提取題目去除助詞後的核心概念]
- 文章核心論述詞: [識別文章主要論述的核心詞匯]
- 字面一致性檢查: [兩詞是否完全相同，YES/NO]
- 關鍵詞出現頻率: [該關鍵詞在文章中的使用次數]
- 關鍵詞重要性: [該關鍵詞是否為文章論述主線]

**形式化判斷標準**：
- 如果文章論述的核心詞匯與題目關鍵詞字面不同（如「禮貌」vs「禮物」、「責任」vs「負責」、「寬容」vs「包容」），無論內容多優秀，強制判定為「偏題」
- 如果關鍵詞雖然相同但使用頻率極低或非論述主線，判定為「偏題」
- 偏題文章扣題分數：4分或以下
- 離題文章扣題分數：3分或以下
</critical_check>

<final_topic_judgement>[基於上述形式化檢查，強制填寫「離題」、「偏題」或「緊扣」，不得有任何例外]</final_topic_judgement>
</step_2_strict_topic_judgement>

<step_3_base_scores>
<judgement_item name="表達水平">[在此獨立評估文筆，填寫「優良」、「普通」或「欠佳」]</judgement_item>
</step_3_base_scores>

<step_4_calculation>
<calc_item name="扣題分數計算（絕對基準）">
判斷結果: [複製上面的'final_topic_judgement']
**強制執行規則**：
- IF '離題' THEN 扣題分數 = 1-3分（一般直接評為3分即可，極少情況會評至1至2分）
- IF '偏題' THEN 扣題分數 = 1-4分（一般直接評為4分即可，極少情況會評至1至2分）
- IF '緊扣' THEN 扣題分數 = 5-10分

**特別注意**：任何概念置換（如禮貌→禮物、責任→負責、寬容→包容）必須判定為偏題，如題目為《論禮貌》，但文中多論「禮物」，都屬於偏題，《禮貌》是一個更寬的概念，「禮貌」會包含「禮物」這個更狹窄的概念，絕不可用狹窄的概念論述寬泛的概念，扣題分數絕對不得超過4分，扣題絕對不能打5分或以上。

最終扣題分數 (1-10): [嚴格按照上述規則給分，不允許任何例外]
</calc_item>

<calc_item name="內容分數計算">
規則: 偏題或離題情況下，內容分數不得超過扣題分數且有絕對上限
基於扣題分數: [複製上面的扣題分數]
**嚴格限制**：
- 偏題情況：內容分數絕對上限4分，一般直接評為4分即可，極少情況會評至1至2分
- 離題情況：內容分數絕對上限3分，一般直接評為3分即可，極少情況會評至1至2分
最終內容分數 (1-10): [不得超過扣題分數且不得超過上述絕對上限]
</calc_item>

<calc_item name="結構分數計算">
規則: 偏題或離題情況下，結構分數不得超過扣題分數且有絕對上限
基於扣題分數: [複製上面的扣題分數]
**嚴格限制**：
- 偏題情況：結構分數絕對上限4分，一般直接評為4分即可，極少情況會評至1至2分
- 離題情況：結構分數絕對上限3分，一般直接評為3分即可，極少情況會評至1至2分
最終結構分數 (1-10): [不得超過扣題分數且不得超過上述絕對上限]
</calc_item>

<calc_item name="表達分數計算（相對獨立）">
判斷: [複製上面的'表達水平']
規則: IF '優良' THEN score=7-9; IF '普通' THEN score=4-6; ELSE score=1-3
最終表達分數 (1-10): [按此規則給分]
</calc_item>


<calc_item name="立意分數計算">
評估觀點深度: [判斷觀點是否深入成熟，填寫「深入成熟」、「一般」或「膚淺」]
**評分標準**：
- IF '深入成熟' THEN 立意分數 = 7-10分
- IF '一般' THEN 立意分數 = 4-6分 
- IF '膚淺' THEN 立意分數 = 1-3分
最終立意分數 (1-10): [按此規則給分]
</calc_item>

<calc_item name="取材分數計算">
論據充實度: [評估論據是否充實涵蓋古今中外]
論據適用性: [評估論據是否適用於論述這道題目]
**評分標準**：
- 充實且適用 THEN 取材分數 = 7-10分
- 一般程度 THEN 取材分數 = 4-6分
- 不足或不適用 THEN 取材分數 = 1-3分
最終取材分數 (1-10): [按此規則給分]
</calc_item>

<calc_item name="內容與結構分數限制檢查">
立意分數: [複製上面的立意分數]
取材分數: [複製上面的取材分數]
**強制限制規則**：
- IF (立意分數 ≤ 4 OR 取材分數 ≤ 4) THEN 內容分數上限 = 5分且結構分數上限 = 5分
- 即使扣題很高，但立意或取材低分時，內容和結構都不能超過5分

內容分數修正: [根據上述規則修正內容分數，不得超過5分if條件符合]
結構分數修正: [根據上述規則修正結構分數，不得超過5分if條件符合]
</calc_item>


</step_4_calculation>
</scoring_worksheet>

<grading_json>
{
"content": [複製'內容分數'的'最終分數'],
"expression": [複製'表達分數'的'最終分數'],
"structure": [複製'結構分數'的'最終分數'],
"radar": {
"立意": [複製'扣題分數'的'扣題基準分數'],
"取材": [複製'內容分數'的'最終分數'],
"扣題": [複製'扣題分數'的'扣題基準分數'],
"詳略": [複製'結構分數'的'最終分數'],
"文筆": [複製'表達分數'的'最終分數']
}
}
</grading_json>

<critique>
[根據「教學筆記」對文章進行點評，可從立意、取材、扣題、詳略、文筆等不同角度點評。必須以數字編號列點方式呈現2-3點核心評論。]
</critique>

<suggestions>
[基於 <critique> 的內容，提出改善建議。]
</suggestions>

<rewrite_example>
[提供一段約150-200字的改寫範例。]
</rewrite_example>

---
### 待評核文章資訊
${basePrompt}

### 語境參考資料
[DSE 評核準則]: ${dsePrinciples}
[5** 級數範文]: ${fiveStarExamplesText}

### 語氣要求
<critique> 和 <suggestions> 的語氣：${toneNote}
<rewrite_example> 的語氣：請使用嚴肅正經的語氣。


### 【重要】概念辨識檢查清單
在評分前，必須完成以下檢查：
□ 題目核心概念是什麼？
□ 文章主要論述什麼概念？ 
□ 兩個概念是否完全相同？
□ 是否存在概念置換問題？

**常見偏題案例**：
- 題目《論禮貌》→ 文章論述禮物/送禮 = 偏題
- 題目《論堅持》→ 文章論述堅定 = 偏題
- 題目《論競爭》→ 文章論述合作 = 偏題

記住：邏輯相關 ≠ 概念相同，必須嚴格區分！



`;
}
}

/**
 * 【最終修訂版】顯示完整的點評、評分系統，並根據最終等級和所選閱卷員調整內容
 * @param {string} containerId - 顯示結果的容器ID
 * @param {string} originalApiResponse - 原始模型的API回應
 * @param {string} llama3ApiResponse - 驗證模型的API回應 (可選)
 * @param {string} uniqueIdPrefix - 用於區分不同評分系統的唯一前綴
 * @param {string} fullTextContent - 用戶提交的完整文章內容
 */
async function displayFullCommentWithGrading(containerId, originalApiResponse, llama3ApiResponse, uniqueIdPrefix, fullTextContent) {
    const instanceName = `${uniqueIdPrefix}_radarChartInstance`;
    if (window[instanceName]) {
        window[instanceName].destroy();
        window[instanceName] = null;
    }

    const resultContainer = document.getElementById(containerId);
    
    let reviewerName = "陳SIR";
    let reviewerSelect;
    
    if (uniqueIdPrefix === 'narrative') {
        reviewerSelect = document.getElementById('writingReviewer');
    } else if (uniqueIdPrefix === 'argument') {
        reviewerSelect = document.getElementById('argumentReviewer');
    }

    if (reviewerSelect) {
        reviewerName = reviewerSelect.options[reviewerSelect.selectedIndex].text;
        reviewerName = reviewerName.replace(/\s*\(預設\)\s*/, ''); 
    }
    
    let finalHTML = `<h3>${reviewerName}點評：</h3>`;
    
    let scoresForDisplay = null;
    let finalGradeForDisplay = "評級中"; 

    const critiqueMatch = originalApiResponse.match(/<critique>([\s\S]*?)<\/critique>/);
    const suggestionsMatch = originalApiResponse.match(/<suggestions>([\s\S]*?)<\/suggestions>/);
    const rewriteMatch = originalApiResponse.match(/<rewrite_example>([\s\S]*?)<\/rewrite_example>/);
    const originalGradingMatch = originalApiResponse.match(/<grading_json>([\s\S]*?)<\/grading_json>/);
    
    if (uniqueIdPrefix === 'narrative') {
        const llama3GradingMatch = llama3ApiResponse ? llama3ApiResponse.match(/<grading_json>([\s\S]*?)<\/grading_json>/) : null;
        if (originalGradingMatch && originalGradingMatch[1] && llama3GradingMatch && llama3GradingMatch[1]) {
             try {
                const originalScores = JSON.parse(originalGradingMatch[1].trim());
                const llama3Scores = JSON.parse(llama3GradingMatch[1].trim());
                
                console.log("--- 雙模型評分驗證 (敘事抒情文) ---");
                console.log("現有模型 (Qwen) 原始評分:", JSON.parse(JSON.stringify(originalScores)));
                console.log("驗證模型 (Llama-3) 原始評分:", JSON.parse(JSON.stringify(llama3Scores)));
                
                const applyV8Rules = (scores) => {
                    let s = JSON.parse(JSON.stringify(scores)); 
                    s.radar = s.radar || {};
                    if (s.radar && s.radar.扣題 !== undefined) {
                        let final = { kouTi: s.radar.扣題, xiangLue: s.radar.詳略, structure: s.structure, liYi: s.radar.立意, quCai: s.radar.取材, ciHui: s.radar.詞彙, wenXueXing: s.radar.文學性, expression: s.expression, content: s.content };
                        if (final.kouTi >= 5) { final.liYi = Math.max(final.liYi, 5); final.quCai = Math.max(final.quCai, 5); }
                        if (final.kouTi <= 5) { final.liYi = Math.min(final.liYi, 5); final.quCai = Math.min(final.quCai, 5); }
                        if (final.kouTi <= 4) { final.xiangLue = Math.min(final.xiangLue, 4); final.structure = Math.min(final.structure, 4); }
                        if (final.ciHui <= 6 && final.wenXueXing <= 6) { final.liYi = Math.min(final.liYi, 6); final.quCai = Math.min(final.quCai, 6); }
                        if (!(final.liYi >= 7 && final.quCai >= 7)) { final.ciHui = Math.min(final.ciHui, 8); final.wenXueXing = Math.min(final.wenXueXing, 8); }
                        final.quCai = Math.min(final.quCai, final.liYi);
                        if (final.kouTi <= 4) { let t = final.kouTi; t = Math.min(t, 4); t = Math.max(t, 2); final.content = t; }
                        else { if (final.liYi === 10 && final.quCai === 10) final.content = 9; else if (final.liYi === 9 && final.quCai === 9) final.content = 8; else if (final.liYi === 8 && final.quCai === 8) final.content = 7; else final.content = Math.round((final.liYi + final.quCai) / 2); }
                        if (final.ciHui < 8 || final.wenXueXing < 8) { final.content = Math.min(final.content, 7); }
                        if (final.ciHui === final.wenXueXing) { final.expression = final.ciHui - 1; } else { final.expression = Math.min(final.ciHui, final.wenXueXing); }
                        const structureLowerBound = final.content - 1;
                        final.structure = Math.min(final.structure, final.content);
                        final.structure = Math.max(final.structure, structureLowerBound);
                        s.content = final.content; s.expression = final.expression; s.structure = final.structure;
                        s.radar.立意 = final.liYi; s.radar.取材 = final.quCai; s.radar.詳略 = final.xiangLue;
                        s.radar.詞彙 = final.ciHui; s.radar.文學性 = final.wenXueXing; s.radar.扣題 = final.kouTi;
                    }
                    return s;
                };
                
                const applyWordCountRule = (scores, textContent) => {
                     let s = JSON.parse(JSON.stringify(scores));
                     const wordCount = textContent.length;
                     if (wordCount < 900) {
                        s.content = Math.min(s.content, 5); s.structure = Math.min(s.structure, 5);
                        if (s.radar) { s.radar.立意 = Math.min(s.radar.立意, 5); s.radar.取材 = Math.min(s.radar.取材, 5); s.radar.詳略 = Math.min(s.radar.詳略, 5); }
                     }
                     return s;
                };

                let finalQwenScores = applyV8Rules(originalScores);
                finalQwenScores = applyWordCountRule(finalQwenScores, fullTextContent);
                let finalLlama3Scores = applyWordCountRule(llama3Scores, fullTextContent);
                finalLlama3Scores = applyContentStructureRule(finalLlama3Scores);

                console.log("Qwen V8規則後分數:", JSON.parse(JSON.stringify(finalQwenScores)));
                console.log("Llama-3 (應用所有規則後)分數:", JSON.parse(JSON.stringify(finalLlama3Scores)));

                const totalQwen = (finalQwenScores.content * 4) + (finalQwenScores.expression * 3) + (finalQwenScores.structure * 2) + 5 + 1;
                const totalLlama3 = (finalLlama3Scores.content * 4) + (finalLlama3Scores.expression * 3) + (finalLlama3Scores.structure * 2) + 5 + 1;
                
                if (totalLlama3 > totalQwen) {
                    scoresForDisplay = finalLlama3Scores;
                    console.log("決策: Llama-3 最終總分較高，採用其結果。");
                } else {
                    scoresForDisplay = finalQwenScores;
                    console.log("決策: Qwen 最終總分較高或相等，採用其結果。");
                }

            } catch (e) {
                console.error("解析、比對或應用評分規則時出錯:", e);
                scoresForDisplay = null;
            }
        } else {
            console.warn("敘事抒情文缺少雙模型評分資料，無法進行驗證。");
            scoresForDisplay = null;
        }
    } 
    else if (uniqueIdPrefix === 'argument') {
        if (originalGradingMatch && originalGradingMatch[1]) {
             try {
                const originalScores = JSON.parse(originalGradingMatch[1].trim());
                console.log("--- 單模型原始評分 (議論文) ---");
                console.log("模型原始評分 (未經處理):", JSON.parse(JSON.stringify(originalScores)));
                scoresForDisplay = originalScores;

             } catch(e) {
                console.error("解析議論文原始評分時出錯:", e);
                scoresForDisplay = null;
             }
        } else {
             console.warn("議論文缺少評分資料，無法進行處理。");
             scoresForDisplay = null;
        }
    } else {
        console.warn("未知的文章類型或評分資料缺失。");
        scoresForDisplay = null;
    }
    
    if (scoresForDisplay) {
        scoresForDisplay = applyFinalConsistencyRule(scoresForDisplay);
        const finalTotalScoreAfterRules = (scoresForDisplay.content * 4) + (scoresForDisplay.expression * 3) + (scoresForDisplay.structure * 2) + 5 + 1;
        finalGradeForDisplay = determineGrade(Math.min(finalTotalScoreAfterRules, 100));
        console.log("最終把關規則後的分數:", JSON.parse(JSON.stringify(scoresForDisplay)));
        console.log("基於最終分數重新計算的總分:", finalTotalScoreAfterRules);
        console.log("基於最終分數重新計算的等級:", finalGradeForDisplay);
    }

    if (scoresForDisplay) {
        const wordCount = fullTextContent.length;
        if (wordCount < 500) {
            console.log(`字數嚴重不足 (${wordCount}字)，強制評為等級1。`);
            scoresForDisplay = {
                content: 1, 
                expression: 1, 
                structure: 1, 
                radar: { "立意": 1, "取材": 1, "扣題": 1, "詳略": 1, "詞彙": 1, "文學性": 1 }
            };
            finalGradeForDisplay = "1";
        }
        else if (wordCount < 800) {
            const gradeHierarchy = ["1", "2", "3", "4", "5", "5*", "5**"];
            const originalGradeIndex = gradeHierarchy.indexOf(finalGradeForDisplay);
            const maxGradeIndex = gradeHierarchy.indexOf("3");
            if (originalGradeIndex > maxGradeIndex) {
                console.log(`字數不足800字 (${wordCount}字)，原等級 ${finalGradeForDisplay} 被強制降為最高等級3。`);
                finalGradeForDisplay = "3";
            }
        }
    }

    const originalCritiqueText = critiqueMatch ? critiqueMatch[1].trim() : "未生成點評";
    let finalCritiqueText = originalCritiqueText;
    let critiqueRewriteInstruction = "";

    if (finalGradeForDisplay === "5**") {
        critiqueRewriteInstruction = "點評中應為讚賞。請完全移除所有批評或負面評價，只保留或改寫為讚賞和肯定。";
    } else if (finalGradeForDisplay === "5*" || finalGradeForDisplay === "5") {
        critiqueRewriteInstruction = "點評主要以讚賞為主。請保留主要的優點分析，可以提及一兩個微小的、建設性的改進建議，但整體基調必須是正面的。";
    } else if (finalGradeForDisplay === "4") {
        critiqueRewriteInstruction = "點評應有褒有貶。請確保評論中既包含對優點的肯定，也包含對主要缺點的明確指出，兩者份量應大致均衡。";
    } else {
        critiqueRewriteInstruction = "點評以批評為主。請集中分析文章存在的核心問題，指出需要優先改進的地方。可以簡單提及一兩個做得尚可的地方作為鼓勵，但主要篇幅應用於批評。";
    }
    
    const rewritePrompt = `你是一個中文科老師的助手，你的任務是根據最終的評級，調整一篇已寫好的點評的語氣。

    ### 原始文章
    ${fullTextContent}

    ### 原始點評
    ${originalCritiqueText}

    ### 最終等級
    ${finalGradeForDisplay}

    ### 語氣調整指令
    ${critiqueRewriteInstruction}

    ### 你的任務
    請根據「語氣調整指令」，重寫「原始點評」。
    - 你的輸出**只能**是重寫後的點評文字。
    - 保持原有的列點格式。
    - **絕對不要**包含任何額外的解釋、標題或XML標籤。直接輸出調整後的點評即可。`;

    try {
        finalCritiqueText = await callReadingAPI(rewritePrompt, 0.5); 
    } catch (e) {
        console.error("重寫點評失敗，將使用原始點評:", e);
        finalCritiqueText = originalCritiqueText;
    }

    if (scoresForDisplay) {
        finalHTML += createGradingSystemHTML(uniqueIdPrefix);
    } else {
        finalHTML += "<p>評等資料不完整，無法顯示分數。</p>";
    }
    if (finalCritiqueText) {
        finalHTML += createBulletedListHTML("點評", finalCritiqueText);
    }
    if (suggestionsMatch && suggestionsMatch[1]) {
        finalHTML += createBulletedListHTML("建議", suggestionsMatch[1].trim());
    }
    if (rewriteMatch && rewriteMatch[1]) {
        // 【核心修訂】在這裡移除「改寫範例」中的星號
        const rewriteContent = rewriteMatch[1].trim().replace(/\*/g, '').replace(/\n/g, '<br>');
        finalHTML += `<div class="rewrite-explanation-container"><div class="rewrite-explanation-card"><h3>改寫範例</h3><p>${rewriteContent}</p></div></div>`;
    }

    resultContainer.innerHTML = finalHTML;

    if (scoresForDisplay) {
        initializeGradingSystem(uniqueIdPrefix, scoresForDisplay, finalGradeForDisplay);
    }

// --- 新增：儲存到 IndexedDB (修訂版：解決雷達圖不顯示問題) ---
    if (scoresForDisplay) { 
        if (uniqueIdPrefix === 'narrative') {
            const topic = localStorage.getItem("currentTopic") || "無題目";
            
            // ★ 關鍵修改：使用 captureContainerHTML 抓取 'writingGradingResult' 容器
            // 這會將雷達圖 Canvas 轉為圖片，確保在歷史紀錄中能看見
            const htmlContent = captureContainerHTML('writingGradingResult'); 
            
            saveToHistory("敘事抒情", "文章點評", topic, `題目：${topic}\n\n文章：${fullTextContent}`, htmlContent);
            
        } else if (uniqueIdPrefix === 'argument') {
            const topic = localStorage.getItem("argumentCurrentTopic") || "無題目";
            
            // ★ 關鍵修改：使用 captureContainerHTML 抓取 'argumentGradingResult' 容器
            const htmlContent = captureContainerHTML('argumentGradingResult'); 
            
            saveToHistory("議論", "文章點評", topic, `題目：${topic}\n\n文章：${fullTextContent}`, htmlContent);
        }
    }
	
}


// =======================================================
// === 評等系統邏輯結束 ===
// =======================================================

document.addEventListener('DOMContentLoaded', function() {

// --- 為動態生成的「自訂題目」輸入框加上排除標記 ---
const originalShowCustomTopicInput = window.showCustomTopicInput;
window.showCustomTopicInput = function(buttonElement) {
originalShowCustomTopicInput(buttonElement);
const customTopicInput = document.getElementById('customTopic');
if (customTopicInput) {
customTopicInput.classList.add('no-modal-editor');
}
// For writing custom topic with focus and plot
const customTitle = document.getElementById('customTitle');
const customFocus = document.getElementById('customFocus');
const customPlot = document.getElementById('customPlot');
if(customTitle) customTitle.classList.add('no-modal-editor');
if(customFocus) customFocus.classList.add('no-modal-editor');
if(customPlot) customPlot.classList.add('no-modal-editor');
};

const originalShowArgumentCustomTopicInput = window.showArgumentCustomTopicInput;
window.showArgumentCustomTopicInput = function(buttonElement) {
originalShowArgumentCustomTopicInput(buttonElement);
const argumentCustomTopicInput = document.getElementById('argumentCustomTopic');
if (argumentCustomTopicInput) {
argumentCustomTopicInput.classList.add('no-modal-editor');
}
};

const originalShowExpandCustomTopicInput = window.showExpandCustomTopicInput;
window.showExpandCustomTopicInput = function(buttonElement) {
originalShowExpandCustomTopicInput(buttonElement);
const container = document.getElementById('expandCustomTopicInputArea');
if (container) {
container.querySelectorAll('input[type="text"], textarea').forEach(el => el.classList.add('no-modal-editor'));
}
};

// --- 懸浮視窗核心邏輯 ---
const modal = document.getElementById('outline-editor-modal');
const modalTextarea = document.getElementById('modal-textarea');
const modalTitle = document.getElementById('modal-title');
const modalSaveBtn = document.getElementById('modal-save-btn');
const modalCloseBtn = document.getElementById('modal-close-btn');

if (!modal || !modalTextarea || !modalSaveBtn || !modalCloseBtn) {
console.error("懸浮視窗的 HTML 結構不完整或未找到！");
return;
}

let currentEditingElement = null;

function openModalEditor(element) {
currentEditingElement = element;
modalTextarea.value = currentEditingElement.value;
let titleText = '編輯內容';

if (element.id === 'writingContent' || element.id === 'argumentWritingContent') {
titleText = '輸入您的文章';
} else {
const parentTableCell = element.closest('td');
if (parentTableCell) {
const parentRow = parentTableCell.closest('tr');
if (parentRow) {
const headerCell = parentRow.cells[0];
const table = parentRow.closest('table');
if (table && table.rows.length > 0) {
const columnHeaderCell = table.rows[0].cells[parentTableCell.cellIndex];
const rowTitle = headerCell ? headerCell.textContent.trim().replace(/[:：]/g, '') : '';
const colTitle = columnHeaderCell ? columnHeaderCell.textContent.trim().replace(/[:：]/g, '') : '';
if (rowTitle && colTitle && rowTitle !== colTitle) {
titleText = `編輯「${rowTitle}」的「${colTitle}」`;
} else if (rowTitle) {
titleText = `編輯「${rowTitle}」`;
} else if (colTitle) {
titleText = `編輯「${colTitle}」`;
}
}
}
} else {
let associatedLabel = document.querySelector(`label[for="${element.id}"]`);
if (!associatedLabel) {
const parentContainer = element.closest('div');
if (parentContainer) {
associatedLabel = parentContainer.querySelector('label');
}
}
if (associatedLabel) {
titleText = `編輯「${associatedLabel.textContent.trim().replace(/[:：]/g, '')}」`;
}
}
}
modalTitle.textContent = titleText;
modal.style.display = 'flex';
modalTextarea.focus();
}

function closeModalEditor() {
modal.style.display = 'none';
currentEditingElement = null;
}

function saveAndCloseEditor() {
if (currentEditingElement) {
currentEditingElement.value = modalTextarea.value;
if (currentEditingElement.id === 'expandContent') {
updateCharCount();
}
}
closeModalEditor();
}

document.body.addEventListener('click', function(event) {
const target = event.target;
const isTextInput = target.tagName === 'INPUT' && target.type === 'text';
const isTextarea = target.tagName === 'TEXTAREA';
if ((isTextInput || isTextarea) && !target.classList.contains('no-modal-editor') && target.id !== 'modal-textarea') {
event.preventDefault();
openModalEditor(target);
}
});

modalSaveBtn.addEventListener('click', saveAndCloseEditor);
modalCloseBtn.addEventListener('click', closeModalEditor);


// --- OCR 整合邏輯 ---
const ocrBtn = document.getElementById('modal-ocr-btn');
let ocrWindow = null;
const VERCEL_OCR_URL = 'https://gemini-ocr-proxy.vercel.app/';

if (ocrBtn) {
ocrBtn.addEventListener('click', function() {
if (ocrWindow && !ocrWindow.closed) {
ocrWindow.focus();
return;
}
ocrWindow = window.open(VERCEL_OCR_URL, 'OCRWindow', 'width=650,height=850,scrollbars=yes,resizable=yes');
});
}

window.addEventListener('message', function(event) {
if (event.origin !== new URL(VERCEL_OCR_URL).origin) {
console.warn('收到來源不明的訊息，已忽略:', event.origin);
return;
}
if (event.data && event.data.type === 'ocrResult') {
const ocrText = event.data.text;
modalTextarea.value += (modalTextarea.value.trim() ? '\n' : '') + ocrText;
if (ocrWindow) {
ocrWindow.close();
}
modalTextarea.focus();
}
});
});

/**
 * 【最終把關規則修訂 v3】
 * 當「扣題」分數為 4 分或以下時，強制將多個核心項目分數的上限限制在 4 分。
 * @param {object} scores - 從 AI 模型解析或初步處理後的原始評分物件。
 * @returns {object} - 經過此規則嚴格調整後的最終評分物件。
 */
function applyFinalConsistencyRule(scores) {
    // 建立一個分數物件的深層複本，避免直接修改傳入的物件
    let s = JSON.parse(JSON.stringify(scores)); 
    
    // 從 radar 物件中安全地獲取「扣題」分數，若不存在則預設為 0
    const kouTi = s.radar ? s.radar.扣題 || 0 : 0;
    
    // 【核心修訂】將觸發條件從 <= 5 改為 <= 4
    if (kouTi <= 4) {
        console.log(`觸發扣題分數把關規則 v3：偵測到扣題分數 (${kouTi}) 低於或等於 4，將相關分數上限設為 4。`);

        // 使用 Math.min() 確保分數不會超過 4。
        // 如果原始分數低於 4（例如 3），則會保留較低的 3 分。
        // 如果原始分數高於 4（例如 6），則會被強制降為 4 分。
        
        // 1. 強制限制雷達圖中的「立意」、「取材」、「詳略」分數
        if (s.radar) {
            s.radar.立意 = Math.min(s.radar.立意, 4);
            s.radar.取材 = Math.min(s.radar.取材, 4);
            s.radar.詳略 = Math.min(s.radar.詳略, 4);
        }

        // 2. 強制限制總項分數中的「內容」和「結構」分數
        s.content = Math.min(s.content, 4);
        s.structure = Math.min(s.structure, 4);
    }
    
    // 在控制台中輸出日誌，方便追蹤規則是否被正確應用及其調整結果
    console.log(`扣題把關規則 v3 應用後：扣題=${kouTi}，調整後立意=${s.radar ? s.radar.立意 : 'N/A'}，取材=${s.radar ? s.radar.取材 : 'N/A'}，詳略=${s.radar ? s.radar.詳略 : 'N/A'}，內容=${s.content}，結構=${s.structure}`);
    
    // 返回經過嚴格調整後的分數物件
    return s;
}




document.addEventListener('DOMContentLoaded', function() {
    const sideMenuToggle = document.getElementById('sideMenuToggle');
    const sideMenu = document.getElementById('sideMenu');
    const sideMenuHomeBtn = document.getElementById('sideMenuHomeBtn');

// 修改這段代碼，增加對工具一覽頁面的判斷
sideMenuToggle.addEventListener('click', function(e) {
    e.stopPropagation();
    if (sideMenu.classList.contains('active')) {
        sideMenu.classList.remove('active');
        sideMenuToggle.classList.remove('active');
    } else {
        sideMenu.classList.add('active');
        sideMenuToggle.classList.add('active');
        
        // 改進判斷邏輯：不僅檢查主頁，也要檢查工具一覽頁面
        const isOnMainPage = document.querySelector('.title-container').style.display !== 'none';
        const isOnToolsPage = document.getElementById('toolsContainer2').style.display === 'flex';
        
        if (isOnMainPage && !isOnToolsPage) {
            sideMenuHomeBtn.style.display = 'none';
            // 隱藏工具一覽按鈕
            const toolsBtn = document.querySelector('#sideMenu .side-menu-item:nth-child(2)');
            if(toolsBtn) toolsBtn.style.display = 'flex';
        } else {
            sideMenuHomeBtn.style.display = 'flex';
            // 在工具一覽頁面和範疇頁面都隱藏工具一覽按鈕
            const toolsBtn = document.querySelector('#sideMenu .side-menu-item:nth-child(2)');
            if(toolsBtn) toolsBtn.style.display = 'none';
        }
    }
});

    // 點擊選單項目後自動收起選單
    const menuItems = document.querySelectorAll('.side-menu-item');
    menuItems.forEach(item => {
        item.addEventListener('click', function() {
            sideMenu.classList.remove('active');
            sideMenuToggle.classList.remove('active');
        });
    });

    // 點擊頁面其他區域收起選單
    document.addEventListener('click', function(e) {
        if (sideMenu.classList.contains('active') && 
            !sideMenu.contains(e.target) && 
            e.target !== sideMenuToggle) {
            sideMenu.classList.remove('active');
            sideMenuToggle.classList.remove('active');
        }
    });
});

// 從側邊選單打開工具一覽
function openToolsFromSideMenu() {
    document.getElementById('sideMenu').classList.remove('active');
    document.getElementById('expandToolsBtn2').click(); // 觸發原有的工具一覽邏輯
}

// 切換音樂播放器顯示/隱藏
function toggleMusicPlayer() {
    const musicPlayer = document.getElementById('music-player');
    
    if (musicPlayer.style.display === 'none' || musicPlayer.style.display === '') {
        musicPlayer.style.display = 'flex';
        // 移除下面這行：showPlayerBtn.style.display = 'none';
    } else {
        musicPlayer.style.display = 'none';
        // 移除下面這行：showPlayerBtn.style.display = 'block';
    }
    
    // 收起側邊選單
    document.getElementById('sideMenu').classList.remove('active');
}

// === 優化版：帶動畫的返回主頁 ===
const performReturnToHomeLogic = window.returnToHome || function() {}; // 備份舊邏輯引用(如果有的話)

// === 優化版：帶動畫的返回主頁 (修復滾動鎖定與視窗殘留) ===
window.returnToHome = function() {
    // 1. 找出當前正在顯示的容器
    const activeContainer = document.querySelector(
        '#writingContainer[style*="display: block"], ' +
        '#readingContainer[style*="display: block"], ' +
        '#booksContainer[style*="display: block"], ' +
        '#expandContainer[style*="display: block"], ' +
        '#argumentContainer[style*="display: block"], ' +
        '#historyContainer[style*="display: block"], ' +
        '#toolsContainer2[style*="display: flex"]'
    );

    // 2. 如果找到了正在顯示的頁面，先播動畫
    if (activeContainer) {
        activeContainer.classList.add('page-exit-shrink');

        // 3. 等待動畫播完再執行清理
        setTimeout(() => {
            // A. 隱藏所有主要功能容器
            const containers = ['writingContainer', 'readingContainer', 'booksContainer', 'expandContainer', 'argumentContainer', 'historyContainer', 'toolsContainer2'];
            containers.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.style.display = "none";
                    el.classList.remove('page-exit-shrink');
                    el.style.opacity = "";
                    el.style.transform = "";
                }
            });

            // ★★★ B. 關鍵修復：解鎖頁面捲動 ★★★
            document.body.style.overflow = 'auto'; 
            document.body.style.height = 'auto'; // 確保高度自適應

            // C. 恢復主頁背景
            document.body.style.backgroundImage = `url('${scenes['home']}')`;
            document.body.style.backgroundColor = '';

            // D. 顯示主頁元素
            document.querySelector('.title-container').style.display = 'block';
            document.getElementById('hitokoto-container').style.display = 'block';
            document.getElementById('mainMenuBox').style.display = 'block';
            
            // E. 顯示 DSE 倒數
            const dseBox = document.getElementById('dse-countdown-box');
            if (dseBox) dseBox.style.display = 'flex';

            // F. 隱藏返回按鈕
            document.getElementById('sideMenuHomeBtn').style.display = 'none';
            document.getElementById('homeBtn').style.display = 'none';

            // G. 移除卡片 active 狀態
            document.querySelectorAll('.anime-card').forEach(card => card.classList.remove('active'));

            // H. 收起側邊選單
            const sideMenu = document.getElementById('sideMenu');
            if (sideMenu) {
                sideMenu.classList.remove('active');
                document.getElementById('sideMenuToggle').classList.remove('active');
            }
            
            // I. 隱藏儲存按鈕
            hideAllSaveHtmlButtons();

            // J. 確保舊版工具箱隱藏
            const toolsBox = document.getElementById('toolsBox');
            if (toolsBox) toolsBox.style.display = 'none';

            // K. 隱藏歷史紀錄詳情與大綱編輯視窗
            const historyModal = document.getElementById('historyModal');
            if (historyModal) historyModal.style.display = 'none';
            
            const outlineModal = document.getElementById('outline-editor-modal');
            if (outlineModal) outlineModal.style.display = 'none';

            // L. 強制關閉語薈的「預覽視窗」與「影片視窗」
            const previewModal = document.getElementById('previewModal');
            const previewIframe = document.getElementById('previewIframe');
            if (previewModal) {
                previewModal.style.display = 'none';
                if (previewIframe) previewIframe.src = 'about:blank';
            }

            const videoModal = document.getElementById('videoModal');
            const videoIframe = document.getElementById('videoIframe');
            if (videoModal) {
                videoModal.style.display = 'none';
                if (videoIframe) videoIframe.src = '';
            }

            // M. 滾動到頂部
            window.scrollTo({ top: 0, behavior: 'instant' });

            // N. 觸發主頁進場動畫
            const mainMenu = document.getElementById('mainMenuBox');
            const dse = document.getElementById('dse-countdown-box');
            
            if (mainMenu) {
                mainMenu.classList.remove('home-enter-pop');
                void mainMenu.offsetWidth; 
                mainMenu.classList.add('home-enter-pop');
            }
            if (dse) {
                dse.classList.remove('home-enter-pop');
                void dse.offsetWidth;
                dse.classList.add('home-enter-pop');
            }

        }, 350); 
        
    } else {
        // 如果沒有偵測到活動頁面，直接重整或重置
        document.body.style.overflow = 'auto'; // 保險起見這裡也加一行
        location.reload(); 
    }
};

// ==========================================
// === IndexedDB 歷史紀錄系統 (V2 層級版) ===
// ==========================================

const DB_NAME = 'SansiDB';
const DB_VERSION = 1;
const STORE_NAME = 'history';

// 定義層級結構 (主範疇 -> 子功能)
const HISTORY_STRUCTURE = {
    "閱讀": ["點評", "指引"],
    "敘事抒情": ["文章點評", "大綱點評", "解題指引", "敘事物象"],
    "議論": ["文章點評", "大綱點評", "指引"],
    "整合拓展": ["點評", "指引"]
};

// 1. 初始化資料庫 (保持不變)
function openHistoryDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onupgradeneeded = function(event) {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                const store = db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                store.createIndex('timestamp', 'timestamp', { unique: false });
                store.createIndex('category', 'category', { unique: false });
                store.createIndex('subFunction', 'subFunction', { unique: false });
            }
        };
        request.onsuccess = function(event) { resolve(event.target.result); };
        request.onerror = function(event) { reject(event.target.error); };
    });
}

// 2. ★ 核心輔助：捕捉 HTML 並將 Canvas 轉為圖片 ★
function captureContainerHTML(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return "";

    // 1. 複製節點，避免影響畫面
    const clone = container.cloneNode(true);

    // 2. 處理 Canvas (雷達圖)
    // 我們必須從 *原始* 容器中獲取 Canvas，因為 clone 中的 canvas 是空的
    const originalCanvases = container.querySelectorAll('canvas');
    const clonedCanvases = clone.querySelectorAll('canvas');

    originalCanvases.forEach((originalCanvas, index) => {
        if (clonedCanvases[index]) {
            try {
                // 將 Canvas 轉為圖片 Data URL
                const imgUrl = originalCanvas.toDataURL('image/png');
                const img = document.createElement('img');
                img.src = imgUrl;
                img.className = 'radar-chart-history-img'; // 添加樣式類
                
                // 替換 clone 中的 canvas
                clonedCanvases[index].parentNode.replaceChild(img, clonedCanvases[index]);
            } catch (e) {
                console.error("Canvas 轉換失敗:", e);
            }
        }
    });

    // 3. 處理可能存在的 input/textarea (確保值被保留)
    // 雖然歷史紀錄主要存 AI 回應，但若有包含用家輸入框，需保留
    // 這裡主要針對顯示用的 HTML，通常不需要處理輸入框，除非有點評表格包含 textarea
    
    return clone.innerHTML;
}

// 3. 儲存紀錄 (使用處理過的 HTML)
async function saveToHistory(category, subFunction, title, userContent, aiContent) {
    try {
        const db = await openHistoryDB();
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);

        const record = {
            category: category,
            subFunction: subFunction,
            title: title || "無標題",
            userContent: userContent,
            aiContent: aiContent, // 這裡必須傳入已經轉換好圖片的 HTML string
            timestamp: new Date().getTime(),
            dateStr: new Date().toLocaleString('zh-HK', { hour12: false })
        };

        store.add(record);
        console.log("紀錄已儲存");
    } catch (error) {
        console.error("儲存紀錄失敗:", error);
    }
}

// ================= UI 導航邏輯 =================

// 變數儲存當前導航狀態
let currentCategoryFilter = null;
let currentSubFunctionFilter = null;

// 4. 開啟歷史頁面 (進入第一層)
function openHistoryContainer() {
    // 隱藏其他所有容器 (包含功能頁面)
    const containers = ['writingContainer', 'readingContainer', 'booksContainer', 'expandContainer', 'argumentContainer', 'mainMenuBox', 'hitokoto-container', 'dse-countdown-box', 'toolsBox'];
    containers.forEach(id => {
        const el = document.getElementById(id);
        if(el) el.style.display = 'none';
    });
    document.querySelector('.title-container').style.display = 'none';
    
    // 顯示歷史容器
    const historyContainer = document.getElementById('historyContainer');
    historyContainer.style.display = 'block';
    
    // 顯示返回主頁按鈕
    document.getElementById('sideMenuHomeBtn').style.display = 'flex';
    document.getElementById('sideMenu').classList.remove('active');

    // 渲染第一層
    renderHistoryCategories();
}

// 5. 渲染第一層：主範疇
// ==========================================
// === 歷史紀錄 UI 渲染邏輯 (修訂版) ===
// ==========================================

// 定義範疇與圖片的對應關係 (確保與主頁一致)
const CATEGORY_ASSETS = {
    "閱讀": { img: '郵筒.png', en: 'READING' },
    "敘事抒情": { img: '相機.png', en: 'NARRATIVE' },
    "議論": { img: '筆.png', en: 'ARGUMENT' },
    "整合拓展": { img: '火車.png', en: 'EXPAND' },
    "課外書籍": { img: '書.png', en: 'LIBRARY' } // 預留
};

// 5. 渲染第一層：主範疇 (動漫卡片風格)
// 5. 渲染第一層：主範疇 (動漫卡片風格)
function renderHistoryCategories() {
    // --- 新增：隱藏日期搜尋按鈕 (因為第一層不需要搜尋) ---
    const searchContainer = document.getElementById('historyDateSearchContainer');
    if (searchContainer) searchContainer.style.display = 'none';

    // 顯示/隱藏層級容器
    document.getElementById('historyLevel1Wrapper').style.display = 'flex'; // Wrapper 需要 flex
    document.getElementById('historyLevel2').style.display = 'none';
    document.getElementById('historyLevel3').style.display = 'none';

	 // ★★★ 新增這一行：觸發第一層的進場動畫 ★★★
    playEntryAnimation('historyLevel1Wrapper');
    
    // 隱藏麵包屑 (第一層不需要)
    document.getElementById('historyBreadcrumb').style.display = 'none';
    
    const container = document.getElementById('historyLevel1');
    const categories = Object.keys(HISTORY_STRUCTURE); // ["閱讀", "敘事抒情", "議論", "整合拓展"]
    
    let html = '';

    categories.forEach(cat => {
        const asset = CATEGORY_ASSETS[cat] || { img: '背景.png', en: 'RECORD' };
        
        // 生成與主頁完全一致的卡片 HTML
        // 注意：這裡移除了 id 屬性以避免衝突，改用 onclick 直接觸發歷史功能
        html += `
            <div class="anime-card" style="--bg-img: url('${asset.img}');" onclick="enterHistoryCategory('${cat}')">
                <div class="card-overlay"></div>
                <div class="card-border-effect"></div>
                <div class="card-content">
                    <div class="card-text">
                        <span class="card-zh">${cat}</span>
                        <span class="card-en">${asset.en}</span>
                    </div>
                </div>
            </div>
        `;
    });

    container.innerHTML = html;
}

// === 新增全域變數，用於傳遞顏色主題 ===
let currentThemeIndex = 1; 

// 6. 進入第二層：子功能 (修改版：分配顏色)
function enterHistoryCategory(category) {
    const searchContainer = document.getElementById('historyDateSearchContainer');
    if (searchContainer) searchContainer.style.display = 'none';

    currentCategoryFilter = category;
    
    document.getElementById('historyLevel1Wrapper').style.display = 'none';
    document.getElementById('historyLevel2').style.display = 'grid';
    document.getElementById('historyLevel3').style.display = 'none';

	 // ★★★ 新增這一行：觸發第二層的進場動畫 ★★★
    playEntryAnimation('historyLevel2');

    // 麵包屑
    const breadcrumb = document.getElementById('historyBreadcrumb');
    breadcrumb.style.display = 'flex';
    document.getElementById('breadcrumb-sep-1').style.display = 'inline';
    const catSpan = document.getElementById('breadcrumb-category');
    catSpan.textContent = category;
    catSpan.style.display = 'inline';
    document.getElementById('breadcrumb-sep-2').style.display = 'none';
    document.getElementById('breadcrumb-sub').style.display = 'none';

    const container = document.getElementById('historyLevel2');
    const subFunctions = HISTORY_STRUCTURE[category] || [];
    
    let html = '';
    
    const subIcons = {
        "文章點評": "fa-file-alt",
        "大綱點評": "fa-list-ol",
        "敘事物象": "fa-tree",
        "解題指引": "fa-compass",
        "指引": "fa-lightbulb",
        "點評": "fa-comment-dots"
    };

    // ★★★ 核心修改：為每個子功能分配一個固定的顏色索引 (1-5) ★★★
    subFunctions.forEach((sub, index) => {
        // 使用 index % 5 + 1 確保顏色在 1~5 之間循環，並讓不同按鈕顏色不同
        const themeIndex = (index % 5) + 1;
        
        // 在 onclick 中傳遞 themeIndex
        html += `
            <div class="history-folder-btn history-theme-${themeIndex}" onclick="enterHistoryList('${sub}', ${themeIndex})">
                <i class="fas ${subIcons[sub] || 'fa-file'}"></i>
                <span>${sub}</span>
            </div>
        `;
    });

    if (subFunctions.length === 0) {
        html = '<p style="grid-column: 1/-1; text-align:center; color: #666;">此範疇暫無子功能定義。</p>';
    }

    container.innerHTML = html;
}

// 7. 進入第三層：紀錄列表 (修改版：接收並儲存顏色)
async function enterHistoryList(subFunction, themeIndex) {
    currentSubFunctionFilter = subFunction;
    
    // ★★★ 儲存傳入的顏色索引，供渲染列表時使用 ★★★
    // 如果是從麵包屑返回，themeIndex 可能為 undefined，則保持原值或預設為 1
    if (themeIndex) {
        currentThemeIndex = themeIndex;
    }

    document.getElementById('historyLevel1Wrapper').style.display = 'none';
    document.getElementById('historyLevel2').style.display = 'none';
    document.getElementById('historyLevel3').style.display = 'flex';

	// ★★★ 新增這一行：觸發第三層的進場動畫 ★★★
    playEntryAnimation('historyLevel3');
    
    const searchContainer = document.getElementById('historyDateSearchContainer');
    if (searchContainer) searchContainer.style.display = 'block';

    // 麵包屑邏輯 (樣式已在 CSS 修改為莫蘭迪色)
    const breadcrumb = document.getElementById('historyBreadcrumb');
    breadcrumb.style.display = 'flex';

    const homeSpan = breadcrumb.querySelector('span[onclick="renderHistoryCategories()"]');
    homeSpan.innerHTML = '<i class="fas fa-home"></i> 主範疇';
    
    document.getElementById('breadcrumb-sep-1').style.display = 'inline';
    
    const catSpan = document.getElementById('breadcrumb-category');
    catSpan.textContent = currentCategoryFilter;
    catSpan.style.display = 'inline';
    catSpan.setAttribute('onclick', `enterHistoryCategory('${currentCategoryFilter}')`);
    
    document.getElementById('breadcrumb-sep-2').style.display = 'inline';
    
    const subSpan = document.getElementById('breadcrumb-sub');
    subSpan.textContent = subFunction;
    subSpan.style.display = 'inline';

    const listContainer = document.getElementById('historyLevel3');
    listContainer.innerHTML = '<div style="text-align:center; padding:20px;"><i class="fas fa-spinner fa-spin"></i> 載入中...</div>';

    try {
        const db = await openHistoryDB();
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const index = store.index('timestamp');
        const request = index.openCursor(null, 'prev');

        const records = [];
        request.onsuccess = function(event) {
            const cursor = event.target.result;
            if (cursor) {
                const r = cursor.value;
                if (r.category === currentCategoryFilter && r.subFunction === subFunction) {
                    records.push(r);
                }
                cursor.continue();
            } else {
                renderFilteredRecords(records);
            }
        };
    } catch (error) {
        console.error("讀取失敗:", error);
        listContainer.innerHTML = '<p>讀取失敗，請重試。</p>';
    }
}

// 8. 渲染列表卡片 (修改版：統一顏色)
// === 優化版：渲染列表卡片 (整張卡片可點擊) ===
function renderFilteredRecords(records) {
    const listContainer = document.getElementById('historyLevel3');
    listContainer.innerHTML = '';

    if (records.length === 0) {
        listContainer.innerHTML = `
            <div style="text-align:center; color:#999; margin-top:40px; grid-column: 1/-1; font-family: 'Noto Serif TC', serif;">
                <i class="far fa-file-alt" style="font-size: 40px; margin-bottom: 15px; opacity: 0.5;"></i>
                <p>此處尚無紀錄，靜待落筆。</p>
            </div>`;
        listContainer.style.display = 'flex';
        listContainer.style.justifyContent = 'center';
        return;
    } else {
        listContainer.style.display = 'grid';
    }

    records.forEach((record) => {
        const accentClass = `history-theme-${currentThemeIndex}`;

        const dateObj = new Date(record.timestamp);
        const dateStr = dateObj.toLocaleDateString('zh-HK', { 
            year: 'numeric', 
            month: '2-digit', 
            day: '2-digit' 
        }).replace(/\//g, '-');

        const card = document.createElement('div');
        card.className = `history-card ${accentClass}`;
        card.setAttribute('data-timestamp', record.timestamp);
        
        // ★★★ 關鍵修改 1：將點擊事件移到最外層容器 ★★★
        // 這樣點擊卡片的任何留白處都能打開視窗
        card.setAttribute('onclick', `viewHistoryDetail(${record.id})`);

        card.innerHTML = `
            <!-- ★★★ 關鍵修改 2：移除這裡內層 div 的 onclick，改為純佈局容器 ★★★ -->
            <div style="flex-grow: 1;">
                <div class="history-meta">
                    <span class="history-tag">${record.subFunction}</span>
                    <span class="history-date">${dateStr}</span>
                </div>
                
                <!-- 
                    標題保留自己的 onclick/ondblclick 邏輯。
                    因為 handleTitleClick 裡面有 event.stopPropagation()，
                    所以點標題時不會觸發外層的直接打開，而是執行標題專屬的「延遲判斷雙擊」邏輯。
                -->
                <h4 class="history-title" 
                    onclick="handleTitleClick(event, ${record.id})"
                    ondblclick="handleTitleDblClick(this, ${record.id})"
                    title="單擊查看詳情，雙擊直接修改標題">
                    ${record.title}
                </h4>
            </div>
            
            <div class="history-actions">
                <!-- 刪除按鈕必須保留 stopPropagation，否則刪除時會同時彈出視窗 -->
                <button class="btn-delete-history" onclick="event.stopPropagation(); deleteHistoryItem(${record.id})" title="刪除此紀錄">
                    <i class="fas fa-trash-alt"></i>
                </button>
            </div>
        `;

        listContainer.appendChild(card);
    });
}

	
// 9. 刪除與清空 (保持類似)
async function deleteHistoryItem(id) {
    if (!confirm("確定要刪除這條紀錄嗎？")) return;
    try {
        const db = await openHistoryDB();
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        store = transaction.objectStore(STORE_NAME);
        store.delete(id);
        transaction.oncomplete = function() {
            enterHistoryList(currentSubFunctionFilter); // 重新整理當前列表
        };
    } catch (e) { console.error(e); }
}

async function clearAllHistory() {
    if (!confirm("警告：確定要清空所有歷史紀錄嗎？")) return;
    try {
        const db = await openHistoryDB();
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        store = transaction.objectStore(STORE_NAME);
        store.clear();
        transaction.oncomplete = function() {
            if(document.getElementById('historyLevel3').style.display === 'flex') {
                enterHistoryList(currentSubFunctionFilter);
            } else {
                alert("紀錄已清空");
            }
        };
    } catch (e) { console.error(e); }
}

// 優化後的查看詳情函數
async function viewHistoryDetail(id) {
    try {
        const db = await openHistoryDB();
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(id);

        request.onsuccess = function(event) {
            const record = event.target.result;
            if (record) {
                // --- 1. 計算該子功能的莫蘭迪色系索引 (1-5) ---
                let themeIndex = 1; // 預設值
                if (HISTORY_STRUCTURE[record.category]) {
                    const subIndex = HISTORY_STRUCTURE[record.category].indexOf(record.subFunction);
                    if (subIndex !== -1) {
                        // 邏輯與列表頁保持一致：(index % 5) + 1
                        themeIndex = (subIndex % 5) + 1;
                    }
                }
                const themeClass = `history-theme-context-${themeIndex}`;
                // --------------------------------------------------

                // 設定標題，並將圖標換成對應顏色
                const colorVar = `var(--m-color-${themeIndex})`;
                document.getElementById('historyModalTitle').innerHTML = 
                    `<i class="fas fa-book-open" style="color:${colorVar}"></i> 
                     <span style="color:#333">${record.category}</span> 
                     <span style="font-size:0.8em; color:#bbb; margin: 0 5px;">/</span> 
                     <span style="color:${colorVar}; font-weight:bold;">${record.subFunction}</span>`;
                
                // 隱藏舊日期
                const dateElement = document.getElementById('historyModalDate');
                if (dateElement) dateElement.style.display = "none"; 
                
                let contentHTML = '';

                // --- 輸入內容：智能解析邏輯 ---
                if (record.userContent) {
                    const rawText = record.userContent;
                    const lines = rawText.split('\n');
                    
                    // 這裡加上了計算出來的顏色 class
                    let parsedHTML = `<div class="history-parsed-container ${themeClass}">`;
                    
                    let currentLabel = '輸入內容'; 
                    let currentContent = [];
                    
                    // 正則：偵測標題行
                    const labelRegex = /^(.{2,10}?)[：:](.*)$/;

                    lines.forEach((line, index) => {
                        const match = line.match(labelRegex);
                        if (match) {
                            // 結算上一段
                            if (currentContent.length > 0) {
                                parsedHTML += `
                                    <div class="history-item-block">
                                        <div class="history-item-label">${currentLabel}</div>
                                        <div class="history-item-content">${currentContent.join('\n')}</div>
                                    </div>`;
                            }
                            // 開啟新一段
                            currentLabel = match[1].trim(); 
                            const restOfLine = match[2].trim();
                            currentContent = restOfLine ? [restOfLine] : []; 
                        } else {
                            if (line.trim() !== "") {
                                currentContent.push(line);
                            }
                        }
                    });

                    // 結算最後一段
                    if (currentContent.length > 0 || lines.length === 0) { 
                         const finalContent = currentContent.length > 0 ? currentContent.join('\n') : rawText;
                         parsedHTML += `
                            <div class="history-item-block">
                                <div class="history-item-label">${currentLabel}</div>
                                <div class="history-item-content">${finalContent}</div>
                            </div>`;
                    }

                    parsedHTML += '</div>';
                    
                    // 外層容器
                    contentHTML += `
                    <div style="background:#fff; padding:20px; border-radius:12px; margin-bottom:25px; border:1px solid #eee; box-shadow: 0 4px 20px rgba(0,0,0,0.04);">
                        ${parsedHTML}
                    </div>`;
                }

                contentHTML += `<div class="ai-output-area" style="margin-top: 15px;">${record.aiContent}</div>`;
                
                document.getElementById('historyModalContent').innerHTML = contentHTML;
                document.getElementById('historyModal').style.display = 'flex';
            }
        };
    } catch (e) { console.error(e); }
}

function closeHistoryModal() {
    document.getElementById('historyModal').style.display = 'none';
}


// === 新增：日期搜尋功能 ===

// 觸發日期選擇器 (為了美觀，用按鈕觸發隱藏的 input)
function triggerDatePicker() {
    const picker = document.getElementById('historyDatePicker');
    if (picker) {
        // 嘗試顯示原生日期選擇器
        try {
            picker.showPicker(); 
        } catch (e) {
            picker.click(); // 舊版瀏覽器 fallback
        }
    }
}

// 執行捲動定位邏輯
function scrollToHistoryDate(inputElement) {
    const selectedDateStr = inputElement.value; // 格式: YYYY-MM-DD
    if (!selectedDateStr) return;

    // 將選擇的日期轉為當天的結束時間戳 (23:59:59)
    // 因為列表是從新到舊排列 (Descending)，我們要找的第一個紀錄應該是
    // 時間戳小於或等於「該日結束」的紀錄
    const selectedDateEnd = new Date(selectedDateStr).setHours(23, 59, 59, 999);
    
    // 獲取所有已渲染的卡片
    const cards = document.querySelectorAll('#historyLevel3 .history-card');
    let targetCard = null;

    // 移除所有舊的高亮
    cards.forEach(c => c.classList.remove('highlighted'));

    // 遍歷卡片尋找目標
    for (let card of cards) {
        const timestamp = parseInt(card.getAttribute('data-timestamp'));
        
        // 邏輯：因為卡片是按時間倒序排列 (最新的在上面)
        // 我們要找的是第一個時間戳「小於或等於」選定日期結束時間的卡片
        // 這代表它是該日期(或該日期之前)最新的一條紀錄
        if (timestamp <= selectedDateEnd) {
            targetCard = card;
            break; // 找到後立即停止
        }
    }

    if (targetCard) {
        // 捲動到該卡片
        targetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        // 添加高亮效果
        targetCard.classList.add('highlighted');
        
        // 檢查是否完全匹配當天 (用於提示)
        const targetDate = new Date(parseInt(targetCard.getAttribute('data-timestamp')));
        const checkDateStr = targetDate.toISOString().split('T')[0];
        
        if (checkDateStr !== selectedDateStr) {
            // 如果找到的卡片不是選定當天的(代表那天沒紀錄)，提示使用者
            // alert(`找不到 ${selectedDateStr} 的紀錄，已定位至最接近的過往紀錄 (${checkDateStr})。`);
            // 上方 alert 可依需求開啟或關閉，通常直接定位即可
        }
    } else {
        alert("找不到該日期或更早之前的紀錄。");
    }
}

	// === 歷史紀錄：標題原地編輯邏輯 ===

/**
 * 啟用標題編輯模式
 * @param {HTMLElement} titleEl - 被雙擊的 h4 元素
 * @param {number} id - 紀錄的 ID
 */
function enableTitleEditing(titleEl, id) {
    // 防止重複觸發 (如果已經是 input 就不動作)
    if (titleEl.querySelector('input')) return;

    const currentText = titleEl.innerText;
    
    // 創建 input 元素
    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentText;
    input.className = 'history-title-input';
    
    // 點擊 input 時也要防止冒泡，以免觸發查看詳情
    input.onclick = (e) => e.stopPropagation();
    input.ondblclick = (e) => e.stopPropagation();

    // 清空原本的標題文字，放入 input
    titleEl.innerHTML = '';
    titleEl.appendChild(input);
    input.focus();

    // 定義儲存並還原的邏輯
    const saveAndRevert = async () => {
        const newTitle = input.value.trim() || currentText; // 如果是空的，還原舊標題
        
        if (newTitle !== currentText) {
            // 如果標題有變更，儲存到 DB
            await updateHistoryTitleInDB(id, newTitle);
        }
        
        // 還原為文字顯示
        titleEl.innerText = newTitle;
    };

    // 事件監聽：失去焦點 (Blur) 或 按下 Enter 鍵時儲存
    input.addEventListener('blur', saveAndRevert);
    input.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            this.blur(); // 觸發 blur 來儲存
        } else if (e.key === 'Escape') {
            // 按 Esc 取消編輯，還原舊文字
            titleEl.innerText = currentText; 
        }
    });
}

/**
 * 更新 IndexedDB 中的標題
 */
async function updateHistoryTitleInDB(id, newTitle) {
    try {
        const db = await openHistoryDB();
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        
        // 1. 獲取舊紀錄
        const getRequest = store.get(id);
        
        getRequest.onsuccess = function(event) {
            const data = event.target.result;
            if (data) {
                // 2. 修改標題
                data.title = newTitle;
                
                // 3. 寫回 DB
                const putRequest = store.put(data);
                putRequest.onsuccess = function() {
                    console.log(`紀錄 ID ${id} 標題已更新為: ${newTitle}`);
                };
            }
        };
    } catch (e) {
        console.error("更新標題失敗:", e);
        alert("標題更新失敗，請重試。");
    }
}

// === 雙擊/單擊 衝突解決方案 ===
let titleClickTimer = null;

/**
 * 處理標題的單擊事件 (延遲觸發查看)
 */
function handleTitleClick(event, id) {
    // 1. 阻止事件冒泡，防止觸發父層的立即查看
    event.stopPropagation();

    // 2. 如果已經有計時器，表示這可能是雙擊過程中的第二次點擊，不做處理
    if (titleClickTimer) return;

    // 3. 設定延遲，如果 250ms 內沒有發生雙擊，才打開視窗
    titleClickTimer = setTimeout(() => {
        viewHistoryDetail(id);
        titleClickTimer = null;
    }, 250); 
}

/**
 * 處理標題的雙擊事件 (取消查看，進入編輯)
 */
function handleTitleDblClick(element, id) {
    // 1. 阻止事件冒泡
    event.stopPropagation();

    // 2. 關鍵：清除單擊產生的計時器！這樣就不會彈出視窗了
    if (titleClickTimer) {
        clearTimeout(titleClickTimer);
        titleClickTimer = null;
    }

    // 3. 進入編輯模式
    enableTitleEditing(element, id);
}
	
	
</script>

<footer class="copyright-footer">
<p> Copyright © 2025 陳冠健. All rights reserved 
<br> 黃子謙於2026/1/9於陳冠健老師授權下複製
<br> 感謝授權🙏</p>
</footer>

<!-- === 大綱編輯懸浮視窗 (修正版) === -->
<!-- === 大綱編輯懸浮視窗 (修正版) === -->
<div id="outline-editor-modal" class="outline-modal-overlay">
    <div class="outline-modal-content">
        <h3 id="modal-title">編輯內容</h3>
        
        <!-- ★★★ 新增：懸浮視窗內的範文選擇器 (預設隱藏) ★★★ -->
        <select id="modal-template-select" style="display: none; margin-bottom: 10px; padding: 8px; font-size: 16px; border: 1px solid #2A9689; border-radius: 5px; background-color: #f0fdfc;">
            <option value="">指定範文</option>
        </select>
        <!-- ★★★ 新增結束 ★★★ -->

        <textarea id="modal-textarea" rows="15"></textarea>
        <div class="modal-buttons">
            <button id="modal-ocr-btn" class="btn-action" style="background-color: #17a2b8;">OCR</button>
            <button id="modal-save-btn" class="btn-action">輸入</button>
        </div>
        <button id="modal-close-btn" class="preview-close-btn" title="關閉">&times;</button>
    </div>
</div>
	<!-- 煙花特效畫布 -->
<canvas id="fireworksCanvas"></canvas>

</body>
</html>
